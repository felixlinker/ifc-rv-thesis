\documentclass{securem}
\usepackage[a4paper]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{enumitem}
\usepackage{csquotes}
\usepackage{tikz}
\usepackage[hidelinks]{hyperref}
\usepackage{syntax}
\usetikzlibrary{positioning,calc,graphs}

\setlength{\grammarindent}{8em}

% fonts
\usepackage{tgpagella}
\usepackage{courier}

\title{Masterthesis Secure-M \\ \large{An outline}}
\author{Felix Linker}
\date{}

\sloppy

\begin{document}

\maketitle

\section{Introduction}

\section{Background}

\subsection{ARM Architecture Reference Manual}

The Arm Architecture Reference Manual (in short: Arm ARM) describes the expected behavior of the Arm architecture for M-, A- and AR-class chips.
Each of these chips is specified by a corresponding Arm ARM which again have different versions reflecting the histority of the architecture(s).

The Arm v8-M ARM for example is sectioned into the following parts:
\begin{enumerate}[label=\Alph*]
    \item \label{itm:arm-intro} Introduction and Overview
    \item \label{itm:arm-rules} Architecture Rules with various subsections
    \item \label{itm:arm-instr} Instruction Set
    \item \label{itm:arm-reg} Registers
    \item \label{itm:arm-pseudo} Pseudocode
    \item \label{itm:arm-prots} Debug Packet Protocols
\end{enumerate}

Whilst this structure is unique to the v8-M ARM, it covers all major points that are brought up in an Arm ARM.
We will skip parts \ref{itm:arm-intro} and \ref{itm:arm-prots} in our introduction to the Arm ARM as they don't specify major aspects of the architecture.
Part \ref{itm:arm-rules} lists a number of rules that describe how the Arm M-class architecture works in its core.
In general, three types of rules can be found\footnote{In what follows, we will give examples for rules, however, these examples are not always accurate. For the sake of clarity, we will leave out parts of them.}:
\begin{enumerate}
    \item Rules that define concepts, e.g.:
    \begin{displaycquote}{Armv8M}
        \begin{description}
            \item[R\textsubscript{QLHB}]
            The return address is one of the following:
            \begin{itemize}
                \item For a synchronous exception, \textelp{} the address of the instruction that caused the exception.
                \item For an asynchronous exception, the address of the next instruction in the program order. \textelp{}
            \end{itemize}
        \end{description}
    \end{displaycquote}

    \item Rules that define transitions, e.g.:
    \begin{displaycquote}{Armv8M}
        \begin{description}
            \item[R\textsubscript{VLDB}] When a pending exception has a lower group priority value than current execution, \textelp{} the pending exception preempts current execution.
        \end{description}
    \end{displaycquote}

    \item Rules that define actions, e.g.:
    \begin{displaycquote}{Armv8M}
        \begin{description}
            \item[R\textsubscript{YFHR}] An exception that does not cause lockup sets both:
            \begin{itemize}
                \item The pending bit of its handler, or the pending bit of the HardFault handler, to 1.
                \item The associated fault status information.
            \end{itemize}
        \end{description}
    \end{displaycquote}
\end{enumerate}

These rules are the core of the Arm ARM and describe the general behavior of an architecture.

Parts \ref{itm:arm-instr} and \ref{itm:arm-reg} specify the structure, usage and semantics of instructions and registers of the architecture; the details of these parts are not important for now.

Part \ref{itm:arm-pseudo} lists some pseudocode variables and functions that are used within the specifications of instruction behavior.
These are meant to clarify what instructions do.
The pseudocode is written in a simple but fully-fledged programming language called Architecture Specification Language (in short: ASL).

\subsection{Architecture Specification Language}

It is a major aspect of the Arm ARM that it is accompanied by pseudocode.
This pseudocode one the one hand clarifies parts of the Arm ARM written in natural language and on the other hand forms a basis for a simulation of the architecture.

At Arm, the pseudocode of the Arm v8-M ARM has been taken and was formed into an executable model of the M-class architecture.
An interpreter called \textit{archex} has been written that can execute ASL commands and simulate the architecture as a whole.

In his paper \textit{Who Guards the Guards? Formal Validation of the Arm v8-M Architecture Specification} Alastair Reid describes ASL as follows:

\begin{displaycquote}{Reid17}
    % TODO: example code and inline-asl highlighting
    At a high level, ASL is an indentation-sensitive,imperative, strongly-typed, first-order language with type inference, exceptions, enumerations, arrays, records, and no pointers.
    All integers in ASL are unbounded and there is direct support for N-bit bitvectors and functions are allowed to be polymorphic in the width of a bitvector.
    For example, memory read returns a value of type bits(8*size) where size is constrained to be 1, 2, 4 or 8.
\end{displaycquote}

This ASL-implementation of the Arm ARM forms a meta-model which describes (or at least should describe) the mechanisms that all implementations of the architecture must comply with.

\subsection{Property Specification Language}

The property specification language (in short: PSL) is a language that is best understood as meta-level ASL and was introduced by Alastair Reid in \cite{Reid17} as a means to verify the pseudocode model of the Arm v8-M ARM against the rules in the specification.

Its foremost purpose therefore is to express rules of the Arm ARM in a formal language.
In PSL you can \textit{talk about} ASL executions.
At its heart, PSL consists of properties and invariants.
A property states that a given formal expression should hold after a given ASL run, an invariant states that a given formal expression should hold before and after a given ASL run.
These formal expressions - for now - can be understood as simple propositional logic.
Furthermore, there are assumptions.
Assumptions fulfill two purposes: they enhance readability and they reduce redundancy.
As properties and invariants are equivalent to formulas of propositional logic they have a concept of assumptions embedded; when expressing the property "Property $ \varphi $ shall hold but only if $ \psi $ holds as well" you could always replace $ \varphi $ with $ \psi \rightarrow \varphi $.
However, writing assumptions seperatly turned out to improve readability and seperate property from assumption more clearly and makes them applicable to multiple propeties/invariants.

The main keywords of PSL are: \pslinline{rule}, \pslinline{assume}, \pslinline{property} and \pslinline{invariant}.
These keywords form a tree.
Each rule can have multiple sub-assumptions, -properties, -invariants and -rules latter of which again can have sub-assumptions, -properties, etc.
Rules, assumptions, properties and invariants can be compared to a file-tree where rules are folders and assumptions/properties/invariants are files.
Here is an example of how a PSL rule might look:

\begin{psl}
rule r
    assume A1;
    property p1 #\textit{<expression>}#;

    rule r_1
        property p2 #\textit{<expression>}#;
        assume A2;
        invariant i1 #\textit{<expression>}#;
\end{psl}

\pslinline{A1} and \pslinline{A2} are expressions whereas \pslinline{r}, \pslinline{r_1}, \pslinline{p1}, \pslinline{p2} and \pslinline{i1} are names.
Assumptions are applied to all properties and invariants that come after them.
This means that assumption \pslinline{a1} is applied to all properties and invariants in the example whereas assumption \pslinline{a2} only is applied to \pslinline{i1}.

Properties and invariants are dealt with seperately, the nesting of rules only is handy for nesting assumptions and grouping similar properties.
This means that our first example is basically the same as:

\begin{psl}
property p1 A1 IMPLIES #\textit{<expression>}#;
property p2 A1 IMPLIES #\textit{<expression>}#;
invariant 1 (A1 && A2) IMPLIES #\textit{<expression>}#;
\end{psl}

A formal definition\footnote{Only lacking the formalization of the necessary indentation.} of this structure is given by the following Backus-Naur-grammar:

\begin{grammar}
    <statement> ::= <rule>
        \alt `property' <denominator> <expression> `;'
        \alt `invariant' <denominator> <expression> `;'

    <rule> ::= `rule' <denominator> \\
        <body>

    <body> ::= <body-statement>
        \alt <body-statement> \\
        <body>

    <body-statement> ::= `assume' <expression> `;'
        \alt <statement>
\end{grammar}

But what is the actual content of expressions in PSL?
Basically just ASL code that evaluates to boolean (with a grain of salt).
This grain of salt consists of syntactic sugare - which we will ignore for now - and the \pslinline{Past} keyword.
Remember when we said that the idea of PSL was to talk about \textit{runs} of ASL.
More precisely, those runs consist of three stages:
First, there is a pre-state, then there is the actual run/ASL code execution, then there is a post-state.
Rules of PSL can only talk about pre- and post-state of such ASL runs\footnote{Beware: Indirectly, in PSL you can also talk about what has happened in that run but only because this makes it much easier to talk about the architecture. We will come to this at a later point.}.
Expressions in assumptions and properties - by default - are evaluated in post-state.
This means that an assumption - by default - means: "If after the execution of the given ASL code, this expession evaluates to true, then check the following properties/invariants".
The \pslinline{Past} keyword allows you to talk about the pre-state as well.
It will take ASL code as an argument and evaluate the content of it in the pre-state.

Furthermore, these two groups of keywords are support:
\begin{enumerate}
    \item \pslinline{Stable}, \pslinline{Changed}, \pslinline{Rose}, \pslinline{Fell}
    \item \pslinline{Called}, \pslinline{Returned}
\end{enumerate}

The first group was introduced as:
\begin{displaycquote}{Reid17}
    \textins{W}e define syntactic sugar for some common uses of the Past operator.
    \begin{align*}
        Stable(e) \widehat{=} Past(e) = e \\
        Changed(e) \widehat{=} Past(e) \neq e \\
        Rose(e) \widehat{=} Past(e) < e \\
        Fell(e) \widehat{=} Past(e) > e
    \end{align*}
    By abuse, Rose and Fell can also be applied to boolean expressions.
\end{displaycquote}

The second group more accurately could be described as semantic- but syntactic-sugar.
It was introduced to more easily talk about pre- and post-states.
They were introduced to tacke the following problem:
\begin{displaycquote}{Reid17}
    The classic approach to writing properties is to write invariant properties and function properties using predicates that refer only to the state of the system before and after the state transition function.
    Our decision to limit ourselves to writing end-to-end properties makes it very hard to capture key properties only in terms of states.
    For example, some properties will only apply if the system takes a certain kind of transition such as taking a reset or an exception but these are hard properties to observe from the state alone.
    In principle, we could reverse engineer the initial conditions under which these events could occur but then we would be reasoning about when we think certain transitions occur instead of what the specification actually says.
\end{displaycquote}

The \pslinline{Called} and \pslinline{Returned} keywords therefore are in place to check whether the architecture did certain transitions.
\pslinline{Called} will evaluate to true if a given function has been called in the ASL run and \pslinline{Returned} will evaluate to true if a given function also has returned in the ASL run.

\section{Towards a Labeled State Transition System}

We already said the the ASL model of the M-class architecture forms a meta-model.
ASL provides some keywords that give a programmed model some flexibility, the most important of which are:
\aslinline{UNKNOWN}, \aslinline{UNPREDICTABLE} and \aslinline{IMPLEMENTATION_DEFINED}.

\paragraph{\aslinline{UNKNOWN}} is an expression that can evaluate to any type.
Any variable in ASL can be initialized with \aslinline{UNKNOWN}.
Especially, some registers of the architecture are initialized with \aslinline{UNKNOWN} to indicate that programmers can't rely on the fact that, e.g., registers are always zero on start-up.

\paragraph{\aslinline{UNPREDICTABLE}} is some form of global exception.
It is used in contexts where further behavior of the architecture is not specified and implementations can do \textit{whatever they want}.

\paragraph{\aslinline{IMPLEMENTATION_DEFINED}} marks a point where implementers of the architecture have some form of flexiblity regarding their design choices.

When simulating the architecture using archex, these keywords will be evaluated either by a set context (for example in the case of \aslinline{IMPLEMENTATION_DEFINED}) or archex makes choices at random, e.g. initializes an integer of value \aslinline{UNKNOWN} with a random number.

This also means that the ASL meta-model of the architecture induces a set of transition systems which all implementations of the architecture must be a member of in order to comply with the specification.

\begin{definition}[\cite{Baier08}\footnote{In their book, Bair and Katoen also consider a set of action for state transition systems. As we don't use actions in our system modeling, we will ignore actions in definitions and alter those accordingly.}]
    A \textit{transition system} $ TS $ is a tuple $ (S, \rightarrow, I, AP, L) $ where

    \begin{itemize}
        \item $ S $ is a set of states,
        \item $ \rightarrow \; \subseteq S \times S $  is a transition relation,
        \item $ I \subseteq S $ is a set of initial states,
        \item $ AP $ is a set of atomic propositions, and
        \item $ L : S \rightarrow 2^{AP} $ is a labeling function.
    \end{itemize}

    For $ (s, s') \in \rightarrow $ we write $ s \rightarrow s' $.
\end{definition}

The states of the transition systems are so called \textit{architectural states} which are the conjunction of all registers and memory values.
These (module implementation details) deterministically determine a next state, i.e. for a given implementation $ \rightarrow $ is a function.

% TODO: more details about the verification process

At Arm, great progress was made for veryfying the architectural meta-model written in ASL against the natural language rules of the Arm ARM details of which can be found in \cite{Reid17}.
However, this verification progress is best to be understood as a verification of the correctness of the meta-model, i.e. it checks whether the set of transition-systems induced by the model is the correct set with respect to the rules in the Arm ARM.

In this process, problems of the rules in the Arm ARM might come to light - even potentially critical ones.
But the verification process itself does not prove any more abstract properties about the model, contributing to the \textit{security} of the architecture.

\subsection{Linear Temporal Logic}

Such more abstract properties can be expressed in linear temporal logic (in short: LTL).
The idea of LTL is to talk about transition systems.
LTL formulas have transition systems as model.
But before LTL formulas can be introduced more formally, we need to go into more details of transition systems.

Let $ TS = (S, \rightarrow, I, AP, L) $ be a transition system.

\begin{definition}[\cite{Baier08}]
    For $ s \in S $, the set of direct \textit{successors} of $ s $ is defined as:
    \begin{equation}
        Post(s) = \{ s' \in S \mid s \rightarrow s' \}
    \end{equation}
\end{definition}

\begin{definition}[\cite{Baier08}]
    A \textit{finite} path fragment $ \widehat{\pi} $ of $ TS $ is a finite state sequence $ s_0 s_1 \dots s_n $ such that $ s_i \in Post(s_{i - 1}) $ for all $ 0 < i \leq n $, where $ n \geq 0 $.
    An \textit{infinite} path fragment $ \pi $ is an infinite state sequence $ s_0 s_1 s_2 \dots $ such that $ s_i \in Post(s_{i - 1}) $ for all $ i > 0 $.
\end{definition}

\begin{definition}[\cite{Baier08}]
    A \textit{maximal} path fragment is either a finite path fragment that ends in a terminal state, or an infinite path fragment.
    A path fragment is called \textit{initial} if it starts in an initial state, i.e., if $ s_0 \in I $.
\end{definition}

\begin{definition}[\cite{Baier08}]
    A \textit{path} of a transition system $ TS $ is an initial, maximal path fragment.

    Let $ Paths(TS) $ denote the set of all paths in $ TS $.
\end{definition}

\begin{definition}[\cite{Baier08}]
    The \textit{trace} of the infinite path fragment $ \pi = s_0 s_1 \dots $ is defined as $ trace(\pi) = L(s_0) L(s_1) \dots $.
    The trace of the finite path fragment $ \widehat{\pi} = s_0 s_1 \dots s_n $ is defined as $ trace(\widehat{\pi}) = L(s_0) L(s_1) \dots L(s_n) $.

    The trace of a path fragment is thus the induced finite or infinite word over the alphabet $ 2^{AP} $, i.e., the sequence of sets of atomic propositions that are valid in the states of the path.
    The set of traces of a set $ \Pi $ of paths is defined in the usual way:
    \begin{equation}
        trace(\Pi) = \{ trace(\pi) \mid \pi \in \Pi \}
    \end{equation}

    A trace of state $ s $ is the trace of an infinite path fragment $ \pi $ with $ \pi = s_0 s_1 \dots $.
    Let $ Traces(s) $ denote the set of traces of $ s $, and $ Traces(TS) $ the set of traces of the initial states of the transition system $ TS $:
    \begin{equation}
        Traces(s) = trace(Paths(s))
    \end{equation}
    \begin{equation}
        Traces(TS) = \bigcup_{s \in I} Traces(s)
    \end{equation}
\end{definition}

With these definitions equipped, we can define what a linear-time property is.

\begin{definition}[\cite{Baier08}]
    A \textit{linear-time property} (LT property) over the set of atomic propositions $ AP $ is a subset of $ (2^{AP})^\omega $.

    Here, $ (2^{AP})^\omega $ denotes the set of words that arise from the infinite concatenation of words in $ 2^{AP} $.
    An LT property is thus a language (set) of infinite words) over the alphabet $ 2^{AP} $.
\end{definition}

\begin{definition}[\cite{Baier08}]
    Let $ P $ be an LT property over $ AP $ and $ TS = (S, \rightarrow, I, AP, L) $ without terminal states.
    Then $ TS $ \textit{satisfies} $ P $, denoted $ TS \models P $, iff $ Traces(TS) \subseteq P $.
    States $ s $ satisfies $ P $, notation $ s \models P $, whenever $ Traces(s) \subseteq P $.
\end{definition}

Baier and Katoen limit themselves to transition systems without terminal state because transition systems \textit{with} terminal state can be transformed into equivalent transition systems without such states.
For this transformation, simply add a new state $ s_{\text{stop}} $ to the transition system that loops itself forever and let all formerly terminal states transit into this new state.

At this point, we will stop with the formal introduction of LTL as the main point has already been made with LT properties.
LTL formulas serve as a description language for LT properties - more precisely, a LTL formula induces a LT property.
Therefore, satisfies-relation of LTL formulas in the end boils down to the satisfies-relation of LT properties.

\section{Goals of the Thesis}

The core problem of expressing properties about the ASL meta-model is twofold.

Firstly, the meta-model must be represented by a sole non-deterministic transition-system.
The challenge herein lies in modelling the non-determinism of keywords such as \aslinline{UNDEFINED}, \aslinline{UNPREDICTABLE} or \aslinline{IMPLEMENTATION_DEFINED} accurately.
Whereas non-deterministic choices in regards to \aslinline{UNDEFINED} or \aslinline{UNPREDICTABLE} do not need to be restricted as an implementation is allowed to choose new values/actions again and again, non-deterministic choices in regards to \aslinline{IMPLEMENTATION_DEFINED} need to be consistent with one another.
Another challenge will be to extract the transition relation from the machine readable specifcations of the Arm architecture that are already available in the first place.

Secondly, the current form of machine-readable specifications of the Arm architecture does not have a notion of \textit{atomic propositions} or a \textit{labeling function} as is needed to form a transition system and especially to express LTL formulas.

As an additional problem, one should investigate how PSL could be utilized to minimize the resulting non-deterministic transition-system in regards to its label function.
This would not only provide performance benefits for checking properties that could now be expressed but could also contribute towards the readability and intuitiveness of LTL formulas or the labels of the transition system.

It should be a goal of this thesis to find a labeling function that matches the view of the developers of the architecture such that LTL formulas satisfy the same goals that were set for PSL formulas.
As Reid described it in his paper:
\begin{displaycquote}{Reid17}
    \textins{Properties \dots}
    \begin{itemize}
        \item \textins{should} express major guarantees that programmers depend on;
        \item are concise so that architects can easily review and remeber the entire set of properties;
        \item are stable so that archticture extensions don't invalidate large numbers of rules;
        \item \textelp{} describe the the architecture differently from the existing specification to reduce the risk of common-mode failure.
    \end{itemize}
\end{displaycquote}

These three points are the goals of a potential masterthesis about for the project Secure-M.

\bibliography{references}
\bibliographystyle{alpha}

\end{document}
