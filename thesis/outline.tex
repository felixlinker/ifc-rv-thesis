\documentclass{securem}
\usepackage[a4paper]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{enumitem}
\usepackage{csquotes}
\usepackage{tikz}
\usepackage[hidelinks]{hyperref}
\usepackage{syntax}
\usepackage[euler]{textgreek}
\usetikzlibrary{positioning,calc,graphs}

\setlength{\grammarindent}{8em}

% fonts
\usepackage{tgpagella}
\usepackage{courier}

\newcommand{\muZ}{{\textmu}Z}

\title{Master-thesis Secure-M \\ \large{An outline}}
\author{Felix Linker}
\date{}

\sloppy

\begin{document}

\maketitle

\section{Introduction}

In \cite{Ferraiuolo17} the authors present an approach to formally verifying the ARM TrustZone architecture by using static information flow analysis.
They apply the method of information flow control (IFC) to the hardware description language (HDL) implementing said architecture.
They approach mainly consists of two things: A lattice of security labels and type-system rules that define how information flows through the HDL code.
Intuitively, it is allowed for information to flow "up" the lattice but not "down".

The goal of this project is to apply this approach of using security labellings to model information flow to the process of model checking an architectural model of a microprocessor with multiple privilege levels.
The model checker will quantify over programs running on the microprocessor and check properties like: "It is not possible for secure information stored at point Y to leak".
Such "point" at which information might be stored, include registers and memory of the micro-controller.
In a 32-bit architecture, this gives us $ (R \cdot 32 + M \cdot 8)^2 $ implicit properties to check where $ R $ is the number of registers and $ M $ is the number of bytes in memory - for each bit in registers and memory, we can check whether information can leak to any other bit in registers or memory.
We expect to find programs that will violate such properties simply because privileged code can do \textit{anything} that is also leaking information.

This approach must not be seen as an attempt to formally verify the security of an architecture itself.
It is an attempt to find program patterns that can leak information and finding rules that - when complied with - guarantee the absence of such leaks.
We will however also have in mind that a IFC formalism might not be able to find \textit{all} issues that can arise during the programming of micro-controllers.
Therefore another goal of this project is to explore the power of a labeled-IFC approach.

\section{Background}

\subsection{RISC-V}

RISC-V (RISC stands for \textbf{R}educed \textbf{I}nstruction \textbf{S}et \textbf{C}omputer) is a modular processor architecture specification.
RISC-V as we will view it here is specified by two documents, the RISC-V User Level ISA \cite{RiscVISA} and the RISC-V Privileged Architectures manuals \cite{RiscVISAP}.
The User Level ISA describes the basic functionality of the processor which is divided into several modules, e.g. integer arithmetic, floating point arithmetic, debugging, that can freely be combined with each other.
The only necessity for each RISC-V CPU is to implement the integer arithmetic module.

The modularity of the RISC-V architecture allows implementors to easily build very simple and small processors, that still are fully compliant with the specification.

In this thesis, we will model check the RISC-V architecture.
We will use the base integer instruction set, the standard extension for user-level interrupts and the privileged architecture to model a micro-controller that has all basic instructions needed to perform computational tasks, support for interrupts and exceptions and two or more privilege modes - thus all function necessary to have sufficient complexity in computing but not too many features to make our undertaking infeasible.

\subsection{\muZ{}}

\muZ{} is a engine that computes fixed points with constraints and comes with the SMT-solver Z3 from Microsoft Research and was introduced in \cite{Hoder11}.
As input \muZ{} receives a set of relations and rules (Horn clauses) utilizing those relations.
Facts can be expressed by rules that have an empty body, e.g. $ R := \emptyset \Rightarrow x $ or $ R := \top \Rightarrow x $.
\muZ{} accepts Datalog and SMT as input languages.

\muZ{} solves queries, whether certain rules are derivable.
This can be used in model checking by using relations to model program states and rules to model program transitions.
For example, consider a program, where an integer counter is initialized to zero and then incremented indefinitely.
We could model this program using rules and relations in SMT as follows:

\begin{smt2}
(declare-rel t (Int))
(declare-rel fail ())

(rule (t 0))

(declare-var x Int)
(rule   (=> (t x)
            (t (+ x 1))))
(rule   (=> (and (t x) (< x 0))
            fail))

(query fail)
\end{smt2}

In this example, \smt{t} is the program state and \smt{fail} models a failed state that is reached when the counter variable is strictly smaller than zero.
We can use \muZ{} to verify that this fail-state will never be reached.

In this thesis, we will use \muZ{} to perform the model checking and will attempt to translate the type system rules of \cite{Ferraiuolo17} into transition rules in SMT.

\subsection{SPACER}

SPACER is an algorithm that uses a Datalog engine to perform automated abstraction on Horn-clauses expressed in propositional Linear Rational Arithmetic and was proposed in \cite{Komuravelli13}.
It combines two approaches of automatic abstraction in model checking: proof based abstraction (PBA) and counterexample-guided abstraction refinement (CEGAR).
Categorically, SPACER and \muZ{} perform the same type of tasks.
Queries solvable by SPACER can also be solved by \muZ{}.
However, SPACER claims to beat \muZ{} in performance giving examples of problem instance that have been solved by SPACER in under a minute whereas \muZ{} was not seen to terminate.
Additionally, SPACER gives better output than \muZ{} as for positive instances of queries proofs and for negative queries counterexamples are given.

If the scope of the project does allow for it, we will try to implement SPACER such that it also can work with a theory of bit vectors and thus be applied to the process of model checking a processor specification.

\section{Project Plan}

The project divides itself into the following steps:
\begin{enumerate}
    \item Development of a simplified architectural model which should include
    \begin{itemize}
        \item Protected system control registers
        \item General purpose registers
        \item A model of memory with secure and non-secure regions
        \item At least 8 instructions: load immediate, load, store, add, subtract, compare, branch, enter privileged mode, leave privileged mode
    \end{itemize}
    \item Formal implementation of the architectural model in SMT
    \item Verification
    \begin{itemize}
        \item Verification can be done straight-forward but it might be advisable to use algorithms like SPACER to enhance performance and output
    \end{itemize}
    \item Iteration \& refinement
    \item Evaluation
\end{enumerate}

\bibliography{references}
\bibliographystyle{alpha}

\end{document}
