\chapter{Counter-Examples to Information Flow Properties}

\section{Assumption Related Counter-Examples}
\label{app:cexs}

In this section, the counter-examples associated with the assumptions which resulted from the prove-refine loop as presented in section \ref{sec:assumptions} will be presented.
The structure of section \ref{sec:assumptions} will be adopted, i.e. counter-examples will be presented in order of the three groups of mode-boundary crossing related, memory related and memory privilege related assumptions.

\paragraph{Mode-boundary crossing related assumptions}
There are two mode-boundary crossing related assumptions: \smv{SAN_ON_CALL} and \smv{CLR_ON_RET}, demanding from machine-mode to sanitize registers when being called from user-mode and clearing registers when returning control to user-mode.

Without assuming \smv{SAN_ON_CALL} nuXmv manages to find two counter-examples.
One for property \smv{MEMORY_OP_INTEGRITY} (\ref{itm:prop-mem-i}) and one for \smv{CSR_INTEGRITY} (\ref{itm:prop-csr-i}).
The traces for both counter-examples are depicted in tables \ref{tbl:cex-mem-i-soc} and \ref{tbl:cex-csr-i-soc} respectively.
Table \ref{tbl:cex-no-leak-cor} illustrates a counter-example for the \smv{NO_LEAK} (\ref{itm:prop-no-leak}) property when not assuming \smv{CLR_ON_RET}.

\begin{example}
    The format of these tables illustrating counter-example traces will be used frequently to illustrate counter-examples.
    To introduce it, table \ref{tbl:cex-mem-i-soc} will be explained in detail now.
    The first row of the table gives the processor's initial state.
    Each subsequent row of the table represents an instruction being executed and shows the values that have changed in result of this instruction.
    Whenever a cell is empty, the value represented by it did not change.
    Furthermore, the table is separated in three main columns: The first column shows the instructions being executed.
    In case of table \ref{tbl:cex-mem-i-soc}, three instructions were executed: \minrv{Ecall}, \minrv{Load} and \minrv{Store}.

    The second group of columns hold the information flow labels for the registers and memory on a per-word basis.
    During the verification process it was found that no counter-example required information flow labels of a per-bit granularity.
    Therefore, for the sake of simplicity, the information flow labels of machine-words in memory or registers were combined to a single label\footnote{
        The labels have been combined by using the $ \sqcup $ operator, i.e. for a label $ w $, the combined label is $ \bigsqcup_{i} w_i $.
    }.
    The two inner rows in the cells of the second major column denote the labels of the registers (\minrv{r}) and memory (\minrv{m}) respectively whereas the inner columns mark the index of the labels, e.g. in table \ref{tbl:cex-mem-i-soc} all registers and the cells of memory region zero are labelled with \PU{}, i.e. public and untrusted, whereas the cells of memory region one are labelled with \PT{}, i.e. public and trusted, in the initial state.

    The third major column shows the status of the processor.
    This column is separated into five inner columns as well.
    The first (labelled with \minrv{p}) shows the privilege mode of execution where \minrv{U} stands for user-mode and \minrv{M} stands for machine-mode.
    The other four columns show the current memory settings per region.
    Inner columns starting with \minrv{0} give the settings for first memory region and starting with \minrv{1} for the second memory region respectively.
    Inner columns ending with \minrv{c} hold the cacheability settings.
    Here, \minrv{UN} stands for uncacheable, \minrv{WB} for write-back-cacheable, \minrv{WT} for write-through-cacheable and \minrv{WP} for write-protected-cacheable (cf. section \ref{sec:minrv8}).
    Inner columns ending with \minrv{p} hold the memory privilege settings for the respective region.
    Memory privilege settings are indicated by a string of the form:
    \begin{grammar}
        <privelege-string> ::= (`-' | `L') (`-' | `R') (`-' | `W')
    \end{grammar}

    The first letter in the privilege string denotes whether the region is locked (\minrv{L}) or not (\minrv{-}), the second whether user-mode can read the region (\minrv{R}) or not (\minrv{-}) and the third whether user mode can write to the region (\minrv{W}) or not (\minrv{-}).
    In table \ref{tbl:cex-mem-i-soc}, none of the regions is locked or cacheable and user mode can write to region zero only and has not further permissions.

    Traces generated by nuXmv are infinitely long but finitely representable by including a loop.
    In this setting, counter-examples generated by nuXmv always violated the property at hand after having executed the second last instruction whereas the last instruction introduced the loop and led to a fixpoint in the state-space.
    For the sake of completeness, the last instruction of counter-example traces will be included nonetheless.
\end{example}

Note that the traces for property \smv{MEMORY_OP_INTEGRITY} in table \ref{tbl:cex-mem-i-soc} and for property \smv{CSR_INTEGRITY} in table \ref{tbl:cex-csr-i-soc} are very similar.
In both traces, the processor starts in user-mode with some untrusted data in the registers.
User-mode then calls machine-mode which decides to use the contents of the registers without sanitization to either write a \gls{csr} or to memory.
The violation of property \smv{NO_LEAK} (\ref{itm:prop-no-leak}) depicted in table \ref{tbl:cex-no-leak-cor} when not assuming \smv{CLR_ON_RET} is analogously simple.
Since machine-mode directly hands over confidential data to user-mode by returning control to user-mode without clearing its registers, user-mode trivially gains access to secrets.
It is obvious that such flows of information are no fault of the architecture but must be fought in programming, i.e. in compilers or \gls{os} programming.
As such, we express sufficient techniques to combat vulnerabilities of this kind in aforementioned assumptions.

\begin{table}
    \begin{subtable}{\textwidth}
        \centering
        \input{../results/SANITIZE-ON-CALL/MEMORY-OP-INTEGRITY.tex}
        \caption{\smv{MEMORY_OP_INTEGRITY} (\ref{itm:prop-mem-i})}
        \label{tbl:cex-mem-i-soc}
    \end{subtable}

    \begin{subtable}{\textwidth}
        \centering
        \input{../results/SANITIZE-ON-CALL/CSR-INTEGRITY.tex}
        \caption{\smv{CSR_INTEGRITY} (\ref{itm:prop-csr-i})}
        \label{tbl:cex-csr-i-soc}
    \end{subtable}

    \begin{subtable}{\textwidth}
        \centering
        \input{../results/CLEAR-ON-RET/NO-LEAK.tex}
        \caption{\smv{NO_LEAK} (\ref{itm:prop-no-leak})}
        \label{tbl:cex-no-leak-cor}
    \end{subtable}
    \caption{Counter-examples for \smv{SAN_ON_CALL} and \smv{CLR_ON_RET}}
\end{table}

\paragraph{Memory related assumptions}
As for mode-boundary crossing related assumptions, there are two memory related assumptions \smv{NO_PUBLIC_READS} and \smv{NO_PUBLIC_WRITES} that prohibit machine-mode to either read from or write to memory that is also accessible to user-mode.

The three counter-examples involved in this two assumptions are straight-forward as well.
If machine-mode is allowed to load arbitrary words from public memory nuXmv gives a counter-example to the properties \smv{MEMORY_OP_INTEGRITY} (\ref{itm:prop-mem-i}) and \smv{CSR_INTEGRITY} (\ref{itm:prop-csr-i}) where some or all memory is untrusted in the initial state, machine-mode in the next step decides to load some word from an untrusted source in memory and then uses that as target address of a \minrv{Store} instruction or to write a \gls{csr} with.
These counter-examples are illustrated in table \ref{tbl:cex-mem-i-npw} and \ref{tbl:cex-csr-i-npw} respectively.
On the other hand, if machine-mode is allowed to store arbitrary words into public memory, a simple counter-example to the \smv{NO_LEAK} property (\ref{itm:prop-no-leak}) is that machine-mode simply stores a secret into public memory which is then loaded by user-mode as illustrated by the trace in table \ref{tbl:cex-no-leak-npw}.

Additionally, in this counter-example the consequences of assuming \minrv{CLR_ON_RET} can be seen.
Machine-mode tries to hide secrets from user-mode by writing a public value into register zero before returning which is mandated by aforementioned assumption.
Yet, as shown in the last paragraph, this assumption taken alone, does not ensure the absence of \smv{NO_LEAK} related counter-examples.

\begin{table}
    \begin{subtable}{\textwidth}
        \centering
        \input{../results/NO-PUBLIC-READS/MEMORY-OP-INTEGRITY.tex}
        \caption{\smv{MEMORY_OP_INTEGRITY} (\ref{itm:prop-mem-i})}
        \label{tbl:cex-mem-i-npw}
    \end{subtable}

    \begin{subtable}{\textwidth}
        \centering
        \input{../results/NO-PUBLIC-READS/CSR-INTEGRITY.tex}
        \caption{\smv{CSR_INTEGRITY} (\ref{itm:prop-csr-i})}
        \label{tbl:cex-csr-i-npw}
    \end{subtable}

    \begin{subtable}{\textwidth}
        \centering
        \input{../results/NO-PUBLIC-WRITES/NO-LEAK.tex}
        \caption{\smv{NO_LEAK} (\ref{itm:prop-no-leak})}
        \label{tbl:cex-no-leak-npw}
    \end{subtable}
    \caption{Counter-examples for \smv{NO_PUBLIC_WRITES} and \smv{NO_PUBLIC_READS}}
\end{table}

\paragraph{Memory privilege related assumptions}
Lastly, the four memory privilege related assumptions will be considered now.
In general, these express that machine-mode must ensure that no malicious data lies and no secrets remain in memory or cache memory or cache of a region to be locked down to user-mode.
The assumptions \smv{SAN_ON_CLASSIFICATION} and \smv{CLR_ON_DECLASSIFICATION} ensure this for the actual memory and \smv{SAN_CACHE_ON_CLASSIFICATION} and \smv{CLR_CACHE_ON_DECLASSIFICATION} for the cache.

The counter-examples when not assuming \smv{SAN_ON_CLASSIFICATION} for properties \smv{MEMORY_OP_INTEGRITY} and \smv{CSR_INTEGRITY} (cf. tables \ref{tbl:cex-csr-i-socl}, \ref{tbl:cex-mem-i-socl}) - as usual - work analogously and illustrate exactly what has been given as intuition for this assumption in the introduction of this paragraph.
In each counter-example, at least one memory region initially is writable for user-mode and contains untrusted data.
Machine-mode changes the privilege settings of that memory region making it non-writable to user-mode and then loads and uses a machine-word which is untrusted violating the respective integrity related property.

The counter-example given when not assuming \smv{CLR_ON_DECLASSIFICATION} is given in table \ref{tbl:cex-no-leak-cod}.
The architecture starts with some confidential data in the memory of the first memory region which is not publicly readable.
In the first step, machine-mode however sets just that memory to being publicly readable.
Machine-mode does clear its registers before giving control back to user-mode, yet this is irrelevant since user-mode can just load the contents from the now accessible memory region one which violates the \smv{NO_LEAK} property (cf. \ref{itm:prop-no-leak}).

\begin{table}
    \begin{subtable}{\textwidth}
        \centering
        \input{../results/SANITIZE-ON-CLASSIFICATION/MEMORY-OP-INTEGRITY.tex}
        \caption{\smv{MEMORY_OP_INTEGRITY} (\ref{itm:prop-mem-i})}
        \label{tbl:cex-mem-i-socl}
    \end{subtable}

    \begin{subtable}{\textwidth}
        \centering
        \input{../results/SANITIZE-ON-CLASSIFICATION/CSR-INTEGRITY.tex}
        \caption{\smv{CSR_INTEGRITY} (\ref{itm:prop-csr-i})}
        \label{tbl:cex-csr-i-socl}
    \end{subtable}

    \begin{subtable}{\textwidth}
        \centering
        \input{../results/CLEAR-ON-DECLASSIFICATION/NO-LEAK.tex}
        \caption{\smv{NO_LEAK} (\ref{itm:prop-no-leak})}
        \label{tbl:cex-no-leak-cod}
    \end{subtable}
    \caption{Counter-examples for \smv{CLR_ON_DECLASSIFICATION} and \smv{SAN_ON_CLASSIFICATION}}
\end{table}

Coming to the assumptions that constrain interaction with cache, the counter-examples given by nuXmv are not completely straight forward.
As a start, consider the counter-examples generated when not assuming \smv{SAN_CACHE_ON_DECLASSFICATION} for the \smv{MEMORY_OP_INTEGRITY} property in table \ref{tbl:cex-mem-i-scocl}.
In the first instruction, machine-mode sets memory region one to be inaccessible by user-mode which does not violate assumption \minrv{SAN_ON_CLASSIFICATION} since all memory provides trusted values.
In the next instruction, machine-mode decides to load a word from memory which happens to be untrusted.
This must come from cache since no other memory cell matches this label.
This is only possible because memory region one is set to be write-back-cacheable where writes not necessarily must be reflect in memory.
This word is then used as address for a \minrv{Load} instruction violating property \ref{itm:prop-mem-i}.
The counter-example for property \smv{CSR_INTEGRITY} (\ref{itm:prop-csr-i}) depicted in table \ref{tbl:cex-csr-i-scocl} follows the same pattern and therefore will not be handled separately in this context.

The trace generated to prove the \smv{NO_LEAK} property (\ref{itm:prop-no-leak}) wrong when not assuming \minrv{CLR_CACHE_ON_DECLASSIFICATION} flips the integrity related counter-examples.
It is given in table \ref{tbl:cex-no-leak-ccod}.
Here, memory region zero is set to be write-back-cacheable.
This time though, machine-mode declassifies it in the first instruction as opposed to the previous counter-examples where the respective region was being classified.
Machine-mode then gives back control to user-mode which performs a load.
Again, a mysterious confidential word appears in register three which must have come from the cache of memory region one since only this region is accessible to user-mode.

\begin{table}
    \begin{subtable}{\textwidth}
        \centering
        \input{../results/SANITIZE-CACHE-ON-CLASSIFICATION/MEMORY-OP-INTEGRITY.tex}
        \caption{\smv{MEMORY_OP_INTEGRITY} (\ref{itm:prop-mem-i})}
        \label{tbl:cex-mem-i-scocl}
    \end{subtable}

    \begin{subtable}{\textwidth}
        \centering
        \input{../results/SANITIZE-CACHE-ON-CLASSIFICATION/CSR-INTEGRITY.tex}
        \caption{\smv{CSR_INTEGRITY} (\ref{itm:prop-csr-i})}
        \label{tbl:cex-csr-i-scocl}
    \end{subtable}

    \begin{subtable}{\textwidth}
        \centering
        \input{../results/CLEAR-CACHE-ON-DECLASSIFICATION/NO-LEAK.tex}
        \caption{\smv{NO_LEAK} (\ref{itm:prop-no-leak})}
        \label{tbl:cex-no-leak-ccod}
    \end{subtable}
    \caption{Counter-examples for \smv{CLR_CACHE_ON_DECLASSIFICATION} and \smv{SAN_CACHE_ON_CLASSIFICATION}}
\end{table}

\subsection{Cache-Invalidation Mitigation}

Consider the counter-example to the cache-relate assumptions \smv{CLR_CACHE_ON_DECLASSIFICATION} depicted in table \ref{tbl:cex-no-leak-ccod}.
It can be seen that it resulted in a trace where memory privileges are lowered but sensitive data remains in cache.
One therefore might think that this vulnerability can be mitigated by changing the architecture such that the cache is invalidated on mode-transitions\footnote{%
    The traces \ref{tbl:cex-mem-i-scocl} and \ref{tbl:cex-csr-i-scocl} both do not involve mode-transitions.
    However, it could be safely assumed that initially, the confidentiality or integrity labels in the cache line are low or high respectively.
    This would rule out the initial state where malicious data is in cache and bring the need for user-mode to prep the cache with such data.
}.
However, the critical part of the cache-related assumptions does not lie in the privilege-transition itself.

Consider the trace depicted in table \ref{tbl:cex-no-leak-inval-trans}.
This trace was generated \textit{with} the adoption to the architecture that the cache is invalidated on any mode-transition and is straight-forward:
machine-mode first gives user-mode read access to memory region one which is fine since only public values are stored in that region.
Then, machine-mode attempts to load some word from memory which, however, leads to a confidential value appearing in memory region one.
How can that be?
Note that memory region one is set to be write-back cacheable.
There must have been some confidential value in the cache which was written back to memory because the cache was about to be filled with other data by the \smv{Load} instruction.
When machine-mode now returns control back to user-mode, having the cache invalidated still allows user-mode to load the confidential value from the memory region accessible to it.
Therefore, this architectural mitigation does not suffice and cache needs to be taken into account when changing access privileges of memory regions.

\begin{table}
    \centering
    \input{../results/CACHE-INVALIDATE-ON-TRANS/NO-LEAK.tex}
    \caption{\smv{NO_LEAK} (\ref{itm:prop-no-leak}) counter-example when invalidating the cache on privilege transitions}
    \label{tbl:cex-no-leak-inval-trans}
\end{table}

\section{Canary Related Counter-Examples}
\label{app:cexs-canaries}

In section \ref{sec:canaries}, two vulnerabilities were purposefully added to the model of the MINRV8 architecture in order to test both the information flow properties and the assumptions that resulted from the prove-refine loop as presented in chapter \ref{chp:results}.
In this section, the counter-examples that were found by nuXmv when the respective modifications were put into effect will be presented.

\subsection{Cache Poisoning Attack on x86}
\label{sec:cexs-cache-vuln}

When the cache poisoning attack discussed in section \ref{sec:cache-poisoning} was injected into the model, all information flow properties were violated.
As usual, the traces for \smv{MEMORY_OP_INTEGRITY} (\ref{itm:prop-mem-i}) and \smv{CSR_INTEGRITY} (\ref{itm:prop-csr-i}) as depicted in tables \ref{tbl:cex-mem-i-cache-vuln} and \ref{tbl:cex-csr-i-cache-vuln} are highly similar.
The counter-example to property \smv{MEMORY_OP_INTEGRITY} (\ref{itm:prop-mem-i}) will be introduced in detail now.
Initially, user-mode executes a \minrv{Store} instruction which is not reflected in memory.
Then, it reads from a \gls{csr} to put a trusted value into register 0.
Interestingly, user-mode thereby aids machine-mode in sanitizing the registers since now, all registers contain trusted values.
In the next step, a pending external interrupt is taken which leads to the transition to machine-mode.
Machine-mode performs a load instruction targeting the same address as the user's store instruction which leads to an untrusted value being stored in register two.
This value is then used to perform a load/store operation.

The load in the fourth step resulting in an untrusted value means, the initial store must have been targeting the only region set cacheable which is region one in table \ref{tbl:cex-mem-i-cache-vuln} and region zero in table \ref{tbl:cex-csr-i-cache-vuln} respectively.
Here, it can be seen that dropping memory privilege controls on cache-writes and -reads leads to states inconsistent with the MINRV8 specification.
In table \ref{tbl:cex-mem-i-cache-vuln}, memory region one is locked and as neither the read- nor the write-bit is set, both user- and machine-mode should not be able to read from or write to memory region one.
Yet, the cache-access succeeds.

In the case of the original cache-poisoning attack, the authors wrote to executable memory directly influencing what would be executed by System Management Mode.
Since the MINRV8 model does not support a model of executable memory, it is not possible to implement this exact vulnerability here.
However, these counter-examples show that it is still possible to implement the very core of the cache poisoning attack into the MINRV8 model which leads to a similar vulnerability of the architecture.

This carries over to the counter-example for property \smv{NO_LEAK} (\ref{itm:prop-no-leak}) which is depicted in table \ref{tbl:cex-no-leak-cache-vuln}.
This counter-example more closely matches the alternative version of the cache-poisoning attack used for reading SMM memory.
nuXmv sets the initial state up such that the cache holds some confidential data for one of the memory regions which both are set to be write-back-cacheable and non-readable to user-mode.
Yet still, user-mode can gain access to the confidential word in cache as no access controls are performed when reading from cache.

\begin{table}
    \begin{subtable}{\textwidth}
        \centering
        \input{../results/CACHE-VULN/MEMORY-OP-INTEGRITY.tex}
        \caption{\smv{MEMORY_OP_INTEGRITY} (\ref{itm:prop-mem-i})}
        \label{tbl:cex-mem-i-cache-vuln}
    \end{subtable}

    \begin{subtable}{\textwidth}
        \centering
        \input{../results/CACHE-VULN/CSR-INTEGRITY.tex}
        \caption{\smv{CSR_INTEGRITY} (\ref{itm:prop-csr-i})}
        \label{tbl:cex-csr-i-cache-vuln}
    \end{subtable}

    \begin{subtable}{\textwidth}
        \centering
        \input{../results/CACHE-VULN/NO-LEAK.tex}
        \caption{\smv{NO_LEAK} (\ref{itm:prop-no-leak})}
        \label{tbl:cex-no-leak-cache-vuln}
    \end{subtable}
    \caption{Counter-examples for the Cache Vulnerability}
    \label{tbl:cex-cache-vuln}
\end{table}

\subsection{The SYSRET Vulnerability}
\label{sec:cexs-sysret}

For the SYSRET vulnerability as presented in section \ref{sec:sysret}, only the integrity-related properties were considered as only these are relevant to the SYSRET vulnerability.
The counter-examples illustrating this are depicted in table \ref{tbl:cex-sysret}.
A new feature is used to visualize the two stack-pointers.
It has already been mentioned that the architecture supports two stack-pointers being indexed by \minrv{0} and \minrv{1}.
These indices are visualized by a superscript in the cells that contain the memory labels.
For example, in table \ref{tbl:cex-mem-i-sysret} the stack-pointer \minrv{sp[1]} points to address \minrv{1} and \minrv{sp[0]} to address \minrv{3}.
The stack-pointer selected as currently active is highlighted by being underlined.

As usual, both counter-examples for the \smv{MEMORY_OP_INTEGRITY} (\ref{itm:prop-mem-i}) and \smv{CSR_INTEGRTIY} (\ref{itm:prop-csr-i}) properties are very similar.
Therefore, only the first of these counter-examples will be introduced in detail.
In the counter-example for the \smv{MEMORY_OP_INTEGRITY} property, the architecture starts in machine-mode with stack-pointer one being active and set to memory region zero which only contains trusted values\footnote{%
    Furthermore, memory region zero is locked and not set to be write- or readable which makes it inaccessible to machine-mode but this is not relevant to the counter-example.
}.
In the first two instructions, machine-mode selects a user-mode controlled stack-pointer as the active one and attempts to give back control to user-mode.
However, an external interrupt must have been set pending and taken exactly when machine-mode attempted to execute the \minrv{Mret} instruction since no privilege-mode transition occurs.
The memory region that is pointed towards by the now active stack-pointer contains untrusted values only.
This alone marks the core of the SYSRET vulnerability but it only becomes a problem because machine-mode then decides to pop a value from the stack which consequently is untrusted and then uses that value.

\begin{table}
    \begin{subtable}{\textwidth}
        \centering
        \input{../results/SP-ENABLE/MEMORY-OP-INTEGRITY.tex}
        \caption{\smv{MEMORY_OP_INTEGRITY} (\ref{itm:prop-mem-i})}
        \label{tbl:cex-mem-i-sysret}
    \end{subtable}

    \begin{subtable}{\textwidth}
        \centering
        \input{../results/SP-ENABLE/CSR-INTEGRITY.tex}
        \caption{\smv{CSR_INTEGRITY} (\ref{itm:prop-csr-i})}
        \label{tbl:cex-csr-i-sysret}
    \end{subtable}
    \caption{Counter-examples for the SYSRET vulnerability}
    \label{tbl:cex-sysret}
\end{table}
