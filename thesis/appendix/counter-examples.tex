\section{Assumption Related Counter-Examples}

\todo[inline]{Introduce and fix flow of text}

\paragraph{Mode-boundary crossing related assumptions}
Without assuming \smv{SAN_ON_CALL} nuXmv manages to find two counter-examples.
One for property \smv{MEMORY_OP_INTEGRITY} (\ref{itm:prop-mem-i}) and one for \smv{CSR_INTEGRITY} (\ref{itm:prop-csr-i}).
The traces for both counter-examples are depicted in tables \ref{tbl:cex-mem-i-soc} and \ref{tbl:cex-csr-i-soc} respectively.
Table \ref{tbl:cex-no-leak-cor} illustrates a counter-example for the \smv{NO_LEAK} (\ref{itm:prop-no-leak}) property when not assuming \smv{CLR_ON_RET}.

\begin{example}
    The format of these tables illustrating counter-example traces will be used frequently throughout this thesis to illustrate counter-examples.
    To introduce it, table \ref{tbl:cex-mem-i-soc} will be explained in detail now.
    The first row of the table gives the processor's initial state.
    Each subsequent row of the table represents an instruction being executed and shows the values that have changed in result of this instruction.
    Whenever a cell is empty, the value represented by it did not change.
    Furthermore, the table is separated in three main columns: The first column shows the instructions being executed.
    In case of table \ref{tbl:cex-mem-i-soc}, three instructions were executed: \minrv{Ecall}, \minrv{Load} and \minrv{Store}.

    The second group of columns hold the information flow labels for the registers and memory on a per-word basis.
    During the verification process it was found that no counter-example required information flow labels of a per-bit granularity.
    Therefore, for the sake of simplicity, the information flow labels of machine-words in memory or registers were combined to a single label\footnote{
        The labels have been combined by using the $ \sqcup $ operator, i.e. for a label $ w $, the combined label is $ \bigsqcup_{i} w_i $.
    }.
    The two inner rows in the cells of the second major column denote the labels of the registers (\minrv{r}) and memory (\minrv{m}) respectively whereas the inner columns mark the index of the labels, e.g. in table \ref{tbl:cex-mem-i-soc} all registers and the cells of memory region zero are labelled with \PU{}, i.e. public and untrusted, whereas the cells of memory region one are labelled with \PT{}, i.e. public and trusted, in the initial state.

    The third major column shows the status of the processor.
    This column is separated into five inner columns as well.
    The first (labelled with \minrv{p}) shows the privilege mode of execution where \minrv{U} stands for user-mode and \minrv{M} stands for machine-mode.
    The other four columns show the current memory settings per region.
    Inner columns starting with \minrv{0} give the settings for first memory region and starting with \minrv{1} for the second memory region respectively.
    Inner columns ending with \minrv{c} hold the cacheability settings.
    Here, \minrv{UN} stands for uncacheable, \minrv{WB} for write-back-cacheable, \minrv{WT} for write-through-cacheable and \minrv{WP} for write-protected-cacheable (cf. section \ref{sec:minrv8}).
    Inner columns ending with \minrv{p} hold the memory privilege settings for the respective region.
    Memory privilege settings are indicated by a string of the form:
    \begin{grammar}
        <privelege-string> ::= (`-' | `L') (`-' | `R') (`-' | `W')
    \end{grammar}

    The first letter in the privilege string denotes whether the region is locked (\minrv{L}) or not (\minrv{-}), the second whether user-mode can read the region (\minrv{R}) or not (\minrv{-}) and the third whether user mode can write to the region (\minrv{W}) or not (\minrv{-}).
    In table \ref{tbl:cex-mem-i-soc}, none of the regions is locked or cacheable and user mode can write to region zero only and has not further permissions.

    Traces generated by nuXmv are infinitely long but finitely representable by including a loop.
    In this setting, counter-examples generated by nuXmv always violated the property at hand after having executed the second last instruction whereas the last instruction introduced the loop and led to a fixpoint in the state-space.
    For the sake of completeness, the last instruction of counter-example traces will be included nonetheless.
\end{example}

Note that the traces for property \smv{MEMORY_OP_INTEGRITY} in table \ref{tbl:cex-mem-i-soc} and for property \smv{CSR_INTEGRITY} in table \ref{tbl:cex-csr-i-soc} are very similar.
In both traces, the processor starts in user-mode with some untrusted data in the registers.
User-mode then calls machine-mode which decides to use the contents of the registers without sanitization to either write a \gls{csr} or to memory.
The violation of property \smv{NO_LEAK} (\ref{itm:prop-no-leak}) depicted in table \ref{tbl:cex-no-leak-cor} when not assuming \smv{CLR_ON_RET} is analogously simple.
Since machine-mode directly hands over confidential data to user-mode by returning control to user-mode without clearing its registers, user-mode trivially gains access to secrets.
It is obvious that such flows of information are no fault of the architecture but must be fought in programming, i.e. in compilers or \gls{os} programming.
As such, we express sufficient techniques to combat vulnerabilities of this kind in aforementioned assumptions.

\begin{table}
    \begin{subtable}{\textwidth}
        \centering
        \input{../results/SANITIZE-ON-CALL/MEMORY-OP-INTEGRITY.tex}
        \caption{\smv{MEMORY_OP_INTEGRITY} (\ref{itm:prop-mem-i})}
        \label{tbl:cex-mem-i-soc}
    \end{subtable}

    \begin{subtable}{\textwidth}
        \centering
        \input{../results/SANITIZE-ON-CALL/CSR-INTEGRITY.tex}
        \caption{\smv{CSR_INTEGRITY} (\ref{itm:prop-csr-i})}
        \label{tbl:cex-csr-i-soc}
    \end{subtable}

    \begin{subtable}{\textwidth}
        \centering
        \input{../results/CLEAR-ON-RET/NO-LEAK.tex}
        \caption{\smv{NO_LEAK} (\ref{itm:prop-no-leak})}
        \label{tbl:cex-no-leak-cor}
    \end{subtable}
    \caption{Counter-examples for \smv{SAN_ON_CALL} and \smv{CLR_ON_RET}}
\end{table}

\paragraph{Memory related assumptions}
The three counter-examples involved in this two assumptions are rather straight-forward as well.
If machine-mode is allowed to load arbitrary words from public memory nuXmv gives a counter-example to the properties \smv{MEMORY_OP_INTEGRITY} (\ref{itm:prop-mem-i}) and \smv{CSR_INTEGRITY} (\ref{itm:prop-csr-i}) where some or all memory is untrusted in the initial state, machine-mode in the next step decides to load some word from an untrusted source in memory and then uses that as target address of a \minrv{Store} instruction or to write a \gls{csr} with.
These counter-examples are illustrated in table \ref{tbl:cex-mem-i-npw} and \ref{tbl:cex-csr-i-npw} respectively.
On the other hand, if machine-mode is allowed to store arbitrary words into public memory, a simple counter-example to the \smv{NO_LEAK} property (\ref{itm:prop-no-leak}) is that machine-mode simply stores a secret into public memory which is then loaded by user-mode as illustrated by the trace in table \ref{tbl:cex-no-leak-npw}.

Additionally, in this counter-example the consequences of assuming \minrv{CLR_ON_RET} can be seen.
Machine-mode tries to hide secrets from user-mode by writing a public value into register zero before returning which is mandated by aforementioned assumption.
Yet, as shown in the last paragraph, this assumption taken alone, does not ensure the absence of \smv{NO_LEAK} related counter-examples.

\begin{table}
    \begin{subtable}{\textwidth}
        \centering
        \input{../results/NO-PUBLIC-READS/MEMORY-OP-INTEGRITY.tex}
        \caption{\smv{MEMORY_OP_INTEGRITY} (\ref{itm:prop-mem-i})}
        \label{tbl:cex-mem-i-npw}
    \end{subtable}

    \begin{subtable}{\textwidth}
        \centering
        \input{../results/NO-PUBLIC-READS/CSR-INTEGRITY.tex}
        \caption{\smv{CSR_INTEGRITY} (\ref{itm:prop-csr-i})}
        \label{tbl:cex-csr-i-npw}
    \end{subtable}

    \begin{subtable}{\textwidth}
        \centering
        \input{../results/NO-PUBLIC-WRITES/NO-LEAK.tex}
        \caption{\smv{NO_LEAK} (\ref{itm:prop-no-leak})}
        \label{tbl:cex-no-leak-npw}
    \end{subtable}
    \caption{Counter-examples for \smv{NO_PUBLIC_WRITES} and \smv{NO_PUBLIC_READS}}
\end{table}

\paragraph{Memory privilege related assumptions}
The counter-examples when not assuming \smv{SAN_ON_CLASSIFICATION} for properties \smv{MEMORY_OP_INTEGRITY} and \smv{CSR_INTEGRITY} (cf. tables \ref{tbl:cex-csr-i-socl}, \ref{tbl:cex-mem-i-socl}) - as usual - work analogously and illustrate exactly what has been given as intuition for this assumption in the introduction of this paragraph.
In each counter-example, at least one memory region initially is writable for user-mode and contains untrusted data.
Machine-mode changes the privilege settings of that memory region making it non-writable to user-mode and then loads and uses a machine-word which is untrusted violating the respective integrity related property.

The counter-example given when not assuming \smv{CLR_ON_DECLASSIFICATION} is given in table \ref{tbl:cex-no-leak-cod}.
The architecture starts with some confidential data in the memory of the first memory region which is not publicly readable.
In the first step, machine-mode however sets just that memory to being publicly readable.
Machine-mode does clear its registers before giving control back to user-mode, yet this is irrelevant since user-mode can just load the contents from the now accessible memory region one which violates the \smv{NO_LEAK} property (cf. \ref{itm:prop-no-leak}).

\begin{table}
    \begin{subtable}{\textwidth}
        \centering
        \input{../results/SANITIZE-ON-CLASSIFICATION/MEMORY-OP-INTEGRITY.tex}
        \caption{\smv{MEMORY_OP_INTEGRITY} (\ref{itm:prop-mem-i})}
        \label{tbl:cex-mem-i-socl}
    \end{subtable}

    \begin{subtable}{\textwidth}
        \centering
        \input{../results/SANITIZE-ON-CLASSIFICATION/CSR-INTEGRITY.tex}
        \caption{\smv{CSR_INTEGRITY} (\ref{itm:prop-csr-i})}
        \label{tbl:cex-csr-i-socl}
    \end{subtable}

    \begin{subtable}{\textwidth}
        \centering
        \input{../results/CLEAR-ON-DECLASSIFICATION/NO-LEAK.tex}
        \caption{\smv{NO_LEAK} (\ref{itm:prop-no-leak})}
        \label{tbl:cex-no-leak-cod}
    \end{subtable}
    \caption{Counter-examples for \smv{CLR_ON_DECLASSIFICATION} and \smv{SAN_ON_CLASSIFICATION}}
\end{table}

This time around, the counter-examples given by nuXmv are not completely straight forward.
As a start, consider the counter-examples generated when not assuming \smv{SAN_CACHE_ON_DECLASSFICATION} for the \smv{MEMORY_OP_INTEGRITY} property in table \ref{tbl:cex-mem-i-scocl}.
In the first instruction, machine-mode sets memory region one to be inaccessible by user-mode which does not violate assumption \minrv{SAN_ON_CLASSIFICATION} since all memory provides trusted values.
In the next instruction, machine-mode decides to load a word from memory which happens to be untrusted.
This must come from cache since no other memory cell matches this label.
This is only possible because memory region one is set to be write-back-cacheable where writes not necessarily must be reflect in memory.
This word is then used as address for a \minrv{Load} instruction violating property \ref{itm:prop-mem-i}.
The counter-example for property \smv{CSR_INTEGRITY} (\ref{itm:prop-csr-i}) depicted in table \ref{tbl:cex-csr-i-scocl} follows the same pattern and therefore will not be handled separately in this context.

The trace generated to prove the \smv{NO_LEAK} property (\ref{itm:prop-no-leak}) wrong when not assuming \minrv{CLR_CACHE_ON_DECLASSIFICATION} flips the integrity related counter-examples.
It is given in table \ref{tbl:cex-no-leak-ccod}.
Here, memory region zero is set to be write-back-cacheable.
This time though, machine-mode declassifies it in the first instruction as opposed to the previous counter-examples where the respective region was being classified.
Machine-mode then gives back control to user-mode which performs a load.
Again, a mysterious confidential word appears in register three which must have come from the cache of memory region one since only this region is accessible to user-mode.

\begin{table}
    \begin{subtable}{\textwidth}
        \centering
        \input{../results/SANITIZE-CACHE-ON-CLASSIFICATION/MEMORY-OP-INTEGRITY.tex}
        \caption{\smv{MEMORY_OP_INTEGRITY} (\ref{itm:prop-mem-i})}
        \label{tbl:cex-mem-i-scocl}
    \end{subtable}

    \begin{subtable}{\textwidth}
        \centering
        \input{../results/SANITIZE-CACHE-ON-CLASSIFICATION/CSR-INTEGRITY.tex}
        \caption{\smv{CSR_INTEGRITY} (\ref{itm:prop-csr-i})}
        \label{tbl:cex-csr-i-scocl}
    \end{subtable}

    \begin{subtable}{\textwidth}
        \centering
        \input{../results/CLEAR-CACHE-ON-DECLASSIFICATION/NO-LEAK.tex}
        \caption{\smv{NO_LEAK} (\ref{itm:prop-no-leak})}
        \label{tbl:cex-no-leak-ccod}
    \end{subtable}
    \caption{Counter-examples for \smv{CLR_CACHE_ON_DECLASSIFICATION} and \smv{SAN_CACHE_ON_CLASSIFICATION}}
\end{table}

It could be seen that counter-example \ref{tbl:cex-no-leak-ccod} to the cache-relate assumptions \smv{CLR_CACHE_ON_DECLASSIFICATION} resulted in a trace where memory privileges are lowered but sensitive data remains in cache.
One therefore might think that this vulnerability can be mitigated by changing the architecture such that the cache is invalidated on mode-transitions\footnote{%
    The traces \ref{tbl:cex-mem-i-scocl} and \ref{tbl:cex-csr-i-scocl} both do not involve mode-transitions.
    However, it could be safely assumed that initially, the confidentiality or integrity labels in the cache line are low or high respectively.
    This would rule out the initial state where malicious data is in cache and bring the need for user-mode to prep the cache with such data.
}.
However, the critical part of the cache-related assumptions does not lie in the privilege-transition itself.

Consider the trace depicted in table \ref{tbl:cex-no-leak-inval-trans}.
This trace was generated \textit{with} the adoption to the architecture that the cache is invalidated on any mode-transition and is straight-forward:
machine-mode first gives user-mode read access to memory region one which is fine since only public values are stored in that region.
Then, machine-mode attempts to load some word from memory which, however, leads to a confidential value appearing in memory region one.
How can that be?
Note that memory region one is set to be write-back cacheable.
There must have been some confidential value in the cache which was written back to memory because the cache was about to be filled with other data by the \smv{Load} instruction.
When machine-mode now returns control back to user-mode, having the cache invalidated still allows user-mode to load the confidential value from the memory region accessible to it.
Therefore, this architectural mitigation does not suffice and cache needs to be taken into account when changing access privileges of memory regions.

\begin{table}
    \centering
    \input{../results/CACHE-INVALIDATE-ON-TRANS/NO-LEAK.tex}
    \caption{\smv{NO_LEAK} (\ref{itm:prop-no-leak}) counter-example when invalidating the cache on privilege transitions}
    \label{tbl:cex-no-leak-inval-trans}
\end{table}
