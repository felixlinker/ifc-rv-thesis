%!TEX root = ../thesis.tex

\section{Architecture}
\label{sec:arch}

\subsection{An Introduction to RISC-V}

This section will introduce the core of the \gls{riscv} architecture by shedding light on the base integer instruction set in section \ref{sec:rv-base-int-isa} and the mechanisms of the privileged part of the architecture in \ref{sec:rv-priv-arch}.

\subsubsection{The Base Integer Instruction Set}
\label{sec:rv-base-int-isa}

\paragraph{Instructions}

\subparagraph{Integer arithmetic and Boolean instructions}
The base integer instruction set provides instructions for plus and minus, integer comparisons and the Boolean operators \rv{And}, \rv{Or} and \rv{Xor}.
Most of these instructions are implemented in two version: a register version (or R-type instruction) and an immediate version (or I-type instruction).
In the first case the two operands are given as registers and in the second case one operand is given as register and the other as an immediate value read from memory.
In either case the value is stored in a destination register.

These basic instructions are all side effect free besides from advancing the program counter which means that if the destination register is x0, each of them encodes a no-operation instruction.
This makes them particularly easy to analyze.
However, as a side-effect, this means that there is no built-in support for overflow checks via flags in some dedicated \gls{csr}.
There also is no special instruction to handle this.
The authors of the \gls{riscv} manual show that in general, overflow checks for addition can be handled with three additional instructions after an add instruction:

\begin{lstlisting}[
    language=rv,
    caption={General overflow checking \cite{RiscVISA}},
    label={snpt:rv-overflow}
]
    Add  t0, t1, t2          # Set R[t0] to R[t1] + R[t2]
    Slti t3, t2, 0           # Set R[t3] to R[t2] < 0
    Slt  t4, t0, t1          # Set R[t4] to R[t0] < R[t1]
    Bne  t3, t4, overflow    # If R[t3] != R[t4] branch to overflow
\end{lstlisting}

The gist of snippet \ref{snpt:rv-overflow} boils down to: we can check if there was overflow when calculating $ a + b $ by checking whether $ b < 0 \leftrightarrow a + b < a $ is false, i.e. \textcquote{RiscVISA}{the sum should be less than one of the operands if and only if the other operand is negative}.

\subparagraph{Memory operations}
There are two types of instructions that deal with external memory.
Firstly, simple load and store instructions that read from or write to memory.
Secondly, FENCE instructions that synchronize memory access between multiple \glspl{hart}.

Memory in \gls{riscv} is byte-addressable.
Therefore, load and store operations in \gls{riscv} can read or write words of size 8-, 16-, 32-, 64- or 128-bits, depending on the maximum word length of the base instruction set of choice.
Read- and write-addresses don't have to be aligned by software before using them, however, if they are not, the architecture must first align them before fetching from or storing to them, i.e. reading a 32-bit word from memory at address 0x1 is impossible.
If this address is given as argument to a respective load instruction it'll be aligned to the address 0x0.

\subparagraph{Control transfer instructions}
There are two types of instructions that can control program flow in \gls{riscv}: jumps and branches.
In short, jumps are performed unconditionally and can target a wider range in memory (at least $ \pm 2^{20}\text{bits} $ in case of a 32-bit architecture) whereas branches are performed conditionally, only can target a narrower range in memory ($ \pm 2^{12}\text{bits} $ in case of a 32-bit architecture) and always must branch to \gls{pc}-relative addresses.

In contrast to memory operations, addresses targeted by jumps must be aligned correctly.
If this is not the case, an exception will be generated.

Jumps are intended to call routines and functions.
This is why they store a return address to some general purpose register.
Branches on the other hand are intended to control the program flow of one such routine or function, e.g. to implement an \textit{if-else} structure or \textit{for}-loops where code won't return from the branched execution.
\gls{riscv} is agnostic about the details of calling conventions for routines, e.g. how the stack is organized, which general purpose registers are used as \gls{lr} or \gls{sp}, and leaves these details to be implemented by software running on the core.

\subparagraph{Platform management instructions}
The last type of instructions to be looked at are platform management instructions.
The \gls{riscv} manual also knows this category and divides it into two subcategories: instructions that deal with \glspl{csr} and other instructions that perform operations that potentially need some form of privilege.
Examples for the former category are straight forward.
\gls{riscv} knows instructions to read or write complete \glspl{csr} but also knows operations to modify single bits only.
For the latter category, \gls{riscv} only knows two instructions at the base instruction set level which are \gls{ecall} and \gls{ebreak} instructions.
We will inspect these instructions in more detail in section \ref{sec:rv-priv-arch}.

\subparagraph{Summary}
The base integer instruction set of \gls{riscv} gives you everything you need for implementing a comfortable Turing-machine but pretty much nothing more.
You can perform basic arithmetic with integers or bit vectors of Booleans, load and store results of your calculations and abstract your code by using jumps and branches.
At this point, there is no state with predefined semantics, i.e. all state available is given by storage that can only influence computation when used by a programmer.

Only the platform management instructions give a hint on the complexity that is offered by the \gls{riscv} architecture to allow abstracting processing done on the core.

\subsubsection{The Privileged Architecture}
\label{sec:rv-priv-arch}

The \textit{The RISC-V Instruction Set Manual, Volume II: Privileged Architecture} \cite{RiscVISAP} mainly specifies three concepts:
\begin{enumerate}
    \item Three levels of privilege
    \item Exceptions, traps and interrupts
    \item Memory attributes
\end{enumerate}

The three levels of privilege form the basis of everything that is defined by the privileged architecture.
The purpose of interrupts and exceptions is not only to handle error conditions that arise during runtime but also to communicate between privilege layers.
Therefore, interrupts and exceptions are being used by up to this point unmentioned auxiliary mechanisms of the architecture that aid the highest privilege in administrating the platform.

Also, memory attributes rely on these levels of privilege as they define which mode is eligible to do some operation on some region of memory.

In this section, the aforementioned concepts will be introduced subsequently and will be concluded by a sketch of the auxiliary mechanisms that build on top of these.

\paragraph{Levels of Privilege}

\gls{riscv} knows three privilege levels: user-mode, supervisor-mode and machine-mode\footnote{%
    In an earlier version, there was a fourth privilege-mode being hypervisor-mode that was more privileged than supervisor- but less privileged than machine-mode.
    However, this mode has been dropped from the specification as of now.
    Yet, \gls{riscv} still needs to encode mode-relative bit-fields with two bits.
    Usually, 00 stands for user-, 01 for supervisor and 11 for machine-mode.
    10 is reserved in most places and has been used for hypervisor-mode.
}.
Each implementation of the \gls{riscv} specification must at least provide machine-mode as a base mode of operation.
Besides this, there are two other choices of privilege levels combinations supported:
\begin{enumerate}
    \item Machine-mode only (\textcquote{RiscVISA}{simple embedded system})
    \item User and machine-mode (\textcquote{RiscVISA}{secure embedded system})
    \item User, supervisor and machine-mode (\textcquote{RiscVISA}{\textins{system} running Unix-like operating systems})
\end{enumerate}

A visualization of these three combinations is given in figure \ref{fig:rv-priv-lvls} where they are depicted from left to right.
A simple embedded system might be the cheapest to implement and manufacture, however, this system lacks any protection against malicious application code, i.e. one would only want to run such a system in very basic scenarios where full control over all source code and the device itself can be guaranteed.

A secure embedded system supports some application to be run on it while an \gls{aee} running in machine-mode controls the execution of this application.
The application communicates to the \gls{aee} via an \gls{abi} that defines the possible interactions between an application and an \gls{aee}.

A system running a Unix-like \gls{os} enhances on this by having an \gls{os} running in supervisor-mode that communicates with multiple applications running in parallel via an \gls{abi} and itself is managed by a \gls{see} which communicates with the \gls{os} via a \gls{sbi}.
The \gls{see} runs in machine-mode.

\begin{figure}
    \centering
    \subcaptionbox{\centering Simple embedded system}
    [0.18\textwidth]{
        \begin{tabular}{| c |}
            \hline
            Application \\ \hline
        \end{tabular}
    }
    \quad
    \subcaptionbox{\centering Secure embedded system}
    [0.18\textwidth]{
        \begin{tabular}{|c|}
            \hline
            Application \\ \hline
            \cellcolor{black} \textcolor{white}{ABI} \\ \hline
            AEE \\ \hline
        \end{tabular}
    }
    \quad
    \subcaptionbox{\centering System with Unix-like OS}
    {
        \begin{tabular}{| c | c | c |}
            \cline{1-1} \cline{3-3}
            Application & \multirow{2}{*}{\dots} & Application \\
            \cline{1-1} \cline{3-3}
            \cellcolor{black} \textcolor{white}{ABI} & & \cellcolor{black} \textcolor{white}{ABI} \\ \hline
            \multicolumn{3}{| c |}{OS} \\ \hline
            \multicolumn{3}{| c |}{\cellcolor{black} \textcolor{white}{SBI}} \\ \hline
            \multicolumn{3}{| c |}{SEE} \\ \hline
        \end{tabular}
    }
    \caption{Privilege level combinations \cite{RiscVISA}}
    \label{fig:rv-priv-lvls}
\end{figure}

To keep things simple, the focus of this thesis lies on secure embedded systems\footnote{%
    % TODO: But will it?
    This will be justified in more detail in section \ref{sec:minrv8} where we introduce the architecture that will be verified as part of this thesis.
}.
This means that the architecture to be worked with supports two modes: user- and machine-mode.
Machine-, user- and supervisor-mode do not simply form a linear order of privilege attributes of code execution.
They differ in the concepts that are available to them and therefore must be handled separately.
However, as the focus will lie on secure embedded systems, many parts of the specification which are about supervisor solely will be left out.
Supervisor-mode will be handled wherever it fits in the bigger picture but not on its own.

\paragraph{Exceptions, traps and interrupts}
\label{sec:rv-exn}

Volume 1 of the \gls{riscv} specification \cite{RiscVISA} introduces the concept of exceptions, traps and interrupts as follows:
\begin{displaycquote}{RiscVISA}
    We use the term \textit{exception} to refer to an unusual condition occurring at run time associated with an instruction in the current RISC-V thread.
    We use the term \textit{trap} to refer to the synchronous transfer of control to a trap handler caused by an exceptional condition occurring within a RISC-V thread.
    Trap handlers usually execute in a more privileged environment.

    We use the term \textit{interrupt} to refer to an external event that occurs asynchronously to the current RISC-V thread.
    When an interrupt that must be serviced occurs, some instruction is selected to receive an interrupt exception and subsequently experiences a trap.

    The instruction descriptions in following chapters describe conditions that raise an exception during execution.
    Whether and how these are converted into traps is dependent on the execution environment, though the expectation is that most environments will take a \textit{precise} trap when an exception is signaled \textelp{}.
\end{displaycquote}

This - in short - means that a trigger for interrupts, traps and exceptions can be given which is depicted in figure \ref{fig:trigger-hierarch}.
In general, interrupts occur asynchronously and trigger synchronous exceptions to be generated for a \gls{hart} which in turn may generate traps but also might be handled otherwise.
The specification mentions the example of the floating-point extension in which exceptions not necessarily generate traps.

\begin{figure}
    \centering
    \tikz \graph[grow right sep] {
        Interrupt -> Exception -> {Trap, ?};
    };
    \caption{Trap-Trigger-Hierarchy}
    \label{fig:trigger-hierarch}
\end{figure}

For the sake of simplicity, we will assume that every exception causes a trap.
As we will not implement any floating-point arithmetic extension, the specification does not demand from us to handle exceptions otherwise and doing so does not serve any purpose at this point.
In following paragraphs, an introduction to the control flow of dealing with interrupts will be given.
Said control flow is depicted in figure \ref{fig:interrupt-handling} and follows these general steps:
\begin{enumerate}
    \item If an interrupt or exception is pending, determine the privilege mode to take the trap
    \item Check if the interrupt is enabled
    \item Take the trap
    \item Return from trap handler
\end{enumerate}
Interrupt handling can be understood as a generalized form of exception handling as exception handling in principle works the same but has fewer steps.

\begin{figure}
    \centering
    \begin{adjustbox}{max width=\textwidth}
        \begin{tikzpicture}[node distance = 1cm, auto]
            \node[block] (pending) {
                An interrupt $ i $ is pending in mode $ y $; let $ x := \text{machine-mode} $
            };

            \node[decision] (takePre) [below=of pending] {$ x\text{ideleg}[i] $ and $ x > y $?};
            \path[line] (pending) -- node[midway] (p2tp) {} (takePre);

            \node[block,text width=8em] (deleg) [left=of takePre] {$ x := x - 1 $};

            \path[line] (takePre) -- node[near start] {yes} (deleg);
            \path[line] (deleg) |- (p2tp);

            \node[decision] (takePre2) [right=of takePre] {$ x > y $ or $ x = y $, $ x\text{status}.x\text{IE} $, $ x\text{ie}[i] $?};
            \path[line] (takePre) -- node[near start] {no} (takePre2);

            \node[block,text width=16em] (take) [below=of takePre2] {
                Write $ x\text{tval} $ accordingly and let $ t := x\text{tvec} $, furthermore set:\\
                $ \begin{aligned}
                    & x \text{status}.x\text{PP} := y \\
                    & x \text{status}.x\text{PIE} := x\text{status}.x\text{IE} \\
                    & x\text{status}.x\text{IE} := 0 \\
                    & x\text{epc} := \text{current address} \\
                    & x\text{cause}[31] := 1 \\
                    & x\text{cause}[30..0] := i \\
                \end{aligned} $
            };
            \path[line] (takePre2) -- node[near start] {yes} (take);
            \path[line,dashed] (takePre2.east) -- node[near start] {no} ++(right:1cm);

            \node[decision,text width=6.5em] (jumpPre) [left=of take] {$ x\text{tvec.MODE} $?};

            \path[line] (take) -- (jumpPre);

            \node[block,text width=8em] (vectored) [left=of jumpPre] {$t := t + 4 \times i $};
            \path[line] (jumpPre) -- node[near start] {yes} (vectored);

            \node[block] (handling) [below=of jumpPre] {Jump to $ t $ and execute instructions};
            \path[line] (jumpPre) -- node[near start] {no} node[midway] (jp2h) {} (handling);
            \path[line] (vectored) |- (jp2h);

            \node[block] (return) [below=of handling] {
                Set privilege mode to $ x\text{status}.x\text{PP} $ and $ x\text{status}.x\text{IE} $ to $ x\text{status}.x\text{PIE} $, then jump to $ x\text{epc} $
            };
            \path[line] (handling) -- node[near start] {on $ x\text{RET} $} (return);
        \end{tikzpicture}
    \end{adjustbox}
    \caption{Interrupt handling flow-chart}
    \label{fig:interrupt-handling}
\end{figure}

\subparagraph{Interrupt and exception handling}
There are three categories of interrupts: external interrupts, timer interrupts and software interrupts.
External interrupts are used to signal exceptional events occurring on some external device that is connected to the core.
Timer interrupts can be used to track time.
Code can use certain \glspl{csr} to signal to the platform that it needs to be alerted when a given amount of real world time has passed.
Such an alert will be given by a timer interrupt.
More on this in section \ref{sec:other-mechs}.
Software interrupts can be set pending by software running on the same \gls{hart} with equal or higher privilege than the targeted privilege mode.
Software interrupts have no predefined semantics and thus can be used by programmers or system designers in every imaginable way.

Each of these categories of interrupts can target any privilege-mode netting a total of 6 interrupts available to the platform in our case (or 9 if supervisor-mode is supported).
These interrupt-types are associated with indices in the range from $ 0_{10} $ to $ 11_{10} $, also called interrupt code\footnote{%
    The reader might have noticed that these are more indices than needed to encode all interrupts available - even if supervisor-mode is present.
    Indices 2, 6 and 10 currently are reserved because hypervisor-mode has been dropped.
    The two least significant bits of the interrupt indices' encoding correspond to the respective mode's encoding.
    Thus 2, 6 and 10 are reserved as their two least significant bits are $ 10_2 $ corresponding to hypervisor-mode.
}.
An overview of all interrupt codes can be found in table \ref{tbl:interrupt-exception-codes}.
Interrupts can be set pending individually in the \gls{mip} register.
An interrupt is set pending if the bit of the \gls{mip} corresponding to the interrupts index is set to 1.

If an interrupt or exception is set pending, it must first be decided which privilege mode will take the trap to handle the exception generated.
By default, all interrupts and exceptions will be handled by machine-mode.
However, interrupts and exceptions can be delegated to less privileged modes via the \gls{mideleg} and \gls{medeleg} register\footnote{%
    It would also be possible to delegate traps by using the \gls{mret} instruction and setting all corresponding \glspl{csr} accordingly.
    However, this would come with a higher latency as a couple of jumps would need to be performed first.
}.
Similar to \gls{mip} and \gls{mie}, each bit field of \gls{mideleg} corresponds to the interrupt of the same index.
Exceptions also have an exception code assigned and thus, fields of \gls{medeleg} correspond to these codes.
An interrupt or exception can only be delegated to modes equally or higher privileged than the mode the interrupt or exception was targeting originally for example, if an interrupt is targeting supervisor-mode it must be handled by machine-mode or can optionally be delegated to supervisor-mode but can not be handled by user-mode.
If an interrupt is delegated to mode $ x $ ($ x \in \{ \text{M}, \text{S}, \text{U}\} $\footnote{%
In future, we will simply use $ x $ or other variables as placeholders for a mode-flag without specifically introducing the variable.
}), the corresponding bit in $ x\text{ip} $ reads accordingly and $ x\text{ie} $ becomes writable.
Otherwise both registers appear to be hardwired to zero.

After the mode to be targeted by the trap has been determined, it must be checked whether the given interrupt is actually enabled.
Exceptions can't be disabled and therefore will always be taken - as a consequence the following checks will be omitted for exceptions.
Interrupts on the other hand can be dis- or enabled individually in the \gls{mie} register.
Analogously to the \gls{mip} register, an interrupt is enabled if the bit corresponding the interrupts index is set to 1.
Additionally, there is the \gls{mstatus} register which can globally dis- or enable interrupt handling for a specific mode via its $ x\text{IE} $ bits.
The \gls{ustatus} register only is a restricted view on \gls{mstatus} and therefore \gls{mstatus} holds these bits not only for machine- but any mode.
These $ x\text{IE} $ fields, however, are only taken into account if the \gls{hart} operates at an equal or higher privilege mode than targeted, i.e. interrupts are always enabled globally it is targeting a mode of higher privilege than the mode of current operation.
Finally, an interrupt will be taken if interrupts are globally enabled \textit{and} the interrupt itself is enabled in the \gls{mie} register.

If a pending interrupt is taken, the \gls{mepc}, \gls{mcause} and \gls{mtval} registers are written and the platform will jump to a base address held by the \gls{mtvec} register.
\gls{mtvec} also provides a field that controls whether interrupts can be \textit{vectored}, i.e. for interrupts the \gls{pc} is not set to the base address for handling trap but to $ (\text{base} + 4 \times \text{cause}) $.
\gls{mepc} holds the address of the original instruction stream that was preempted, i.e. either the address of the instruction that caused the exception or the instruction that was next to be executed as a external interrupt was taken.
\gls{mcause} holds an identifier of the current interrupt or exception being handled by the trap.
The most significant bit indicates whether an interrupt is currently being serviced and all other bits hold the exception or interrupt code.
\gls{mtval} serves as a register to hold arguments for a trap handler.
Technically, it holds \textcquote{RiscVISAP}{exception-specific information to assist software in handling the trap}.
One example for such \enquote{exception-specific information} is that \gls{mtval} can contain the faulting bits of an instruction for an illegal instruction exception whereas \gls{mepc} would only point to the instruction in memory as a whole therefore not giving specific information about which part of the instruction caused the exception.

\gls{mstatus} also provides bits to \enquote{stack} certain values when handling exceptions or interrupts.
Nested interrupts are only supported between privilege modes.
On a trap to handle an interrupt in mode $ x $, interrupts are disabled for this mode and the value of the interrupt-enable bit is \enquote{stacked onto} a prior-interrupt-enable bit $x\text{PIE} $, i.e. $ x\text{PIE} := x\text{IE} $ and $ x\text{IE} := 0 $.
Additionally, there is a prior-privilege bit $ x\text{PP} $ that stores the privilege mode before the trap was taken.

% TODO: Maybe exactly one instruction? How does alignment play into this?
Note that due to the small offset between vectored interrupt jump destinations, the instructions located there can't perform much more than jumping to the \textit{real} trap handler.
Furthermore, as exceptions can't be vectored, any differentiation between those must be performed by software.

\begin{table}
    \centering
    \begin{tabular}{| r | r | l |}
        \hline
        Interrupt & Exception Code & Description \\
        \hline
        1 & 0 & User software interrupt \\
        1 & 1 & Supervisor software interrupt \\
        1 & 2 & \textit{Reserved} \\
        1 & 3 & Machine software interrupt \\
        \hline
        1 & 4 & User timer interrupt \\
        1 & 5 & Supervisor timer interrupt \\
        1 & 6 & \textit{Reserved} \\
        1 & 7 & Machine timer interrupt \\
        \hline
        1 & 8 & User external interrupt \\
        1 & 9 & Supervisor external interrupt \\
        1 & 10 & \textit{Reserved} \\
        1 & 11 & Machine external interrupt \\
        \hline
        1 & $ \geq $ 12 & \textit{Reserved} \\
        \hline
        0 & 0 & Instruction address misaligned \\
        0 & 1 & Instruction access fault \\
        0 & 2 & Illegal instruction \\
        0 & 3 & Breakpoint \\
        0 & 4 & Load address misaligned \\
        0 & 5 & Load access fault \\
        0 & 6 & Store \textelp{} address misaligned \\
        0 & 7 & Store \textelp{} access fault \\
        0 & 8 & Environment call from U-mode \\
        0 & 9 & Environment call from S-mode \\
        0 & 10 & \textit{Reserved} \\
        0 & 11 & Environment call from M-mode \\
        0 & 12 & Instruction page fault \\
        0 & 13 & Load page fault \\
        0 & 14 & \textit{Reserved} \\
        0 & 15 & Store \textelp{} page fault \\
        0 & $ \geq $ 16 & \textit{Reserved} \\
        \hline
    \end{tabular}
    \caption{Interrupt and exception codes \cite{RiscVISAP}}
    \label{tbl:interrupt-exception-codes}
\end{table}

\subparagraph{Summary}
You can find an overview over all registers that are involved in trap handling in table \ref{tbl:trap-csrs}.
Those \glspl{csr} which are available to user-mode would also be available to supervisor-mode in this context.
Registers written in italic font are not actual registers on their own but provide a restricted view on their respective machine-mode counterpart.

\begin{table}
    \centering
    \begin{tabular}{| c c || l |}
        \hline
        \textbf{Machine-mode} & \textbf{User-mode} & \textbf{Description} \\
        \acrshort{mstatus} & \textit{\acrshort{ustatus}} & Status \\
        \acrshort{mie} & \textit{\acrshort{uie}} & Interrupt enable \\
        \acrshort{mip} & \textit{\acrshort{uip}} & Interrupt pending \\
        \acrshort{mtvec} & \acrshort{utvec} & Trap-vector base address \\
        \acrshort{mscratch} & \acrshort{uscratch} & Scratch \\
        \acrshort{mepc} & \acrshort{uepc} & Exception program counter \\
        \acrshort{mcause} & \acrshort{ucause} & Trap cause \\
        \acrshort{mtval} & \acrshort{utval} & Trap value \\
        \acrshort{medeleg} & & Exception delegation \\
        \acrshort{mideleg} & & Interrupt delegation \\
        \hline
    \end{tabular}
    \caption{Trap-handling \glspl{csr}}
    \label{tbl:trap-csrs}
\end{table}

To summarize the mechanisms that play into interrupt and exception handling, recall the four steps to interrupt and exception handling we introduced at the beginning of this section.
These can now be filled with more details:
\begin{enumerate}
    \item If an interrupt or exception is pending, determine the privilege mode to take the trap by checking the targeted privilege mode and any delegation settings
    \item If an interrupt is pending, check that interrupts are enabled globally and the specific interrupt is enabled as well
    \item Take the trap by jumping to to trap base vector and if an interrupt is being serviced take vectoring into account
    \item Return from trap handler
\end{enumerate}

The differences between handling exceptions and interrupts can be summarized by the following:
\begin{itemize}
    \item Exception can't be disabled therefore they will always be handled
    \item $ x\text{cause}[31] $ is written with $ 0 $
    \item Exceptions can't be vectored therefore the \gls{pc} will always be set to $ x\text{tvec} $
\end{itemize}

One would need to alter figure \ref{fig:interrupt-handling} by replacing most interrupt-related \glspl{csr} with their exception-related counterpart if possible.
An exception to this is $ x\text{status}.x\text{IE} $ which still is set to 0 meaning that it is not possible to preempt handling an exception by handling an interrupt.

Finally, note that exceptions are handled as soon as they occur.
This is necessary as exceptions always are closely related to the current stream of instructions and therefore need attention before said stream can continue to be executed.
The only exception to this are other interrupts which are handled before any exception with the following decreasing order of priority: external interrupts, software interrupts, timer interrupts, exceptions.
% Source: https://stackoverflow.com/a/56402079/7194995
\gls{riscv} knows no concept of settings exceptions pending, this however, isn't necessary.
If an exception occurs while an interrupt is set pending, the interrupt can be handled with \gls{mepc} being set to the address of the faulting instruction which either will again fault after the interrupt has been handled or will succeed by some magical condition in which case it does need any further attention.

% TODO: Mention what I didn't mention; e.g. specific parts of mstatus

\paragraph{Memory Attributes}
\label{sec:memory-attrs}

In the previous paragraph, it was mentioned that \gls{mstatus} contains some bits that are not directly relevant to trap handling.
In this section, these bits will be introduced alongside another \gls{csr} that is related to trap handling.

These two remaining fields of \gls{mstatus} deal with memory privilege translation for machine-mode.
Firstly, there is the MPRV bit which can translate memory access privilege.
This bit is only available if at least two privilege modes are supported otherwise it is hardwired to zero.
If MPRV is set to one, \textcquote{RiscVISAP}{load and store memory addresses are translated and protected as though the current privilege mode were set to MPP}, i.e. they're performed with the privilege level that has was preempted by taking the trap.
Secondly, there is the MXR field that allows to read executable memory regions.
If MXR is not set, attempting to read from a memory region marked as executable will fail.
If MXR is set, such reads can succeed if said region is also marked as readable.
% TODO: is page-based virtual memory given?
MXR is only applicable though, if page-based virtual memory is in place.

The last register we will introduce is the \gls{mscratch} register which can be used by machine-mode to be read from and written to for preserving any value the machine-mode would like to see preserved.
The intended use-case for this register by the specification is that \textcquote{RiscVISAP}{it is used to hold a pointer to a machine-mode \gls{hart}-local context space and swapped with a user register upon entry to a \textins{machine}-mode trap handler}.

% TODO: Introduce pma- and pmpcfg

\paragraph{Other Mechanisms}
\label{sec:other-mechs}

\subparagraph{Timer and performance counter \glspl{csr}}
There also is a group of registers dealing with timers and hardware performance monitoring, namely: \gls{mtime}, \gls{mtimecmp}, \gls{mcycle}, \gls{minstret}, \gls{mhpmcountern}, \gls{mhpmeventn} and \gls{mcounteren}.
Details on these registers will be skipped here as these registers also won't be part of this thesis.
The reasoning for skipping these is not as straight-forward as for the previously introduced registers.
In general, timer and performance counting registers can be used for side channel attacks.
In \cite{Qian16} the authors give an overview over timing-side-channel-attacks which by their very nature always need to rely on some notion of time.
This notion can be given by timer and performance counter registers which for example hold the number of instructions executed since a given point in time.
For example, the authors discuss an attack where a side channel to OpenSSL's implementation of \gls{rsa} could be introduced by differentiating between multiplications and squares being performed.
Such a differentiation could be easily done if performance counter registers where to count such instructions and were to leak information to lower privilege levels.
This means that in principle, timer and performance counter registers are relevant for the security of an architecture.
However, they do not introduce new notions of information flow to the architecture and are therefore redundant to our thesis.

It is the case that contents of these registers are confidential as their contents might be used to introduce side-channels to other applications running on the processor.
However, their core mechanisms are not unique.
They can be read and written to and might generate interrupts.
Therefore, dealing with information flow in general is sufficient for our approach and these registers can be safely ignored without loosing major aspects of the \gls{riscv} functionality.

Besides the interrupts and exceptions that have been introduced in the last few paragraphs, there are two further \textit{exceptional conditions} that can occur in a \gls{hart}.

\subparagraph{Reset}
The first of these is the reset.
The specification does not explicitly define how resets are triggered but it is clear that at least hardware must be capable of triggering a reset, e.g. by the push of a button that is on a shared board with the processor.
As the specification gave an exhaustive list of exceptions and interrupts available to the system (which is given in table \ref{tbl:interrupt-exception-codes}), it is assumed here that resets can be triggered by hardware only.

On reset, the \gls{pc} is set to an implementation defined address, the privilege mode is set to machine-mode, the MIE and MPRV bits in \gls{mstatus} are set to 0 and \gls{mcause} should be written with implementation-defined values to indicate the cause of the reset.
The specification explicitly mentions that \textcquote{RiscVISAP}{%
    \textins{a}ll other hart state is undefined
} although software located at the reset vector might write \glspl{csr} with arbitrary values.

% Source: https://stackoverflow.com/a/46989066/7194995
Although the specification itself says that the \textcquote{RiscVISAP}{\texttt{pc} is set to an implementation-defined reset vector} and does not lay any constraints on this, this address must not be the same as \gls{mtvec}.
The reason for this is given in a comment to this section where it says:
\begin{displaycquote}{RiscVISAP}
    \texttt{mcause} reset values may alias \texttt{mcause} values following synchronous exceptions.
    There is no ambiguity in this overlap, since on reset the \texttt{pc} is set to a different value than on other traps.
\end{displaycquote}

Although comments should not be taken with the same weight as regular passages of the specification, the intent behind this comment is quite clear and as it only slightly contradicts the specification we will go with this interpretation.

\subparagraph{Non-Maskable Interrupts}
The other exceptional condition are \glspl{nmi}.
The specification describes these as: \textcquote{RiscVISAP}{%
    \textins{NMIs} are only used for hardware error conditions, and cause an immediate jump to an implementation-defined NMI vector running in M-mode regardless of the state of a hart's interrupt enable bits.
}
Similar to resets, nothing is said about the mechanisms to trigger \glspl{nmi} in the specification.
For the same reasons given in the paragraph about reset, we will assume that \glspl{nmi} can only be triggered by hardware.

On jump to the \gls{nmi} handler address, \gls{mepc} is written with the next address to be read and executed and \gls{mcause} is written with information about the cause of the \gls{nmi}.
Other \glspl{csr} are left untouched.

% TODO: Summarize

% TODO: Add goal of the architecture and in particular, checking it

\subsection{The MINRV8 Architecture}
\label{sec:minrv8}

The architecture that will be model checked in this thesis is a minimal, \gls{riscv}-inspired 8-bit architecture and shall be named MINRV8 from now on.
A secure embedded system that implements the RV32E, i.e. base integer instruction set for embedded computing, was taken as a role model for this minimal architecture.

MINRV8 supports 4 general purpose registers and has two privilege modes: machine- and user-mode.
Besides this, it has 4-bytes of readable and writeable memory which is divided into two regions the first of which ranges from addresses 0 to 1 whereas the other occupies all remaining addresses, i.e. 2 to 3.
MINRV8 supports basic instructions for memory reads and writes, integer arithmetic with $ + $ and $ - $, bit-shifts, bitwise-logical operations with \minrv{And} and \minrv{Or}, a \minrv{Mov} instruction to move a word from one register to another, a comparison instruction, two instructions to switch privilege mode and instructions to read and write \glspl{csr}.
A full list of all instructions can be found in table \ref{tbl:min-arch-instrs}.
Machine words are generally interpreted as signed-words thus there won't be unsigned counterparts to integer arithmetic or the comparison instruction.

\begin{table}
    \centering
    \begin{tabular}{|l p{8cm}|}
        \hline
        \minrv{Load rd, rs1} & Load the word stored in memory at the address stored in registers \minrv{rs1} modulo 4 into register \minrv{rd} \\
        \minrv{Store rs1, rs2} & Store the word located in register \minrv{rs2} into memory at address stored in register \minrv{rs1} modulo 4 \\
        \minrv{Loadi rd, imm} & Load the 8-bit immediate value \minrv{imm} into register \minrv{rd} \\
        \minrv{Add rd, rs1, rs2} & Set register \minrv{rd} to the sum of the values in registers \minrv{rs1} and \minrv{rs2} \\
        \minrv{Sub rd, rs1, rs2} & Set register \minrv{rd} to the value of register \minrv{rs1} minus the value of register \minrv{rs2} \\
        \minrv{And rd, rs1, rs2} & Set register \minrv{rd} to the result of a bitwise-and of the values of registers \minrv{rs1} and \minrv{rs2} \\
        \minrv{Or rd, rs1, rs2} & Same as \minrv{And} but with the bitwise-or operation \\
        \minrv{Mov rd, rs1} & Set register \minrv{rd} to the content of register \minrv{rs1} \\
        \minrv{Sll rd, rs1, rs2} & Set register \minrv{rd} to content of register \minrv{rs1} shifted left logically (i.e. without sign-extension) by the value in register \minrv{rs2} \\
        \minrv{Sra rd, rs1, rs2} & Set register \minrv{rd} to the content of register \minrv{rs1} shifted right arithmetically (i.e. with sign-extension) by the value in register \minrv{rs2} \\
        \minrv{Slt rd, rs1, rs2} & Set register \minrv{rd} to 0x01 if the value in register \minrv{rs1} is smaller than the value in register \minrv{rs2} \\
        \minrv{Ecall} & Environment call to machine-mode \\
        \minrv{Mret} & Machine-mode return from trap handler \\
        \minrv{Csrrs rd, rs1, rs2} & Read the value of the \gls{csr} with index \minrv{rs1} modulo the number of all \glspl{csr} and store it in register \minrv{rd}; additionally, set all bits of the \gls{csr} high that are high in register \minrv{rs2} \\
        \minrv{Csrrc rd, rs1, rs2} & Same as \minrv{Csrrs} but set all bits low that are low in register \minrv{rs2} \\
        \hline
    \end{tabular}
    \caption{Instructions of the MINRV8 architecture}
    \label{tbl:min-arch-instrs}
\end{table}

Besides the general purpose storage options, MINRV8 also includes three \glspl{csr}: an \gls{mstatus} equivalent, a \gls{pmpcfg} equivalent and a \gls{pmacfg} register that implements the configuration of some \glspl{pma} as described in section \ref{sec:memory-attrs}.
MINRV8 supports external interrupts as the only source of interrupts and an environment call to machine-mode as the only source of exceptions.
Therefore, in the context of MINRV8, \gls{mstatus} has 4 bits comprising two stacking bits for taking traps, a MEIP bit to signal pending external interrupts and a MIE bit to en- or disable interrupts.

The \gls{pmacfg} register defines cacheability of the two memory regions.
Each memory region can either be set as uncacheable, write-back-cacheable, write-through-cacheable or write-protected-cacheable.
% TODO: Introduce intel architecture
% TODO: Is it really the x86 architecture?
% TODO: Introduce caching in detail
These caching methods are inspired by the caching methods that are available in the x86 architecture from Intel as described in section 11.3 \textit{Methods of Caching Available} of the System Programming Guide in the Software Developer's Manual.
This manual describes these methods of caching as follows:
\begin{displaycquote}[p.11-7]{IntelSystemProgramming}
    \begin{description}
        \item[Write-through (WT)] --- \textelp{} Reads come from cache on cache hits; read misses cause cache fills. \textelp{}
        All writes are written to a cache line (when possible) and through to system memory.
        When writing through to memory, invalid cache lines are never filled, and cache lines are either filled or invalidated. \textelp{}
        \item[Write-back (WB)] --- \textelp{} Reads come from cache lines on cache hits; read misses cause cache fills. \textelp{}
        Write misses cause cache line fills \textelp{}, and writes are performed entirely in the cache, when possible. \textelp{}
        The write-back memory type reduces bus traffic by eliminating many unnecessary writes to system memory.
        Writes to a cache line are not immediately forwarded to system memory; instead, they are accumulated in the cache.
        The modified cache lines are written to system memory later, when a write-back operation is performed.
        Write-back operations are triggered when a cache lines need to be deallocated, such as when new cache lines are being allocated in a cache that is already fill. \textelp{}
        \item[Write-protected (WP)] --- Reads come from cache lines when possible, and read misses cause cache fills.
        Writes are propagated to the system bus and cause corresponding cache lines on all processors on the bus to be invalidated.
        \textelp{}
    \end{description}
\end{displaycquote}

These paragraphs vom the System Programming Guide are summarized in table \ref{tbl:cache-methods}.
In this setting, it was decided to always fill the cache on write-hits for write-through-cacheable memory regions to make the caching methods as concise as possible although the manual leaves it open to implementations to also invalidate the cache.

\begin{table}
    \centering
    \begin{tabular}{| c r | c c c c |}
        \hline
        && Uncached & WB & WT & WP \\
        \hline
        \multirow{2}{*}{Write} & Hit & \ding{53} & Fill & Fill if valid & Invalidate \\
        & Miss & \ding{53} & Fill & \ding{53} & \ding{53} \\
        \hline
        \multirow{2}{*}{Read} & Hit & \ding{53} & Read & Read & Read \\
        & Miss & \ding{53} & Fill & Fill & Fill \\
        \hline
    \end{tabular}
    \caption{Caching Methods}
    \label{tbl:cache-methods}
\end{table}

The \gls{pmpcfg} register allows to set read and write privileges per memory region and also allows to lock the settings of individual regions.

Someone experienced in the field of microcontrollers and processors might find MINRV8 to lack some crucial features, such as jump and branch instructions and the specification of executable memory or an instruction fetch unit.
These points were left out or left unspecified deliberately.
However, a good reasoning for this can not be given at this point.
The development of the MINRV8 architecture was tightly coupled to its implementation in nuXmv which will presented in section \ref{sec:model-implementation}.
In section \ref{sec:model-scope}, the scope of the MINRV8 architecture will be analyzed - both in terms of what it tries to achieve and what it actually is capable of representing, i.e. how close it is to real-life architectures.
In this section, the aforementioned problems will also be reflected.

\subsection{Implementation of MINRV8 in nuXmv}
\label{sec:model-implementation}

% TODO: better introduction, i.e. introduce the parts we will talk about and nuXmv in general (this might have already been done in the introduction then)

\subsubsection{Core Functionality}

\paragraph{Variables}
In nuXmv, models of a piece of software, hardware or in this case a specification are described using variables with transition relations.
The core of the model is implemented using four variables:
\begin{itemize}
    \item \smv{priv : boolean}
    \item \smv{csrs : array 0..1 of unsigned word[8]}
    \item \smv{regs : array 0..3 of signed word[8]}
    \item \smv{memory : array 0..3 of signed word[8]}
\end{itemize}

As the names suggest: \smv{priv} indicates the current privilege mode where \smv{TRUE} means that the \gls{hart} is in machine-mode and \smv{FALSE} means that the \gls{hart} is in user-mode.
\smv{csrs} hold the three \glspl{csr} of the MINRV8 architecture.
Technically, only 16 bits are needed to implement all \glspl{csr} of the MINRV8 architecture which is why only two \enquote{physical} \glspl{csr} are modelled.
This allows to implement a homogeneous interface for memory/register reads and writes and does not introduce unused bits to the implementation, i.e. dead state space that still requires traversal from nuXmv.
\gls{mstatus} is located in the lower half (bits 0 to 3) of \smv{csrs[0]}, \gls{pmacfg} in the upper half (bits 4 to 7) of \smv{csrs[0]} and \gls{pmpcfg} in \smv{csrs[1]}.
The variables \smv{regs} and \smv{memory} implement the registers and memory in a straight-forward fashion.

Furthermore, the model knows five input variables:
\begin{itemize}
    \item \smv{op}
    \item \smv{rd : 0..3}
    \item \smv{rs1 : 0..3}
    \item \smv{rs2 : 0..3}
    \item \smv{m_external_interrupt : unsigned word[1]}
\end{itemize}

\smv{op}, \smv{rd}, \smv{rs1} and \smv{rs2} represent a fully decoded instruction where \smv{op} is the opcode as a symbolic constant and the other arguments point to registers with per-instruction determined semantics.
When an instruction does not support some or all of the arguments to the instruction, the values of these input variables are simply ignored.
The variable \smv{m_external_interrupt} signals the event of a pending external interrupt from some source outside of the \gls{hart}.

There is no input variable for an immediate value which might be needed by the \minrv{Loadi} instruction because otherwise, extra state space would be wasted.
% TODO: is this understandable?
Instead, the content of the destination register in the case of a \minrv{Loadi} instruction being executed is not constrained.
Thereby, the value written to the destination register by the \minrv{Loadi} instruction is encoded implicitly in the transition relation rather than in the state space.

\paragraph{Transitions}
nuXmv allows to constrain the transition of variables by arbitrary formulas expressed in propositional logic.
The system can make a transition if it satisfies all formulas given as constraints.
Therefore - if full control over the transition relation is desired - it often is not sufficient to simply constrain transitions by a group of implications\footnote{%
    The exception to this are groups of implications where the antecedents form a total case differentiation, i.e. where one antecedent is always true.
}.

\begin{example}
    Consider this nuXmv model that implements an adder that can store its result in two registers:
    \begin{lstlisting}[language=smv]
        MODULE main
            VAR
                r1 : integer;
                r2 :integer;
            IVAR
                ri : 1..2;
                summand1 : integer;
                summand2 : integer;

            DEFINE sum := summand1 + summand2;

            TRANS ri = 1 -> next(r1) = sum;
            TRANS ri = 2 -> next(r2) = sum;

            LTLSPEC G (ri = 1 -> r2 = next(r2));
            LTLSPEC G (ri = 2 -> r1 = next(r1));
    \end{lstlisting}

    At first, this implementation seems to match the intuition of the adder.
    It is declared imperatively that when the selector input variable \smv{ri} equals 1, \smv{r1} is updated and when it equals 2, \smv{r2} is updated.
    However, attempting to prove one of the two properties in the model which both state that a register doesn't change if it isn't selected, results in nuXmv quickly giving a counter-example.
    This is because the implications do not fully cover all possible transitions of the system.
    On a transition where \smv{ri} does not equal 1 (or 2), the next value of \smv{r1} (or \smv{r2}) is not constrained, i.e. can change to any value.
    Swapping out the implication \smv{->} with a iff \smv{<->} does not solve this as now only that whenever the next value chosen randomly for \smv{r1} or \smv{r2} happens to coincide with the sum of the input variables, \smv{ri} must be equal to the appropriate index.
    In all other cases, nuXmv still can choose whatever next value it wants.

    The only solution to this is covering all other cases and explicitly stating what should happen then as for example can be done by using an inline-if expression:
    \begin{lstlisting}[language=smv]
        TRANS next(r1) = (ri = 1 ? sum : r1);
        TRANS next(r2) = (ri = 2 ? sum : r2);
    \end{lstlisting}

    Now, whenever \smv{ri} is not equal to the respective index, \smv{r1} (or \smv{r2}) will be stable.
    With this implementation, nuXmv fails to find a counter-example for the two LTL properties.
\end{example}

% TODO: What is SMV?
In the implementation in SMV of the MINRV8 architecture, \smv{case}-expressions that always close with a default statement were used to ensure that transitions of variables are always fully constrained.

In the following, the \enquote{formal idea} of the variable transitions of the model will be introduced.
In this context, it is assumed that variables are stable unless otherwise mentioned, i.e. default statements of model explicitly are not listed for the most part.

The transitions of the \smv{priv} variable are simple.
There are two conditions by which \smv{priv} can change.
Firstly, whenever there is an exception - be it an exception triggered by a pending external interrupt or a environment call to machine-mode exception - the \gls{hart} switches to machine-mode and does not execute the current instruction, i.e. the value of \smv{op}, \smv{rd}, \smv{rs1} and \smv{rs2} are ignored.
Secondly, when the \minrv{Mret} instruction is executed, the \gls{hart} sets \smv{priv} to the value stored in \gls{mstatus}.MPP (cf. section \ref{sec:rv-exn}).

\gls{mstatus} changes under the same conditions which leads to the transitions of \smv{csrs}.
On a trap, MPP and MPIE are written accordingly while MEIP and MIE are set to zero.
MEIP can be set to zero although the trap might have been triggered by an \minrv{Ecall} instruction because interrupts have higher priority in \gls{riscv} than synchronous exceptions.
To understand why this is correct, there are two cases to consider.
Either an external interrupt was set pending: then it must be serviced immediately and MEIP must be cleared; or it wasn't set pending: then writing MEIP with 0 does not change the state of the \gls{hart}.
On return from machine-mode, i.e. execution of \minrv{Mret}, MIE is written with MPIE, MPIE is set to 1 and MPP is set to 0; all other bits are left unchanged.
An exception to the rules mentioned above is the field MEIP which can be set high on every transition based on the value of \smv{m_externel_interrupt}.

The \glspl{csr} can also be written by the \minrv{Csrrc} or \minrv{Csrrs} instructions.
In order to control read- and write-access to the \glspl{csr}, the model knows two constant arrays:
\begin{lstlisting}[language=smv]
    __csrs_read_privs := [ 0h_0F, 0h_00 ];
    __csrs_write_privs := [ 0h_FF, 0h_FF ];
\end{lstlisting}

These arrays provide bitmasks that indicate the least privilege level necessary to read or write the \gls{csr} of the corresponding index at the corresponding bit-position.
All \glspl{csr} besides \gls{mstatus} can be read but but no \gls{csr} can be written by user-mode.
These constants are transformed to the bitmasks \smv{csr_read_mask} or \smv{csr_write_mask} respectively by the per-bit $ b $ implication of $ b \rightarrow \texttt{priv} $ based on the index of the currently targeted \gls{csr}.
Bits of \glspl{csr} are changed by the \minrv{Csrrs} or \minrv{Csrrc} instruction only if \smv{csr_write_mask} is high at the corresponding index with two exceptions:
\begin{itemize}
    \item \gls{mstatus}.MEIP cannot be written by software
    \item Once a \gls{pmpcfg} register has been locked, it cannot be changed anymore
\end{itemize}

The transition relation of the registers and memory is easier to understand.
\smv{regs} changes at index \smv{i} if it is targeted by some instruction and no trap is taken.
Then, \smv{regs[i]} is written with a value determined by the instruction semantics\footnote{%
    This only applies to instructions that \textit{have} semantics targeting registers, e.g. \minrv{Ecall} will not change values of any register.
}.
These per-instruction semantics include considering the \smv{csr_read_mask} bitmask on \minrv{Csrrs} and \minrv{Csrrc}.

\smv{memory} is written at index \smv{i} if it is targeted by the \minrv{Store} instruction, no trap occurs and the write privilege settings in \gls{pmpcfg} allow the current privilege mode to write the register.
Otherwise \smv{memory} does not change.
It does not mark an error, should the current privilege level not suffice to write the targeted memory address.
No exception will be generated - the memory simply will not be written.
The same is true for read privileges and \smv{regs} on a \minrv{Load}.

\subsubsection{Caching}

% TODO: mention that the cache is its own module accessible via \texttt{cache}
The cache spices up transitions of memory and registers and comprises three variables:
\begin{itemize}
    \item \smv{addr : 0..3}
    \item \smv{valid : boolean}
    \item \smv{line : signed word[8]}
\end{itemize}

These variables transition dependent on the cache-configuration of the respective memory region in \gls{pmacfg}.
As already introduced in section \ref{sec:minrv8}, a memory region can be either set as uncacheable, write-back-cacheable or write-through-cacheable.
If a memory region is set as uncacheable, the cache will ignore reads and writes to this region and not make any transition.

\paragraph{Reads}
If a memory region is set as cacheable\footnote{%
    In context of this thesis, \enquote{cacheable} means that a memory region is marked as write-back-cacheable, write-through-cacheable or write-protected-cacheable.
}, reads will trigger a cache-fill.
On a \minrv{Load} if the cache is invalid or currently holds the contents of a different memory address than targeted, \smv{addr} gets written with \smv{regs[rs1] mod 4}, \smv{valid} becomes \smv{TRUE} and \smv{line} is written with \smv{memory[addr]}\footnote{%
    \smv{addr} here refers to the already updated value of that variable, i.e. \smv{regs[rs1] mod 4}.
}.
This process is independent of the current privilege level, e.g. user-mode can cause a cache-fill with memory content in regions that are unreadable to it.
Though, user-mode still won't be able to read the respective word as reads are privileged controlled.

If, however, on a \minrv{Load} the cache already holds the targeted word, is valid and the current mode suffices to read the respective memory address, \smv{line} instead of \smv{memory[regs[rs1] mod 4]} will be written into register \smv{rd}.

\paragraph{Writes}
From the cache's perspective, writes to regions which are set cacheable work the same way, regardless of the specific region's cacheability settings.
For such a region, on a \minrv{Store}, \smv{line} will be written with \smv{regs[rs2]}, \smv{address} with \smv{regs[rs1] mod 4} and \smv{valid} will become \smv{TRUE}.
However, if the region is set to be write-through-cacheable, the write will also be reflected in memory whereas for a write-back-cacheable region the write will be reflected in cache only.

This brings the need to persist writes to the cache in memory when cache lines are evicted.
For example, consider the following program where it is assumed that \minrv{regs[1] mod 4 != regs[2] mod 4}:
\begin{lstlisting}[language=minrv8]
    Store 1, 0  # store regs[0] at memory[regs[1] mod 4]
    Load 0, 2   # read memory[regs[2] mod 4] to regs[0]
\end{lstlisting}

If the memory region targeted by \minrv{regs[1]} was set to be write-back-cacheable the write in the first line would not be persisted in memory but would happen on cache level only.
If furthermore the memory region targeted by \minrv{regs[2]} was set to be cacheable as well, the read in the second line would overwrite changes of the first instruction which is why the cache content must first be written to memory.
Therefore, if the cache holds some non persisted values of write-back-cacheable memory regions and either the cache's target changes or the \gls{pmacfg} attributes change such that the cache is not write-back-cacheable anymore, the content of the cache will be written to memory as well.

\subsection{Scope of the Model}
\label{sec:model-scope}

In summary, the MINRV8 architecture knows three groups of instructions (cf. table \ref{tbl:min-arch-instrs}):
\begin{itemize}
    \item Computational instructions such as Mov, \minrv{And}, \minrv{Add}, etc.
    \item Memory instructions \minrv{Load} and \minrv{Store}
    \item System instructions \minrv{Ecall}, \minrv{Mret}, \minrv{Csrrs}, \minrv{Csrrc}
\end{itemize}

MINRV8 is meant to be a reasonable abstraction of a real-world \gls{riscv} architecture from a security standpoint.
However, up to this point nothing has been said about the limits of this abstraction.
With every abstraction, there is a small chance that it perfectly matches the concept that has been abstracted but in most cases, some corners are cut.
In this section, we will reflect on the limits of the MINRV8 architecture and its implementation.

% TODO: mention that other fields are well modelled
% TODO: mention that we actually don't need all computational instructions
% TODO: mention performance hit of dynamic memory regions

A reader, experienced in the field of microcontrollers or computer-architecture in general might wonder why our model does not include:
\begin{enumerate}
    \item Executable memory and a \gls{pc}
    \item Jump or branch instructions
    \item A model of a stack pointer
\end{enumerate}

In the introduction of the MINRV8 architecture in section \ref{sec:minrv8} we mentioned that the idea of the architecture was tightly coupled to its implementation.
The design of the model had to answer the question: How can a stream of instructions be implemented?
nuXmv allows to think of the following options:
\begin{enumerate}
    \item \label{itm:exmem-frozen}
    Use \smv{FROZENVAR}s to model executable memory - a \smv{FROZENVAR} is something like a constant in other programming languages but without a fixed value.
    nuXmv chooses the value on the first simulation step but does not change it afterwards.
    This is more efficient than using plain \smv{VAR}s with no transitions.
    \item \label{itm:exmem-var}
    Use \smv{VAR}s to model executable memory.
    In practice, this would mean that the memory of the implementation as described in section \ref{sec:model-implementation} would be much larger than the current 4 bytes.
    \item \label{itm:exmem-ivar}
    Finally, use \smv{IVAR}s to model the stream of instruction.
    This is the option we decided to go for as described in section \ref{sec:model-implementation}.
    Using \smv{IVAR}s means that there is no model of executable memory.
    % TODO: is the part about the ALU actually true?
    Instead, the input variables provided to the implementation model the result of an instruction decoder that hands the \gls{alu} the ready-to-use decoded instructions on each transition of the simulated model.
    As such, the architecture does not need to worry \textit{where} these instructions come from.
\end{enumerate}

\subsection{Trustworthiness of the Model}
