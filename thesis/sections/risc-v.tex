%!TEX root = ../thesis.tex

\section{An Introduction to RISC-V}
\label{sec:risc-v-intro}

\gls{riscv} was originally presented in the technical report \textit{UCB/EECS-2011-62} by the University of California in May 2011 \cite{RiscVISA-org} and since then has undergone many changes.
\gls{riscv} divides its architectural specification into two volumes: in volume 1 the base user-level \gls{isa} is described which is separated into several modules whereas volume 2 defines the privileged architecture and instruction set but still only is available as a draft.
The privileged architecture is not divided into modules but rather \textit{functional groups} that define certain aspects of privileged computing.
Such groups include for example machine- and supervisor-level \glspl{isa} and the description of a platform level interrupt controller.

% TODO: Add motivation/goals of RISC-V

In this thesis, we work with version 2.2 of volume 1 \cite{RiscVISA} and version 1.1 of volume 2 \cite{RiscVISAP}.
\gls{riscv} understands itself as a highly customizable architecture.
Currently, there are four variants of a base integer instruction set - one of which must be implemented by any \gls{riscv} processor - and 13 of optional extensions.
The base integer instruction sets include instructions for integer arithmetic, memory operations (loads and stores), control transfer (jumps and branches) and platform management (environment calls and status register operations).
The base integer instruction sets mainly differ in the word-size and register number.
To cope with these differences, they also make small adjustments to some functionalities but only introduce slight changes to the instruction set itself.
These four base integer instruction sets are given by:
\begin{description}
    \item[RV32I] Base integer instruction set
    \item[RV32E] Base integer instruction set for embedded computing
    \item[RV64I] Base integer instruction set for a 64-bit architecture
    \item[RV128I] Base integer instruction set for a 128-bit architecture
\end{description}

The \gls{riscv} manual differentiates between standard and non-standard extensions but only introduces standard ones.
A standard extension is meant to be compatible with any other standard extension and should be \textcquote{RiscVISA}{generally useful} whilst non-standard extensions might add support for more niche use-cases and do not need to be compatible with all standard extensions.

The set of functionalities offered by standard extensions begins at quite low level with the probably most mundane being the standard extension for integer multiplication and division.
You can find a list of all standard extensions in table \ref{tbl:rv-exts}.

\begin{table}
    \centering
    \begin{tabular}{| c | l |}
        \hline
        \textbf{M} & Integer multiplication and division \\
        \textbf{A} & Atomic instructions \\
        \textbf{F} & Single-precision floating-point arithmetic \\
        \textbf{D} & Double-precision floating-point arithmetic \\
        \textbf{Q} & Quad-precision floating-point arithmetic \\
        \textbf{L} & Decimal floating-point arithmetic \\
        \textbf{C} & Compressed instructions \\
        \textbf{B} & Bit manipulation \\
        \textbf{J} & Dynamically translated languages \\
        \textbf{T} & Transactional memory \\
        \textbf{P} & Packed-SIMD instructions \\
        \textbf{V} & Vector operations \\
        \textbf{N} & User-level interrupts \\
        \hline
    \end{tabular}
    \caption{All \gls{riscv} standard extensions}
    \label{tbl:rv-exts}
\end{table}

\paragraph{Naming strings}
A subset of the \gls{riscv} \gls{isa} is described by a so called \textcquote{RiscVISA}{\gls{isa} naming string} which is defined as:

\begin{grammar}
    <naming-string> ::= `RV' (`32' | `64' | `128') (`I' | `E') <extensions>
\end{grammar}

An example for a naming string is the very common \gls{isa}-subset RV64IMAFD which officially is abbreviated by RV64G.
This subset includes the integer multiplication and division, user-level interrupts, atomic instructions, single-precision and double-precision floating-point arithmetic extensions.

This section will introduce the core of the \gls{riscv} architecture by shedding light on the base integer instruction set in section \ref{sec:rv-base-int-isa} and the mechanisms of the privileged part of the architecture in \ref{sec:rv-priv-arch}.

\subsection{The Base Integer Instruction Set}
\label{sec:rv-base-int-isa}

A \gls{riscv} core consists of multiple \glspl{hart}.
Each \gls{hart} controls its own registers including a \gls{pc} and is equipped with its own instruction fetch unit.
However, multiple \glspl{hart} share the same memory.

\subsubsection{Registers}
A \gls{hart} might either control 16 or 32 general purpose registers which are named from x0 to x32.
All but the RV32E base instruction sets support 32 general purpose registers whereas the base instruction set aimed at embedded computing only supports 16 general purpose registers.

The first of these general purpose registers is hardwired to zero and might be used as a target register when the result of an instruction is not needed.
This might seem overly restrictive at first glance but having such a dedicated \enquote{sink}-register serves a purpose as hardware can take benefit of this extra knowledge to perform optimizations.
For example, \gls{riscv} defines the pseudo-instruction \gls{nop} as \rv{Addi x0, x0, 0} the semantics of which is: Add the constant value 0 to x0 and store the result in x0.
The intention of which is to \textcquote{RiscVISA}{define a canonical NOP encoding to allow microarchitectural optimizations} which is only possible because the hardware can know that no register will \textit{truly} be read or written so a \gls{nop} might terminate directly without waiting for the \gls{alu} to calculate some values which will never be used.

In \gls{riscv}, there is no dedicated \gls{lr} or \gls{sp}.
Instead, it is the obligation of the software to implement certain calling conventions.
Both jump instructions of \gls{riscv}, \gls{jal} and \gls{jalr}, receive a general purpose register as argument to which they store the return address of the respective jump which - in practice - will be the \gls{lr}.

\gls{riscv} supports up to 4096 \glspl{csr} for additional state.
On the user-level without any extension, there are no \glspl{csr} present so we will postpone a more detailed introduction to \glspl{csr} to section \ref{sec:rv-priv-arch} where we have a look at the privileged architecture of \gls{riscv}.

\subsubsection{Instructions}

\paragraph{Integer arithmetic and Boolean instructions}
The base integer instruction set provides instructions for plus and minus, integer comparisons and the Boolean operators AND, OR and XOR.
Most of these instructions are implemented in two version: a register version (or R-type instruction) and an immediate version (or I-type instruction).
In the first case the two operands are given as registers and in the second case one operand is given as register and the other as an immediate value read from memory.
In either case the value is stored in a destination register.

These basic instructions are all side effect free besides from advancing the program counter which means that if the destination register is x0, each of them encodes a no-operation instruction.
This property makes them particularly easy to analyze.
However, as a side-effect, this means that there is no built-in support for overflow checks via flags in some dedicated \gls{csr}.
There also is no special instruction to handle this.
The authors of the manual show that in general, overflow checks for addition can be handled with three additional instructions after an add instruction:

\begin{lstlisting}[language=rv,caption={General overflow checking \cite{RiscVISA}},label={snpt:rv-overflow}]
Add  t0, t1, t2          # Set R[t0] to R[t1] + R[t2]
Slti t3, t2, 0           # Set R[t3] to R[t2] < 0
Slt  t4, t0, t1          # Set R[t4] to R[t0] < R[t1]
Bne  t3, t4, overflow    # If R[t3] != R[t4] branch to overflow
\end{lstlisting}

The gist of snippet \ref{snpt:rv-overflow} boils down to: we can check if there was overflow when calculating $ a + b $ by checking whether $ b < 0 \leftrightarrow a + b < a $ is false, i.e. \textcquote{RiscVISA}{the sum should be less than one of the operands if and only if the other operand is negative}.

\paragraph{Memory operations}
There are two types of instructions that deal with external memory.
Firstly, simple load and store instructions that read from or write to memory.
Secondly, FENCE instructions that synchronize memory access between multiple \glspl{hart}.

Memory in \gls{riscv} is byte-addressable.
Therefore, load and store operations in \gls{riscv} can read or write words of size 8-, 16-, 32-, 64- or 128-bits, depending on the maximum word length of the base instruction set of choice.
Read- and write-addresses don't have to be aligned by software before using them, however, if they are not, the architecture must first align them before fetching from or storing to them, i.e. reading a 32-bit word from memory at address 0x1 is impossible.
If this address is given as argument to a respective load instruction it'll be aligned to the address 0x0.

\paragraph{Control transfer instructions}
There are two types of instructions that can control program flow in \gls{riscv}: jumps and branches.
In short, jumps are performed unconditionally and can target a wider range in memory (at least $ \pm 2^{20}\text{bits} $ in case of a 32-bit architecture) whereas branches are performed conditionally, only can target a narrower range in memory ($ \pm 2^{12}\text{bits} $ in case of a 32-bit architecture) and always must branch to \gls{pc}-relative addresses.

In contrast to memory operations, addresses targeted by jumps must be aligned correctly otherwise an exception will be generated.

Jumps are intended to call routines and functions.
This is why they store a return address to some general purpose register.
Branches on the other hand are intended to control the program flow of one such routine or function, e.g. to implement an \textit{if-else} structure or \textit{for}-loops where code won't return from the branched execution.
\gls{riscv} is agnostic about the details of calling conventions for routines, e.g. how the stack is organized, which general purpose registers are used as \gls{lr} or \gls{sp}, and leaves these details to be implemented by software running on the core.

\paragraph{Platform management instructions}
The last type of instructions we will have a look at are platform management instructions.
The \gls{riscv} manual also knows this category and divides it into two subcategories: instructions that deal with \glspl{csr} and other instructions that perform operations that potentially need some form of privilege.
Examples for the former category are straight forward.
\gls{riscv} knows instructions to read or write complete \glspl{csr} but also knows operations to modify single bits only.
For the latter category, \gls{riscv} only knows two instructions at the base instruction set level which are \gls{ecall} and \gls{ebreak} instructions.
We will inspect these instructions in more detail in section \ref{sec:rv-priv-arch}.

\paragraph{Summary}
The base integer instruction set of \gls{riscv} gives you everything you need for implementing a comfortable Turing-machine but pretty much nothing more.
You can perform basic arithmetic with integers or bit vectors of Booleans, load and store results of your calculations and abstract your code by using jumps and branches.
At this point, there is no state with predefined semantics, i.e. all state available is given by storage that can only influence computation when used by a programmer.

Only the platform management instructions give a hint on the complexity that is offered by the \gls{riscv} architecture to allow abstracting processing done on the core.

\subsection{The Privileged Architecture}
\label{sec:rv-priv-arch}

The privileged architecture of \gls{riscv} in \cite{RiscVISAP} mainly specifies three concepts:
\begin{enumerate}
    \item Three levels of privilege
    \item Exceptions, traps and interrupts
    \item Memory attributes
\end{enumerate}

The three levels of privilege form the basis of everything that is defined by the privileged architecture.
The purpose of interrupts and exceptions is not only to handle error conditions that arise during runtime but also to communicate between privilege layers.
Therefore, interrupts and exceptions are being used by up to this point unmentioned auxiliary mechanisms of the architecture that aid the highest privilege in administrating the platform.

Also, memory attributes rely on these levels of privilege as they define which mode is eligible to do some operation on some region of memory.

In this section, we will subsequently introduce the aforementioned concepts and conclude with a sketch of the auxiliary mechanisms that build on top of these.

\subsubsection{Levels of Privilege}

\gls{riscv} knows three privilege levels: user-mode, supervisor-mode and machine-mode\footnote{%
    In an earlier version, there was a fourth privilege-mode being hypervisor-mode that sat between supervisor- and machine-mode.
    However, support for this mode has been dropped.
    This leads \gls{riscv} still with the need to encode mode-relative bit-fields in a size of 2 where 00 stands for user-, 01 for supervisor and 11 for machine-mode.
    10 is reserved in most places.
}.
Each implementation of the \gls{riscv} specification must at least provide machine-mode as a base mode of operation.
Besides this, there are two other choices of privilege levels netting in three different configurations:
\begin{enumerate}
    \item Machine-mode only as a \textcquote{RiscVISA}{simple embedded system}
    \item User and machine-mode as a \textcquote{RiscVISA}{secure embedded system}
    \item User, supervisor and machine-mode as a \textcquote{RiscVISA}{\textins{system} running Unix-like operating systems}
\end{enumerate}

A visualization of these three combinations is given in figure \ref{fig:rv-priv-lvls} where they are depicted from left to right.
A simple embedded system might be the cheapest to implement and manufacture, however, this system lacks any protection against malicious application code, i.e. one would only want to run such a system in very basic scenarios where full control over all source code and the device itself can be guaranteed.

A secure embedded system supports some application to be run on it while an \gls{aee} running in machine-mode controls the execution of this application.
The application communicates to the \gls{aee} via an \gls{abi} that defines the possible interactions between an application and an \gls{aee}.

A system running a Unix-like \gls{os} enhances on this by having an \gls{os} running in supervisor-mode that communicates with multiple applications running in parallel via an \gls{abi} and itself is managed by a \gls{see} which communicates with the \gls{os} via a \gls{sbi}.
The \gls{see} runs in machine-mode.

\begin{figure}
    \centering
    \subcaptionbox{\centering Simple embedded system}
    [0.18\textwidth]{
        \begin{tabular}{| c |}
            \hline
            Application \\ \hline
        \end{tabular}
    }
    \quad
    \subcaptionbox{\centering Secure embedded system}
    [0.18\textwidth]{
        \begin{tabular}{|c|}
            \hline
            Application \\ \hline
            \cellcolor{black} \textcolor{white}{ABI} \\ \hline
            AEE \\ \hline
        \end{tabular}
    }
    \quad
    \subcaptionbox{\centering System with Unix-like OS}
    {
        \begin{tabular}{| c | c | c |}
            \cline{1-1} \cline{3-3}
            Application & \multirow{2}{*}{\dots} & Application \\
            \cline{1-1} \cline{3-3}
            \cellcolor{black} \textcolor{white}{ABI} & & \cellcolor{black} \textcolor{white}{ABI} \\ \hline
            \multicolumn{3}{| c |}{OS} \\ \hline
            \multicolumn{3}{| c |}{\cellcolor{black} \textcolor{white}{SBI}} \\ \hline
            \multicolumn{3}{| c |}{SEE} \\ \hline
        \end{tabular}
    }
    \caption{Privilege level combinations \cite{RiscVISA}}
    \label{fig:rv-priv-lvls}
\end{figure}

To keep things simple, we will focus on secure embedded systems in this thesis\footnote{%
    This will be justified in more detail in section \ref{sec:model} where we introduce the model that will be verified as part of this thesis.
}.
This means that the architecture we will be working with supports two modes: user- and machine-mode.
Machine-, user- and supervisor-mode do not simply form a linear order of privilege attributes of code execution.
They differ in the concepts that are available to them and therefore must be handled separately.
However, as we will focus on secure embedded systems, we will leave out many parts of the specification which are about supervisor solely.
Supervisor-mode will be handled wherever it fits in the bigger picture but not on its own.

\subsubsection{Exceptions, traps and interrupts}
\label{sec:rv-exn}

Volume 1 of the specification introduces the concept of exceptions, traps and interrupts as follows:
\begin{displaycquote}{RiscVISA}
    We use the term \textit{exception} to refer to an unusual condition occurring at run time associated with an instruction in the current RISC-V thread.
    We use the term \textit{trap} to refer to the synchronous transfer of control to a trap handler caused by an exceptional condition occurring within a RISC-V thread.
    Trap handlers usually execute in a more privileged environment.

    We use the term \textit{interrupt} to refer to an external event that occurs asynchronously to the current RISC-V thread.
    When an interrupt that must be serviced occurs, some instruction is selected to receive an interrupt exception and subsequently experiences a trap.

    The instruction descriptions in following chapters describe conditions that raise an exception during execution.
    Whether and how these are converted into traps is dependent on the execution environment, though the expectation is that most environments will take a \textit{precise} trap when an exception is signaled \textelp{}.
\end{displaycquote}

This - in short - means that a trigger-hierarchy for interrupts, traps and exceptions can be recognized which is depicted in figure \ref{fig:trigger-hierarch}.
In general, interrupts occur asynchronously and trigger synchronous exceptions to be generated for a \gls{hart} which in turn may generate traps but also might be handled otherwise.
The specification mentions the example of the floating-point extension in which exceptions not necessarily generate traps.

\begin{figure}
    \centering
    \tikz \graph[grow right sep] {
        Interrupt -> Exception -> {Trap, ?};
    };
    \caption{Trap-Trigger-Hierarchy}
    \label{fig:trigger-hierarch}
\end{figure}

For the sake of simplicity, we will assume that every exception causes a trap.
As we will not implement any floating-point arithmetic extension, the specification does not demand from us to handle exceptions otherwise and doing so does not serve any purpose at this point.
In following paragraphs, we will give an introduction to the control flow of dealing with interrupts which is depicted in figure \ref{fig:interrupt-handling} and follows these steps:
\begin{enumerate}
    \item If an interrupt or exception is pending, determine the privilege mode to take the trap
    \item Check if the interrupt is enabled
    \item Take the trap
    \item Return from trap handler
\end{enumerate}
Interrupt handling can be understood as a generalized form of exception handling as exception handling in principle works the same but has fewer steps.

\begin{figure}
    \centering
    \begin{tikzpicture}[node distance = 1.5cm, auto]
        \node[block] (pending) {
            An interrupt $ i $ is pending in mode $ y $; let $ x := \text{machine-mode} $
        };

        \node[decision] (takePre) [below=of pending] {$ x\text{ideleg}[i] $ and $ x > y $?};
        \path[line] (pending) -- node[midway] (p2tp) {} (takePre);

        \node[block,text width=8em] (deleg) [left=of takePre] {$ x := x - 1 $};

        \path[line] (takePre) -- node[near start] {yes} (deleg);
        \path[line] (deleg) |- (p2tp);

        \node[decision] (takePre2) [right=of takePre] {$ x > y $ or $ x = y $, $ x\text{status}.x\text{IE} $, $ x\text{ie}[i] $?};
        \path[line] (takePre) -- node[near start] {no} (takePre2);

        \node[block,text width=16em] (take) [below=of takePre2] {
            Write $ x\text{tval} $ accordingly and let $ t := x\text{tvec} $, furthermore set:\\
            $ \begin{aligned}
                & x \text{status}.x\text{PP} := y \\
                & x \text{status}.x\text{PIE} := x\text{status}.x\text{IE} \\
                & x\text{status}.x\text{IE} := 0 \\
                & x\text{epc} := \text{current address} \\
                & x\text{cause}[31] := 1 \\
                & x\text{cause}[30..0] := i \\
            \end{aligned} $
        };
        \path[line] (takePre2) -- node[near start] {yes} (take);
        \path[line,dashed] (takePre2.east) -- node[near start] {no} ++(right:1.5cm);

        \node[decision,text width=6.5em] (jumpPre) [left=of take] {$ x\text{tvec.MODE} $?};

        \path[line] (take) -- (jumpPre);

        \node[block,text width=8em] (vectored) [left=of jumpPre] {$t := t + 4 \times i $};
        \path[line] (jumpPre) -- node[near start] {yes} (vectored);

        \node[block] (handling) [below=of jumpPre] {Jump to $ t $ and execute instructions};
        \path[line] (jumpPre) -- node[near start] {no} node[midway] (jp2h) {} (handling);
        \path[line] (vectored) |- (jp2h);

        \node[block] (return) [below=of handling] {
            Set privilege mode to $ x\text{status}.x\text{PP} $ and $ x\text{status}.x\text{IE} $ to $ x\text{status}.x\text{PIE} $, then jump to $ x\text{epc} $
        };
        \path[line] (handling) -- node[near start] {on $ x\text{RET} $} (return);
    \end{tikzpicture}
    \caption{Interrupt handling flow-chart}
    \label{fig:interrupt-handling}
\end{figure}

\paragraph{Interrupt and exception handling}
There are three categories of interrupts: external interrupts, timer interrupts and software interrupts.
External interrupts are used to signal exceptional events occurring on some external device that is connected to the core.
Timer interrupts can be used to track time.
Code can use certain \glspl{csr} to signal to the platform that it needs to be alerted when a given amount of real world time has passed.
Such an alert will be given by a timer interrupt.
More on this in section \ref{sec:other-mechs}.
Software interrupts can be set pending by software running on the same \gls{hart} with equal or higher privilege than the targeted privilege mode.
Software interrupts have no predefined semantics and thus can be used by programmers or system designers in every imaginable way.

Each of these categories of interrupts can target any privilege-mode netting a total of 6 interrupts available to the platform in our case (or 9 if supervisor-mode is supported).
These interrupt-types are associated with indices in the range from $ 0_{10} $ to $ 11_{10} $, also called interrupt code\footnote{%
    The reader might have noticed that these are more indices than needed to encode all interrupts available - even if supervisor-mode is present.
    Indices 2, 6 and 10 currently are reserved because support for hypervisor-mode was dropped.
    The two least significant bits of the interrupt indices correspond to their respective mode thus 2, 6 and 10 are reserved as their two least significant bits are 10 corresponding to hypervisor-mode.
}.
An overview of all interrupt codes can be found in table \ref{tbl:interrupt-exception-codes}.
Interrupts can be set pending individually in the \gls{mip} register.
An interrupt is set pending if the bit corresponding the interrupts index is set to 1.

If an interrupt or exception is pending, it must first be decided which privilege mode should take the trap to handle the exception generated.
By default, all interrupts and exceptions will be handled by machine-mode.
However, interrupts and exceptions can be delegated to less privileged modes via the \gls{mideleg} and \gls{medeleg} register\footnote{%
    It would also be possible to delegate traps by using the \gls{mret} instruction and setting all corresponding \glspl{csr} accordingly.
    However, this would come with a higher latency as a couple of jumps would need to be performed first.
}.
Similar to \gls{mip} and \gls{mie}, each bit field of \gls{mideleg} corresponds to the interrupt of the same index.
Exceptions also have an exception code assigned and thus, fields of \gls{medeleg} correspond to these codes.
An interrupt or exception can only be delegated to modes equally or higher privileged than the mode the interrupt or exception was targeting originally for example, if an interrupt is targeting supervisor-mode it must be handled by machine-mode or can optionally be delegated to supervisor-mode.
If an interrupt is delegated to mode $ x $, the corresponding bit in $ x\text{ip} $ reads accordingly and $ x\text{ie} $ becomes writable otherwise both registers appear to be hardwired to zero.

After the mode to be targeted by the trap has been determined, it must be checked whether the given interrupt is actually enabled.
Exceptions can't be disabled and therefore will always be taken - as a consequence the following checks will be omitted for exceptions.
Interrupts on the other hand can be dis- or enabled individually in the \gls{mie} register.
Analogously to the \gls{mip} register, an interrupt is enabled if the bit corresponding the interrupts index is set to 1.
Additionally, there is the \gls{mstatus} register which can globally dis- or enable interrupt handling for a specific mode via its $ x\text{IE} $ bits ($ x \in \{ \text{M}, \text{S}, \text{U}\} $\footnote{%
    In future, we will simply use $ x $ or other variables as placeholders for a mode-flag without specifically introducing the variable.
}).
The \gls{ustatus} register only is a restricted view on \gls{mstatus} and therefore \gls{mstatus} holds these bits not only for machine- but any mode.
These $ x\text{IE} $ fields, however, are only taken into account if the \gls{hart} operates at an equal or higher privilege mode than targeted, i.e. interrupts are always enabled globally it is targeting a mode of higher privilege than current operation.
Finally, an interrupt will be taken if interrupts are globally enabled \textit{and} the interrupt itself is enabled in the \gls{mie} register.

If a pending interrupt is taken, the \gls{mepc}, \gls{mcause} and \gls{mtval} registers are written and the platform will jump to a base address held by the \gls{mtvec} register.
\gls{mtvec} also holds a field that controls whether interrupts can be \textit{vectored}, i.e. for interrupts the \gls{pc} is not set to the base address for handling trap but to $ \text{base} + 4 \times \text{cause} $.
\gls{mepc} holds the address of the original instruction stream that was preempted, i.e. either the address of the instruction that caused the exception or the instruction that was next to be executed as a external interrupt was taken.
\gls{mcause} holds an identifier of the current interrupt or exception being handled by the trap.
The most significant bit indicates whether an interrupt is currently being served and all other bits hold the exception or interrupt code.
\gls{mtval} serves as a register to hold arguments for a trap handler.
Technically, it holds \textcquote{RiscVISAP}{exception-specific information to assist software in handling the trap}.
One example for such \enquote{exception-specific information} is that \gls{mtval} can contain the faulting bits of an instruction for an illegal instruction exception whereas \gls{mepc} would only point to the instruction in memory as a whole therefore giving no specific information about which part of the instruction caused the exception.

\gls{mstatus} also holds bits to \enquote{stack} certain values when handling exceptions or interrupts.
Nested interrupts are only supported between privilege modes.
On a trap to handle an interrupt in mode $ x $, interrupts are disabled and the value of the interrupt-enable bit is \enquote{stacked} into a prior-interrupt-enable bit $x\text{PIE} $, i.e. $ x\text{PIE} := x\text{IE} $ and $ x\text{IE} := 0 $.
Additionally, there is a prior-privilege bit $ x\text{PP} $ that stores the privilege mode before the trap was taken.

% TODO: Maybe exactly one instruction? How does alignment play into this?
Note that due to the small offset between vectored interrupt jump destinations, the instructions located there can't perform much more than jumping to the \textit{real} trap handler.
Furthermore, as exceptions can't be vectored, any differentiation between those must be performed by software.

\begin{table}
    \centering
    \begin{tabular}{| r | r | l |}
        \hline
        Interrupt & Exception Code & Description \\
        \hline
        1 & 0 & User software interrupt \\
        1 & 1 & Supervisor software interrupt \\
        1 & 2 & \textit{Reserved} \\
        1 & 3 & Machine software interrupt \\
        \hline
        1 & 4 & User timer interrupt \\
        1 & 5 & Supervisor timer interrupt \\
        1 & 6 & \textit{Reserved} \\
        1 & 7 & Machine timer interrupt \\
        \hline
        1 & 8 & User external interrupt \\
        1 & 9 & Supervisor external interrupt \\
        1 & 10 & \textit{Reserved} \\
        1 & 11 & Machine external interrupt \\
        \hline
        1 & $ \geq $ 12 & \textit{Reserved} \\
        \hline
        0 & 0 & Instruction address misaligned \\
        0 & 1 & Instruction access fault \\
        0 & 2 & Illegal instruction \\
        0 & 3 & Breakpoint \\
        0 & 4 & Load address misaligned \\
        0 & 5 & Load access fault \\
        0 & 6 & Store \textelp{} address misaligned \\
        0 & 7 & Store \textelp{} access fault \\
        0 & 8 & Environment call from U-mode \\
        0 & 9 & Environment call from S-mode \\
        0 & 10 & \textit{Reserved} \\
        0 & 11 & Environment call from M-mode \\
        0 & 12 & Instruction page fault \\
        0 & 13 & Load page fault \\
        0 & 14 & \textit{Reserved} \\
        0 & 15 & Store \textelp{} page fault \\
        0 & $ \geq $ 16 & \textit{Reserved} \\
        \hline
    \end{tabular}
    \caption{Interrupt and exception codes \cite{RiscVISAP}}
    \label{tbl:interrupt-exception-codes}
\end{table}

\paragraph{Summary}
You can find an overview over all registers that are involved in trap handling in table \ref{tbl:trap-csrs}.
Those \glspl{csr} which are available to user-mode would also be available to supervisor-mode in this context.
Registers written in italic font are not actual registers on their own but provide a restricted view on their respective machine-mode counterparts.

\begin{table}
    \centering
    \begin{tabular}{| c c || l |}
        \hline
        \textbf{Machine-mode} & \textbf{User-mode} & \textbf{Description} \\
        \acrshort{mstatus} & \textit{\acrshort{ustatus}} & Status \\
        \acrshort{mie} & \textit{\acrshort{uie}} & Interrupt enable \\
        \acrshort{mip} & \textit{\acrshort{uip}} & Interrupt pending \\
        \acrshort{mtvec} & \acrshort{utvec} & Trap-vector base address \\
        \acrshort{mscratch} & \acrshort{uscratch} & Scratch \\
        \acrshort{mepc} & \acrshort{uepc} & Exception program counter \\
        \acrshort{mcause} & \acrshort{ucause} & Trap cause \\
        \acrshort{mtval} & \acrshort{utval} & Trap value \\
        \acrshort{medeleg} & & Exception delegation \\
        \acrshort{mideleg} & & Interrupt delegation \\
        \hline
    \end{tabular}
    \caption{Trap-handling \glspl{csr}}
    \label{tbl:trap-csrs}
\end{table}

To summarize the mechanisms that play into interrupt and exception handling, recall the four steps to interrupt and exception handling we introduced at the beginning of this section.
These can now be filled with more details:
\begin{enumerate}
    \item If an interrupt or exception is pending, determine the privilege mode to take the trap by checking the targeted privilege mode and any delegation settings
    \item If an interrupt is pending, check that interrupts are enabled globally and the specific interrupt is enabled as well
    \item Take the trap by jumping to to trap base vector and if an interrupt is being serviced take vectoring into account
    \item Return from trap handler
\end{enumerate}

The differences between handling exceptions and interrupts can be summarized by the following:
\begin{itemize}
    \item Exception can't be disabled therefore they will always be handled
    \item $ x\text{cause}[31] $ is written with $ 0 $
    \item Exceptions can't be vectored therefore the \gls{pc} will always be set to $ x\text{tvec} $
\end{itemize}

One would need to alter figure \ref{fig:interrupt-handling} by replacing most interrupt-related \glspl{csr} with their exception-related counterpart if possible.
An exception to this is $ x\text{status}.x\text{IE} $ which still is set to 0 meaning that it is not possible to preempt handling an exception by handling an interrupt.

Finally, note that exceptions are handled as soon as they occur.
This is necessary as exceptions always are closely related to the current stream of instructions and therefore need attention before said stream can continue to be executed.
The only exception to this are other interrupts which are handled before any exception with the following decreasing order of priority: external interrupts, software interrupts, timer interrupts, exceptions.
% Source: https://stackoverflow.com/a/56402079/7194995
\gls{riscv} knows no concept of settings exceptions pending, this however, isn't necessary.
If an exception occurs while an interrupt is set pending, the interrupt can be handled with \gls{mepc} being set to the address of the faulting instruction which either will again fault after the interrupt has been handled or will succeed by some magical condition in which case it does need any further attention.

% TODO: Mention what I didn't mention; e.g. specific parts of mstatus

\subsubsection{Memory Attributes}
\label{sec:memory-attrs}

In the previous paragraph, we mentioned that \gls{mstatus} contains some bits that are not directly relevant to trap handling.
Alongside these bits we will introduce another \gls{csr} that is related to trap handling but not directly necessary in this section.

These two remaining fields of \gls{mstatus} deal with memory privilege translation for machine-mode.
Firstly, there is the MPRV bit which can translate memory access privilege.
This bit is only available if at least two privilege modes are supported otherwise it is hardwired to zero.
If MPRV is set to one, \textcquote{RiscVISAP}{load and store memory addresses are translated and protected as though the current privilege mode were set to MPP}, i.e. they're performed with the privilege level that has was preempted by taking the trap.
Secondly, there is the MXR field that allows to read executable memory regions.
If MXR is not set, attempting to read from a memory region marked as executable will fail.
If MXR is set, such reads can succeed if said region is also marked as readable.
% TODO: is page-based virtual memory given?
MXR is only applicable though, if page-based virtual memory is in place.

The last register we will introduce is the \gls{mscratch} register which can be used by machine-mode to be read and written to for preserving any value the machine-mode would like to see preserved.
The intended use-case for this register by the specification is that \textcquote{RiscVISAP}{it is used to hold a pointer to a machine-mode \gls{hart}-local context space and swapped with a user register upon entry to a \textins{machine}-mode trap handler}.

% TODO: Introduce pma- and pmpcfg

\subsubsection{Other Mechanisms}
\label{sec:other-mechs}

\paragraph{Timer and performance counter \glspl{csr}}
There also is a group of registers dealing with timers and hardware performance monitoring, namely: \gls{mtime}, \gls{mtimecmp}, \gls{mcycle}, \gls{minstret}, \gls{mhpmcountern}, \gls{mhpmeventn} and \gls{mcounteren} but we won't go into detail here as we will be ignoring these registers as well.
The reasoning for skipping these is not as straight-forward as for the previously introduced registers.
In general, timer and performance counting registers can be used for side channel attacks.
In \cite{Qian16} the authors give an overview over timing-side-channel-attacks which by their very nature always need to rely on some notion of time.
This notion can be given by timer and performance counter registers which for example hold the number of instructions executed since a given point in time.
For example, the authors discuss an attack where a side channel to OpenSSL's implementation of \gls{rsa} could be introduced by differentiating between multiplications and squares being performed.
Such a differentiation could be easily done if performance counter registers where to count such instructions and were to leak information to lower privilege levels.
This means that in principle, timer and performance counter registers are relevant for the security of an architecture.
However, we find that they do not introduce new notions of information flow to the architecture and are therefore redundant to our thesis.

It is the case that contents of these registers are confidential as their contents might be used to introduce side-channels to other applications running on the processor.
However, their core mechanisms are not unique.
They can be read and written to and might generate interrupts but this is nothing new to the architecture.
We therefore think that dealing with information flow in general is sufficient for our approach and will ignore these registers.

Besides the interrupts and exceptions that have been introduced in the last few paragraphs, there are two further \textit{exceptional conditions} that can occur in a \gls{hart}.

\paragraph{Reset}
The first of these is the reset.
The specification does not explicitly define how resets are triggered but it is clear that resets must be triggered by hardware at least., e.g. by the push of a button that is on a shared board with the processor.
As the specification gave an exhaustive list of exceptions and interrupts available to the system in table \ref{tbl:interrupt-exception-codes} we assume here that resets can be triggered by hardware only.

On reset, the \gls{pc} is set to an implementation defined address, the privilege mode is set to machine-mode, the MIE and MPRV bits in \gls{mstatus} are set to 0 and \gls{mcause} should be written with implementation-defined values to indicate the cause of the reset.
The specification explicitly mentions that \textcquote{RiscVISAP}{%
    \textins{a}ll other hart state is undefined
} although software located at the reset vector might write \glspl{csr} with arbitrary values.

% Source: https://stackoverflow.com/a/46989066/7194995
Although the specification itself says that the \textcquote{RiscVISAP}{\texttt{pc} is set to an implementation-defined reset vector} and does not lay any constraints on this, we think that this address must not be the same as \gls{mtvec}.
The reason for this is given in a comment to this section where it says:
\begin{displaycquote}{RiscVISAP}
    \texttt{mcause} reset values may alias \texttt{mcause} values following synchronous exceptions.
    There is no ambiguity in this overlap, since on reset the \texttt{pc} is set to a different value than on other traps.
\end{displaycquote}

Although comments should not be taken with the same weight as regular passages of the specification, the intent behind this comment is quite clear and as it only slightly contradicts the specification we will go with this interpretation.

\paragraph{Non-Maskable Interrupts}
The other exceptional condition are \glspl{nmi}.
The specification describes these as: \textcquote{RiscVISAP}{%
    \textins{NMIs} are only used for hardware error conditions, and cause an immediate jump to an implementation-defined NMI vector running in M-mode regardless of the state of a hart's interrupt enable bits.
}
Similar to resets, nothing is said about the mechanisms to trigger \glspl{nmi} in the specification.
For the same reasons given in the paragraph about reset, we will assume that \glspl{nmi} can only be triggered by hardware.

On jump to the \gls{nmi} handler address, \gls{mepc} is written with the next address to be read and executed and \gls{mcause} is written with information about the cause of the \gls{nmi}.
Other \glspl{csr} are left untouched.

% TODO: Summarize
