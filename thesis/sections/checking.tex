\section{Checking}
\label{sec:checking}

In this section we will outline the process of the actual \textit{verification} of the now implemented architecture.
The verification process itself is threefold:
Before any verification can be done, it needs to be clear what shall be verified - not in the sense what the object of verification is but what its goal is, i.e. which properties express the security of the architecture adequately?
This allows the actual verification of these properties as the next step which will lead to first results.
In the case of a real world verification attempt these results hopefully are that the system to be verified is perfectly valid - it is, however, most likely that the majority of properties verified will end up with a negative result.
In this case, the model and/or properties are refined which marks the last step.

Not only will we detail these steps themselves, we will also reflect whether this process of verification is trustworthy by shedding light on the methodology of deriving the concretization of these by now only loosely described steps.
To outline this, we will answer two questions:
How do we phrase properties to verify?
How do we refine the model and/or properties on a verification failure?

\subsection{Verification Process}

\subsubsection{Properties}

In the summary of section \ref{sec:ifc-model} we mentioned that there are some arguments to the information flow semantic functions in $ \I $ that are not used to determine the information flow label of some architectural word.
These induce the first properties we will verify the MINRV8 architecture against.

Firstly, recall the definition of the LOAD and STORE semantics.
The new tracking labels resulting from executing such an instruction solely depend on the labels of the word loaded or stored.
What hasn't been used in the definition of information flow is the label of the target address of the memory operation.
It is intuitive that the address does not influence the label of the information itself.
% TODO: is security a good word?
However, this suggests that the labels of the address of the memory operation might be relevant for the security of architecture as a whole in another.
This leads to the following two properties:
\begin{enumerate}[label=\Roman*.,series=]
    \item \label{itm:prop-mem-i}
    Whenever a memory operation is performed in privileged mode, the target address must be integrous.
    \item \label{itm:prop-mem-c}
    Whenever a confidential word is read from or written to memory in privileged mode, the target address must be confidential.
\end{enumerate}

% TODO: give intuition for both properties

Secondly, recall the definition of the semantics for CSRRS or CSRRC, respectively.
These only propagate information flow tracking labels by assigning the constant labels of the \gls{csr} read to the respectively targeted register.
We decided to model the labels of \glspl{csr} as constants because they control the state of the architecture and as such might be target of an attack.
We labelled all \glspl{csr} as integrous and \gls{mstatus} as confidential.
We decided to not label \gls{pmacfg} or \gls{pmpcfg} as confidential since it can be assumed that user mode must be able to know where memory regions are to operate correctly.
Our architecture does not support virtual addresses, address translation or other similar concepts which might hide details of the memory settings from user mode leaving it without the need to know the details of memory settings.

Coming back to the information flow semantics of CSRRS and CSRRC, notice that in the respective definition of the semantical functions the value the \glspl{csr} are written with is not used.
This must necessarily be the case since the labels of the \glspl{csr} are constant and as such can not change based on the labels of the value to write them with.
However, this leads us to phrase a property about the \gls{csr} labels that ensures their integrity or confidentiality respectively:
\begin{enumerate}[label=\Roman*.,resume]
    \item \label{itm:prop-csr-i}
    Whenever a \gls{csr} is written, the value it is written with must be integrous.
    \item \label{itm:prop-mstatus-c}
    Whenever \gls{mstatus} is written, the value it is written with must be confidential.
\end{enumerate}

From all the variables our implementation of the MINRV8 architecture comprises we now considered \smvinline{regs} and \smvinline{memory} as well as \smvinline{cache} in regards to the security of the architecture by looking at the gaps of the information flow semantic functions.
We also considered the variable \smvinline{csrs} by assigning constant information flow labels to it and using it as an information flow target, i.e. we phrased properties ensuring that certain flows of information \textit{to} \smvinline{csrs} do not occur.
However, up to this point we only implicitly handled the \smvinline{priv} variable which holds the current privilege mode.
It was used as a source of labels since it determines the labels of machine words loaded as immediates by LOADI.

It is reasonable to assume, though, that \smvinline{priv} also can serve as an information flow target; similar to \smvinline{csrs}.
We already did this partially in properties \ref{itm:prop-mem-i}and \ref{itm:prop-mem-c} where we assumed the architecture to be in privileged mode.
These properties, however, only dealt with the integrity labels of information.
The domain of confidentiality has yet been left out so we will introduce one final property for verification that covers the interplay between privilege mode and confidentiality labels:
\begin{enumerate}[label=\Roman*.,resume]
    \item \label{itm:prop-no-leak}
    Whenever the architecture is in user mode, there is no confidential data in any register.
\end{enumerate}

The implementation of these five properties is straight-forward.
Confer code snippets \ref{snpt:prop-mem-i}-\ref{snpt:prop-no-leak} for details.

\begin{smv}[caption={Implementation of property \ref{itm:prop-mem-i}},label={snpt:prop-mem-i}]
LTLSPEC NAME MEMORY_OP_INTEGRITY :=
    assumptions -> G (
        priv & op in { LOAD, STORE }
        -> regs_integrity[rs1] > 0h_03
    );
\end{smv}

\begin{smv}[caption={Implementation of property \ref{itm:prop-mem-c}}]
LTLSPEC NAME MEMORY_OP_CONFIDENTIALITY :=
    assumptions -> G (
        priv & op in { LOAD, STORE }
            & memory_conf[read_addr(rs1)] > 0h_00
        -> regs_conf[rs1] > 0h_03
    );
\end{smv}

\begin{smv}[caption={Implementation of property \ref{itm:prop-csr-i}}]
LTLSPEC NAME CSR_INTEGRITY :=
    assumptions -> G (
        priv & op in { CSRRS, CSRRC }
        -> regs_integrity[rs2] = 0h_FF
    );
\end{smv}

\begin{smv}[caption={Implementation of property \ref{itm:prop-mstatus-c}}]
LTLSPEC NAME MSTATUS_CONFIDENTIALITY :=
    assumptions -> G (
        priv & op in { CSRRS, CSRRC }
        -> regs_conf[rs2] > 0h_0F
    );
\end{smv}

\begin{smv}[caption={Implementation of property \ref{itm:prop-no-leak}},label={snpt:prop-no-leak}]
LTLSPEC NAME NO_LEAK :=
    assumptions -> G (priv | (
        regs_conf[0] = 0h_00
        & regs_conf[1] = 0h_00
        & regs_conf[2] = 0h_00
        & regs_conf[3] = 0h_00
    ));
\end{smv}

\subsubsection{Mitigations \& Refinement}

\begin{figure}
    \centering
    \begin{tikzpicture}[node distance = 1.5cm, auto]
        \node[block] (proofs) {run proofs};
        \node[decision] (failure) [below=of proofs] {is there a failure?};
        \node[block] (inspect) [below=of failure] {inspect counter example};
        \node[decision] (model) [right=of inspect] {is the model correct?};
        \node[block] (fix) [above=of model] {fix the model};
        \node[decision] (cause) [below=of model] {is mitigation possible?};
        \node[block] (architecture) [left=of cause] {refine the architecture};
        \node[block] (rule) [below=of cause] {refine assumptions};

        \path[line] (proofs) -- (failure);
        \path[line] (failure) -- node[near start] {yes} (inspect);
        \path[line,dashed] (failure.west) -- node[near start] {no} ++(left:1.5cm);
        \path[line] (inspect) -- (model);
        \path[line] (model) -- node[near start] {no} (fix);
        \path[line] (fix) |- (proofs);
        \path[line] (model) -- node[near start] {yes} (cause);
        \path[line] (cause) -- node[near start] {yes} (architecture);
        \path[line] (cause) -- node[near start] {no} (rule);
        \path[line] (architecture.west) -| ++(left:1cm) |- (proofs);
        \path[line] (rule.west) -| ($ (architecture.west) + (left:1cm) $);
    \end{tikzpicture}
    \caption{Verification Process Flowchart}
    \label{fig:ver-process}
\end{figure}

\subsection{Trustworthiness of the Verification Process}
