%!TEX root = ../thesis.tex

\section{Related Work}
\label{sec:related-work}

As related work, we will consider seven papers - one of which will be investigated in detail.
Since this work founded itself both on \citetitle{Reid17} \cite{Reid17} and \citetitle{Ferraiuolo17} \cite{Ferraiuolo17} but both papers have been introduced in section \ref{sec:background} extensively, we won't consider them again in this section.
However, we will make an extensive comparison to the paper \citetitle{BradfieldS16} \cite{BradfieldS16} by \citeauthor{BradfieldS16} since this work is closest to ours.

The remaining six papers will be introduced as a group.
All related work covers verification\footnote{%
    It was a deliberate decision to not label all related work as \textit{formal} verification.
    E.g. \cite{Zhang15,SuhLZD04} do verify either properties or live program execution but do not use formal methods to accomplish this.
} of specifications or via information flow properties.
We found that related work can be characterized by four dimensions:
\begin{enumerate}
    \item It has either software or hardware as subject.
    \item It verifies either implementations or specifications.
    \item Verification is performed either live or statically.
    \item Information flow properties are either expressed directly or as non-interference properties.
\end{enumerate}

Given these categories, our work falls into the box of having hardware as subject, verifying a specification statically via direct information flow properties.

Two papers that do not consider hardware verification come from the Massachusetts Institute of Technology.
Firstly, \citeauthor{GordonKPGNR15} presented their tool DroidSafe for static analysis of information flow properties for android applications in their work \citetitle{GordonKPGNR15} \cite{GordonKPGNR15}.
Secondly, \citeauthor{SuhLZD04} proposed an approach to live track information on \gls{os} level tacking traps on security policy violations in \citetitle{SuhLZD04} \cite{SuhLZD04}.
It is quite far-fetched to call \cite{SuhLZD04} a paper about \textit{verification}.
Nonetheless, the approach is interesting and methodologically close to ours.

The authors in \cite{GordonKPGNR15} considered information flow privacy sensitive sources of information, e.g. unique device ID, SMS messages and other private file, to riskful sinks of information, e.g. the network, NFC and the local file system.
Both, sources and sinks, are guarded by the android \gls{api}.
The authors tracked information flow from sensitive sources to sensitives sinks which both are given by specific calls to methods of the android \gls{api}.
DroidSafe managed to detect at least 90\% of malicious information flows in selected benchmarks whilst reporting at most 13 false positives.

The approach in \cite{SuhLZD04} aims to prevent the misuse of programming errors such as buffer overflows or format strings.
As opposed to verifying the absence of such vulnerabilities, the authors track data from sensitive sources through instructions using per-byte bit labels to observe when such vulnerabilities are being targeted by attacker payloads from such sources.
As opposed to \cite{GordonKPGNR15}, where information was tracked from the \enquote{user} to the \enquote{outside world}, the flow of information here is the other way round: from the \enquote{outside world} to the \enquote{user}.
This is due to the fact that \cite{GordonKPGNR15} considered the domain of confidentiality and \cite{SuhLZD04} considered the domain of integrity when tracking information.
Additionally, this in in line with our work where we information flow properties regarding confidentiality stated that confidential data may not flow to user-mode (the \enquote{outside world}) and malicious data from user-mode may not flow to sensitive places in machine-mode (the \enquote{user} in this analogy).
Similarly to our work, the authors here also gave information flow semantics for each instruction available.
The authors proposed a simple security policy involving two rules:
\begin{displaycquote}{SuhLZD04}
    \textit{No instruction can be generated from I/O inputs}, and \textit{No I/O inputs and spurious values based on propagated inputs can be used as pointers unless they are bound-checked and added to an authentic pointer}.
\end{displaycquote}

Whereas the first can not be compared to the properties of this work meaningfully as executable memory is not modelled, the second comes remarkably close to the properties integrity property \ref{itm:prop-mem-i} which (in words of the authors of \cite{SuhLZD04}) states that no \enquote{spurios} value can be used as pointer.
The exception of bound-checks is implicitly modelled by the \smv{SAN_ON_*} assumptions in section \ref{sec:results} which mandate from machine-mode to sanitize register of spurious values before using them.
Such a sanitization might be implemented by boundary-checking.
% TODO: Double check whether this actually is true
Recall that the security lattice continues to track data as malicious only if both sources of an operation are malicious.
For example, comparing a value to a constant bound, loaded from trusted memory would set it to be trustworthy.

The approach of \cite{SuhLZD04} achieved a 100\% success rate in a benchmark and the authors claim that their approach has negligible performance impact.

These two papers were those related to software.
The other five papers are all related to hardware.
\citeauthor{Zhang15} considered the detection of hardware trojans in \citetitle{Zhang15} \cite{Zhang15}, i.e. parts of an integrated circuit that behave maliciously, can be activated by very few inputs and otherwise do not affect the functionality of the circuit.
They analyzed \gls{hdl} implementations of such integrated circuits searching for (mostly) unused parts in the design.
The techniques employed in this work do not come close to what has been used in this thesis.
However, one can view the detection of (mostly) unused parts of a design and information flow tracking as two sides of the same coin: whereas here, we strived for finding out where information can flow, the authors in \cite{Zhang15} aim for finding out where information (mostly) does not flow.

\citeauthor{Fox02} formally verified the \gls{arm} architecture by redundancy in \citetitle{Fox02} \cite{Fox02}.
% TODO: \gls{hol}
He implemented a formal model of the \gls{arm} architecture in the theorem prover HOL, using general first order logic for verification.
In this implementation, \citeauthor{Fox02} modelled two views on the \gls{arm} architecture: the \gls{isa} itself and the micro-architecture implementing this \gls{isa}.
\citeauthor{Fox02} used theorems expressing that there always must be some correspondence between runs of the \gls{isa}-world and runs of the micro-architecture-world.
If for a given list of instructions or a giving list of steps in the micro-architecture, no corresponding run of the opposite world can be found, the architecture itself must be flawed.
This work was picked up by \citeauthor{KhakpourSD13} in \citetitle{KhakpourSD13} \cite{KhakpourSD13}.
The authors of this work extended the implementation of \citeauthor{Fox02} proving three isolation properties of user- and machine-mode:
User-mode processes must only depend on process-accessible-resources, processes must only modify those memory regions they can access by a given MMU configuration and user-mode-processes must only execute code by calling machine-mode through a trap.
The first of these is a non-interference property.
In general, non-interference properties state that a given system (in this case: user-mode-processes) must not be influenced by certain values (in this case: non-user-mode-process accessible resources).
They are generally stated in the following form: whenever two initial states of the system agree on a list of selected values, the respective final states must also agree on these values.
This is an indirect way of expressing information flow properties.
As opposed to formalize: \enquote{information from source $ X $ must not flow to sink $ T $}, directly, non-interference properties state that \enquote{information from any illegitimate source must not flow to any sink}, hence must not be able to interfere computation.

In contrast to the work of this thesis, \citeauthor{KhakpourSD13} achieve to distinguish between multiple user-mode processes and in this way tackle a more broad problem.
In our work, we only considered the scenario of user-mode attacking machine-mode and not user-mode attacking different user-mode processes.
% TODO: mention in future work
It would be an interesting line of research to add an MMU to the model and extend the information flow properties accordingly.

On the other hand, \citeauthor{KhakpourSD13} do not give any sense for what these properties actually achieve when it comes to security.
It is not clear what kind of bugs concretely might be tackled by their properties; whilst they are intuitive and certainly should be met by the \gls{arm} architecture, it is unclear whether they actually guarantee any desirable characteristics of the architecture.
To some extent, these properties fall out of nowhere.
Whilst this critique to some extent also applies to our work, we think that the methodology of deriving the information flow properties as presented in section \ref{sec:checking} gives some sense of completeness to our properties which is missing from the work of \citeauthor{KhakpourSD13}.

Lastly, we consider the work of \citeauthor{Nienhuis19} in \citetitle{Nienhuis19} \cite{Nienhuis19}.
% TODO: \gls{cheri}
This work comes from a completely other direction: as opposed to verifying information flow properties in some existing architecture, the authors present a new architecture, CHERI, that guard memory accesses by \textit{capabilities}.
These capabilities allow processes to perform given actions on a given range of memory, specified per virtual address.
The development of CHERI was accompanied by formal methods and proofs to enhance the trust in this system.
The CHERI architecture is an attempt to equip an architecture with strong mechanisms of controlling information flow such that the trust in it is very high from the beginning, supported by formal proofs that certain desirable properties hold for this architecture.

\begin{table}
    \centering
    \begin{tabular}{| r | c c | c c | c c | c c |}
        \hline
        & \multicolumn{2}{c |}{Subject} & \multicolumn{2}{c |}{Level} & \multicolumn{2}{c |}{Context} & \multicolumn{2}{c |}{Information Flow} \\
        & SW & HW & Impl. & Spec. & Live & Static & Direct & Non-I. \\
        \cite{GordonKPGNR15} & \checkmark & & \checkmark & & & \checkmark & \checkmark & \\
        \hline
        \cite{SuhLZD04} & \checkmark & & \checkmark & & \checkmark & & \checkmark & \\
        \hline
        \cite{Zhang15} & & \checkmark & \checkmark & & & \checkmark & (\checkmark) & \\
        \hline
        \cite{Fox02} & & \checkmark & & \checkmark & & \checkmark & \multicolumn{2}{c |}{N/A} \\
        \hline
        \cite{KhakpourSD13} & & \checkmark & \checkmark & & & \checkmark & & \checkmark \\
        \hline
        \cite{Nienhuis19} & & \checkmark & & \checkmark & & \checkmark &\multicolumn{2}{c |}{N/A} \\
        \hline
        \cite{BradfieldS16} & & \checkmark & & \checkmark & & \checkmark & \multicolumn{2}{c |}{N/A} \\
        \hline
    \end{tabular}
\end{table}
