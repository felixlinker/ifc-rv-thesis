%!TEX root = ../thesis.tex

\section{Related Work}
\label{sec:related-work}

As related work, we will consider seven papers - one of which will be investigated in detail.
Since this work founded itself both on \citetitle{Reid17} \cite{Reid17} and \citetitle{Ferraiuolo17} \cite{Ferraiuolo17} but both papers have been introduced in section \ref{sec:background} extensively, we won't consider them again in this section.
However, we will make an extensive comparison to the paper \citetitle{BradfieldS16} \cite{BradfieldS16} by \citeauthor{BradfieldS16} since this work is closest to ours.

The remaining six papers will be introduced as a group.
All related work covers verification\footnote{%
    It was a deliberate decision to not label all related work as \textit{formal} verification.
    E.g. \cite{Zhang15,SuhLZD04} do verify either properties or live program execution but do not use formal methods to accomplish this.
} of specifications or via information flow properties.
We found that related work can be characterized by four dimensions:
\begin{enumerate}
    \item It has either software or hardware as subject.
    \item It verifies either implementations or specifications.
    \item Verification is performed either live or statically.
    \item Information flow properties are either expressed directly or as non-interference properties.
\end{enumerate}

Given these categories, our work falls into the box of having hardware as subject, verifying a specification statically via direct information flow properties.

Two papers that do not consider hardware verification come from the Massachusetts Institute of Technology.
Firstly, \citeauthor{GordonKPGNR15} presented their tool DroidSafe for static analysis of information flow properties for android applications in their work \citetitle{GordonKPGNR15} \cite{GordonKPGNR15}.
Secondly, \citeauthor{SuhLZD04} proposed an approach to live track information on \gls{os} level tacking traps on security policy violations in \citetitle{SuhLZD04} \cite{SuhLZD04}.
It is quite far-fetched to call \cite{SuhLZD04} a paper about \textit{verification}.
Nonetheless, the approach is interesting and methodologically close to ours.

The authors in \cite{GordonKPGNR15} considered information flow privacy sensitive sources of information, e.g. unique device ID, SMS messages and other private file, to riskful sinks of information, e.g. the network, NFC and the local file system.
Both, sources and sinks, are guarded by the android \gls{api}.
The authors tracked information flow from sensitive sources to sensitives sinks which both are given by specific calls to methods of the android \gls{api}.
DroidSafe managed to detect at least 90\% of malicious information flows in selected benchmarks whilst reporting at most 13 false positives.

The approach in \cite{SuhLZD04} aims to prevent the misuse of programming errors such as buffer overflows or format strings.
As opposed to verifying the absence of such vulnerabilities, the authors track data from sensitive sources through instructions using per-byte bit labels to observe when such vulnerabilities are being targeted by attacker payloads from such sources.
As opposed to \cite{GordonKPGNR15}, where information was tracked from the \enquote{user} to the \enquote{outside world}, the flow of information here is the other way round: from the \enquote{outside world} to the \enquote{user}.
This is due to the fact that \cite{GordonKPGNR15} considered the domain of confidentiality and \cite{SuhLZD04} considered the domain of integrity when tracking information.
Additionally, this in in line with our work where we information flow properties regarding confidentiality stated that confidential data may not flow to user-mode (the \enquote{outside world}) and malicious data from user-mode may not flow to sensitive places in machine-mode (the \enquote{user} in this analogy).
Similarly to our work, the authors here also gave information flow semantics for each instruction available.
The authors proposed a simple security policy involving two rules:
\begin{displaycquote}{SuhLZD04}
    \textit{No instruction can be generated from I/O inputs}, and \textit{No I/O inputs and spurious values based on propagated inputs can be used as pointers unless they are bound-checked and added to an authentic pointer}.
\end{displaycquote}

Whereas the first can not be compared to the properties of this work meaningfully as executable memory is not modelled, the second comes remarkably close to the properties integrity property \ref{itm:prop-mem-i} which (in words of the authors of \cite{SuhLZD04}) states that no \enquote{spurios} value can be used as pointer.
The exception of bound-checks is implicitly modelled by the \smv{SAN_ON_*} assumptions in section \ref{sec:results} which mandate from machine-mode to sanitize register of spurious values before using them.
Such a sanitization might be implemented by boundary-checking.
% TODO: Double check whether this actually is true
Recall that the security lattice continues to track data as malicious only if both sources of an operation are malicious.
For example, comparing a value to a constant bound, loaded from trusted memory would set it to be trustworthy.

The approach of \cite{SuhLZD04} achieved a 100\% success rate in a benchmark and the authors claim that their approach has negligible performance impact.

These two papers were those related to software.
The other five papers are all related to hardware.
\citeauthor{Zhang15} considered the detection of hardware trojans in \citetitle{Zhang15} \cite{Zhang15}, i.e. parts of an integrated circuit that behave maliciously, can be activated by very few inputs and otherwise do not affect the functionality of the circuit.
They analyzed \gls{hdl} implementations of such integrated circuits searching for (mostly) unused parts in the design.
The techniques employed in this work do not come close to what has been used in this thesis.
However, one can view the detection of (mostly) unused parts of a design and information flow tracking as two sides of the same coin: whereas here, we strived for finding out where information can flow, the authors in \cite{Zhang15} aim for finding out where information (mostly) does not flow.

\citeauthor{Fox02} formally verified the \gls{arm} architecture by redundancy in \citetitle{Fox02} \cite{Fox02}.
% TODO: \gls{hol}
He implemented a formal model of the \gls{arm} architecture in the theorem prover HOL, using general first order logic for verification.
In this implementation, \citeauthor{Fox02} modelled two views on the \gls{arm} architecture: the \gls{isa} itself and the micro-architecture implementing this \gls{isa}.
\citeauthor{Fox02} used theorems expressing that there always must be some correspondence between runs of the \gls{isa}-world and runs of the micro-architecture-world.
If for a given list of instructions or a giving list of steps in the micro-architecture, no corresponding run of the opposite world can be found, the architecture itself must be flawed.
This work was picked up by \citeauthor{KhakpourSD13} in \citetitle{KhakpourSD13} \cite{KhakpourSD13}.
The authors of this work extended the implementation of \citeauthor{Fox02} proving three isolation properties of user- and machine-mode:
User-mode processes must only depend on process-accessible-resources, processes must only modify those memory regions they can access by a given MMU configuration and user-mode-processes must only execute code by calling machine-mode through a trap.
The first of these is a non-interference property.
In general, non-interference properties state that a given system (in this case: user-mode-processes) must not be influenced by certain values (in this case: non-user-mode-process accessible resources).
They are generally stated in the following form: whenever two initial states of the system agree on a list of selected values, the respective final states must also agree on these values.
This is an indirect way of expressing information flow properties.
As opposed to formalize: \enquote{information from source $ X $ must not flow to sink $ T $}, directly, non-interference properties state that \enquote{information from any illegitimate source must not flow to any sink}, hence must not be able to interfere computation.

In contrast to the work of this thesis, \citeauthor{KhakpourSD13} achieve to distinguish between multiple user-mode processes and in this way tackle a more broad problem.
In our work, we only considered the scenario of user-mode attacking machine-mode and not user-mode attacking different user-mode processes.
% TODO: mention in future work
It would be an interesting line of research to add an MMU to the model and extend the information flow properties accordingly.

On the other hand, \citeauthor{KhakpourSD13} do not give any sense for what these properties actually achieve when it comes to security.
It is not clear what kind of bugs concretely might be tackled by their properties; whilst they are intuitive and certainly should be met by the \gls{arm} architecture, it is unclear whether they actually guarantee any desirable characteristics of the architecture.
To some extent, these properties fall out of nowhere.
Whilst this critique to some extent also applies to our work, we think that the methodology of deriving the information flow properties as presented in section \ref{sec:checking} gives some sense of completeness to our properties which is missing from the work of \citeauthor{KhakpourSD13}.

Lastly, we consider the work of \citeauthor{Nienhuis19} in \citetitle{Nienhuis19} \cite{Nienhuis19}.
% TODO: \gls{cheri}
This work comes from a completely other direction: as opposed to verifying information flow properties in some existing architecture, the authors present a new architecture, CHERI, that guard memory accesses by \textit{capabilities}.
These capabilities allow processes to perform given actions on a given range of memory, specified per virtual address.
The development of CHERI was accompanied by formal methods and proofs to enhance the trust in this system.
The CHERI architecture is an attempt to equip an architecture with strong mechanisms of controlling information flow such that the trust in it is very high from the beginning, supported by formal proofs that certain desirable properties hold for this architecture.

\subsection{Model Checking Instruction Set Architectures}

The work of \citeauthor{BradfieldS16} in \citetitle{BradfieldS16} \cite{BradfieldS16} comes closest to what has been attempted in this thesis.
On the high level, \citeauthor{BradfieldS16} also attempt to verify an \gls{isa} and also use model checking to do so.
However, they do not use higher level properties or information flow tracking to achieve this.
Coincidentally, the authors focus on the SYSRET vulnerability to the x86 architecture.
Their goal is to prove the absence of SYSRET-like vulnerabilities which is expressed as the property: never can the processor be in privileged mode when at the same time the stack pointer, base pointer or instruction pointer are controlled by user-mode.

In their methodology, the authors first identify a group of vulnerable instructions which might lead to such a state by being interrupted.
They then modelled these instructions alongside with all state touched by these instructions.
By sparsely constraining the initial state of the model they finally prove: for all initial states, there is no direct successor state where a general protection fault has been thrown and one of the stack, base or instruction pointers is controlled by user-mode.
The authors claim that by the constraints chosen for the initial states of the model, these states actually embody an over-approximation of all reachable states of the x86 architecture.
With this methodology, the authors managed to find that Intel's version of the x86 architecture is vulnerable to the SYSRET vulnerability while AMD's version is not.

On the one hand, we find it to be unfair to compare this work on all aspects to ours since the work of \citeauthor{BradfieldS16} clearly does not have the same scope as ours.
On the other hand, we find that the work in \cite{BradfieldS16} is lacking in two, key aspects.
First and foremost, the problem of a circular argument in verification as discussed in section \ref{sec:trustworthiness} fully applies to this work.
The authors actually didn't use the model checker to verify the x86 architecture but to simulate the SYSRET vulnerability: they restricted their model to instructions of which they knew these were relevant to the SYSRET vulnerability or at least highly related to instructions affected by the SYSRET vulnerability with no clear reasons for why others were excluded or not included and they specifically encoded the gist of the SYSRET vulnerability in the property to be verified\footnote{%
    With the property's encoding, the authors miss the original intent of the work: to verify the absence of SYSRET-\textit{like} vulnerabilities.
    By only considering general protection fault, a potentially huge class of other vulnerabilities is ruled out by assumption.
}.

This poses a big problem for a generalization of this work.
Whilst it might be an adequate showcase for instances of problems where model checking might be helpful, their work only shows how to check that an architecture is \textit{specifically} not susceptible to the SYSRET vulnerability.

Secondly, the property proposed by \citeauthor{BradfieldS16} is not in line with Intel's x86 specification (cf. \cite{Dunlap19}).
The purpose of the SYSENTER and SYSEXIT instructions \textit{is} to execute privileged code with the stack pointer being controlled by user-mode to reduce the overhead of the mode transition.
This means, that taking a general protection fault while handling a call to machine-mode via SYSENTER, leaving the general protection fault handler with a stack pointer controlled by user-mode is intended behavior.
This might be badly designed behavior - but it works as specified.
In practice, operating systems opted to ensure that no general protection fault could occur when executing the SYSRET instruction but to verify Intel's x86 architecture to not be susceptible to the SYSRET vulnerability asks from it to violate the specification.

In contrast, regarding the first issue, in our work we not only proposed more general properties that were not rooted in specific vulnerabilities but in a structured model of information flow and also would apply to other architectures with few adjustments required, we also took clear and justifiable steps when minimizing the \gls{riscv} architecture such that it would be feasible to verify it in scope of this thesis.
Regarding the second issue of verifying the x86 architecture to not meet the specification, in our work we took a more moderate approach of verifying mitigations to the SYSRET vulnerability.
Instead of proving the absence of the SYSRET vulnerability, we opted to prove that the mitigation of disabling interrupts when executing the SYSRET instruction is effective (cf. snippet \ref{snpt:sp-safety}, sec. \ref{sec:sysret}).

\subsection{Summary}

We considered seven papers as related work.
Find an overview of all papers in table \ref{tbl:related-work}.
Each column classifies related work in regard to the categories introduced at the beginning of this section: the subject of verification is software/hardware and an implementation/specification, verification is performed live/statically and information flow properties are expressed directly or as non-interference properties (if at all).

The work coming closest to our methodology of verification via information flow control considered software and was \cite{GordonKPGNR15,SuhLZD04}.
The work coming closest to our goal of verifying specifications against higher level properties was \cite{Fox02,KhakpourSD13,BradfieldS16}.
Additionally, the work of \cite{SuhLZD04,KhakpourSD13} motivates to augment our model by an implementation of an MMU to prove isolation properties on user-process level.

\begin{table}
    \centering
    \begin{tabular}{| r | c c | c c | c c | c c |}
        \hline
        & \multicolumn{2}{c |}{Subject} & \multicolumn{2}{c |}{Level} & \multicolumn{2}{c |}{Context} & \multicolumn{2}{c |}{Information Flow} \\
        & SW & HW & Impl. & Spec. & Live & Static & Direct & Non-I. \\
        \cite{GordonKPGNR15} & \checkmark & & \checkmark & & & \checkmark & \checkmark & \\
        \hline
        \cite{SuhLZD04} & \checkmark & & \checkmark & & \checkmark & & \checkmark & \\
        \hline
        \cite{Zhang15} & & \checkmark & \checkmark & & & \checkmark & (\checkmark) & \\
        \hline
        \cite{Fox02} & & \checkmark & & \checkmark & & \checkmark & \multicolumn{2}{c |}{N/A} \\
        \hline
        \cite{KhakpourSD13} & & \checkmark & \checkmark & & & \checkmark & & \checkmark \\
        \hline
        \cite{Nienhuis19} & & \checkmark & & \checkmark & & \checkmark &\multicolumn{2}{c |}{N/A} \\
        \hline
        \cite{BradfieldS16} & & \checkmark & & \checkmark & & \checkmark & \multicolumn{2}{c |}{N/A} \\
        \hline
    \end{tabular}
    \caption{An overview of related work}
    \label{tbl:related-work}
\end{table}
