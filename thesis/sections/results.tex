%!TEX root = ../thesis.tex

\section{Results}

This section will cover the results of the verification process as it was described in section \ref{sec:checking}.
The main finding was that there are 8 assumptions which in total grant that the properties as described in section \ref{sec:props} can not be violated, in other words: the MINRV8 architecture models the information flow properties introduced in this thesis, namely \smv{MEMORY_OP_INTEGRITY}, \smv{CSR_INTEGRITY} and \smv{NO_LEAK}, if and only if we assume the 8 assumptions that will be introduced in subsequent sections.

Additionally, roughly 19 bug fix patches\footnote{%
    The number of 19 bug fix patches was measured by counting the amount of patches containing the word \enquote{fix} in its description and being applied to the model file.
} were applied to the model.
Taken together with aforementioned assumptions these changes to the model mark a fixpoint of the verification process as depicted in figure \ref{fig:ver-process}.

This section is grouped as follows: section \ref{sec:assumptions} will introduce aforementioned assumptions that have been added to the model during the verification process.
Section \ref{sec:alt-approaches} will discuss the approach to finding and phrasing said assumptions and investigate possible alternative approaches to ensuring that all the architecture models the information flow properties.

Since only assumptions and no architectural refinements were introduced to the model, it was also tested how the model would behave when deliberate breaking points were introduced to it.
These breaking points tried to mimic known vulnerabilities to real-world architectures and will therefore also give an overview of the capabilities of the verification approach of this thesis.
The results to these tests will finally be presented in section \ref{sec:canaries}.

\subsection{Assumptions}
\label{sec:assumptions}

The 8 assumptions that have been introduced throughout the verification process can be grouped into three categories:
\begin{itemize}
    \item Mode-boundary crossing related assumptions
    \item Memory related assumptions
    \item Memory privilege related assumptions
\end{itemize}

Find an overview of all these assumptions in table \ref{tbl:assumptions-overview}.
Each row represents one assumption and each column one property.
A check mark denotes that the respective assumption is critical for the respective property, i.e. there exists a counter-example proving the property to be false if the assumption at hand is not assumed.
Note that each of the assumptions is critical for at least one property.
This stresses that \enquote{$ \text{assumptions} \Leftrightarrow \text{properties} $} as opposed to \enquote{$ \text{assumptions} \Rightarrow \text{properties} $} since \enquote{$ \neg \text{assumptions} \Rightarrow \neg \text{properties} $}.

\begin{table}
    \centering
    \begin{tabular}{| c r | c | c | c |}
        \multicolumn{1}{r}{} & \multicolumn{1}{r}{} &
        \multicolumn{1}{l}{\tilthdr{\smv{MEMORY_OP_INTEGRITY} (\ref{itm:prop-mem-i})}} &
        \multicolumn{1}{l}{\tilthdr{\smv{CSR_INTEGRITY} (\ref{itm:prop-csr-i})}} &
        \multicolumn{1}{l}{\tilthdr{\smv{NO_LEAK} (\ref{itm:prop-no-leak})}} \\
        \hline % \cline{3-5}
        \multirow{2}{*}{Mode-boundary} & \smv{SAN_ON_CALL} & \checkmark & \checkmark & \\
        \cline{3-5}
        & \smv{CLR_ON_RET} &&& \checkmark \\
        \hline % \cline{3-5}
        \multirow{2}{*}{Memory} & \smv{NO_PUBLIC_READS} & \checkmark & \checkmark & \\
        \cline{3-5}
        & \smv{NO_PUBLIC_WRITES} &&& \checkmark \\
        \hline % \cline{3-5}
        \multirow{4}{*}{Memory privilege} & \smv{SAN_ON_CLASSIFICATION} & \checkmark & \checkmark & \\
        \cline{3-5}
        & \smv{CLR_ON_DECLASSIFICATION} &&& \checkmark \\
        \cline{3-5}
        & \smv{SAN_CACHE_ON_CLASSIFICATION} & \checkmark & \checkmark & \\
        \cline{3-5}
        & \smv{CLR_CACHE_ON_DECLASSIFICATION} &&& \checkmark \\
        \hline % \cline{3-5}
    \end{tabular}
    \caption{Assumptions Compared to Properties}
    \label{tbl:assumptions-overview}
\end{table}

\paragraph{Mode-boundary crossing related assumptions}
The first assumption to be introduced is called \smv{CLR_ON_RET} and mandates from machine-mode to always clear the registers of confidential information when returning control to user-mode.
For the sake of simplicity the instruction \minrv{Clr} (\textit{clear}) was added to the model.
This instruction simply changes the confidentiality labels of all register to \textit{public}, i.e. \minrv{0}.
It is meant to allow machine-mode to deliberately make the decision of evaluating all registers contents and clearing whatever is confidential.
Therefore, the \minrv{CLR} instruction simulates a routine that might be executed on real-world implementations of code managing a platform.
The \smv{CLR_ON_RET} assumption mandates from machine-mode to always execute the \minrv{Clr} instruction before privilege mode changes from machine- to user-mode.
The formal implementation of \smv{CLR_ON_RET} is given in snippet \ref{snpt:clr-on-ret}.

\begin{figure}
    \begin{lstlisting}[
        language=smv,
        caption={Assumption \lstinline{SAN_ON_CALL}},
        label={snpt:san-on-call}
    ]
        G (!priv & X priv -> X op = SAN)
    \end{lstlisting}

    \begin{lstlisting}[
        language=smv,
        caption={Assumption \smv{CLR_ON_RET}},
        label={snpt:clr-on-ret}
    ]
        G (priv & X !priv -> Y op = CLR)
    \end{lstlisting}
\end{figure}

A counter-example stressing the relevance of this assumption can be found in table \ref{tbl:cex-no-leak-cor}.
The format of this table will be used frequently throughout this thesis to illustrate counter-examples.
Each row of the table represents an instruction being executed and the changes in result of this instruction with the exception of the first row which depicts the processor's initial state.
Whenever labels do not change, the values do not change as well.
Furthermore, the table is separated in three main columns: The first column shows the instructions being executed.
In case of table \ref{tbl:cex-no-leak-cor}, two instructions were executed both of which are the \minrv{Mret} instruction.

The second group of columns hold the information flow labels for the registers and memory on a per-word basis.
During the verification process it was found that no counter-example required information flow labels of a per-bit granularity.
Therefore, for the sake of simplicity, the information flow labels of machine-words in memory or registers were combined to a single label.
The two inner rows in the cells of the second major column denote the labels of the registers (\minrv{r}) and memory (\minrv{m}) respectively whereas the inner columns mark the index of the labels, e.g. in table \ref{tbl:cex-no-leak-cor} all registers are labelled with \CT{} whereas all of the memory is labelled with \CU{} in the initial state.

The third major column shows the status of the processor.
This column is separated into five inner columns as well.
The first (labelled with \minrv{p}) shows the privilege mode of execution where \minrv{U} stands for user-mode and \minrv{M} stands for machine-mode.
The other four columns show the current memory settings per region.
Inner columns starting with \minrv{0} give the settings for first memory region and starting with \minrv{1} for the second memory region respectively.
Inner columns ending with \minrv{c} hold the cacheability settings.
Here, \minrv{UN} stands for uncacheable, \minrv{WB} for write-back-cacheable, \minrv{WT} for write-through-cacheable and \minrv{WP} for write-protected-cacheable (cf. section \ref{sec:minrv8}).
Inner columns ending with \minrv{p} hold the memory privilege settings for the respective region.
Memory privilege settings are indicated by a string of the form:
\begin{grammar}
    <privelege-string> ::= (`-' | `L') (`-' | `R') (`-' | `W')
\end{grammar}

The first letter in the privilege string denotes whether the region is locked (\minrv{L}) or not (\minrv{-}), the second whether user-mode can read the region (\minrv{R}) or not (\minrv{-}) and the third whether user mode can write to the region (\minrv{W}) or not (\minrv{-}).
In table \ref{tbl:cex-no-leak-cor}, none of the regions is locked and user mode can write to both regions but can only read region 1.

Traces generated by nuXmv must be infinitely long but finitely representable.
This means that each trace includes a loop.
In this setting, counter-examples generated by nuXmv always violated the property at hand after having executed the second last instruction whereas the last instruction introduced the loop and led to a fixpoint in the state-space.
For the sake of completeness, the last instruction of counter-example traces will be included nonetheless.

To fully understand the counter-example to the \smv{NO_LEAK} (cf. \ref{sec:props}, \ref{itm:prop-no-leak}) property recall that it says: Never can the processor be in user-mode and there is some confidential data in some register.
Table \ref{tbl:cex-no-leak-cor} illustrates a counter-example since machine-mode directly hands over confidential data to user-mode by returning control to user-mode without clearing its registers.
This clearly is a problem that can never be mitigated by architectural measures since the architecture has no way to tell whether data is confidential.
This led to the addition of the assumption \smv{CLR_ON_RET} (cf. snippet \ref{snpt:clr-on-ret}) being added to the model which demands exactly that.

The next assumption to be introduced is similar to \smv{CLR_ON_RET}.
\smv{SAN_ON_CALL} demands from machine-mode to clear the registers from any untrusted data before continuing to use their contents when entering machine-mode from user-mode.
To allow this, another abstract instruction was added to the model: \minrv{San}, which stands for \textit{sanitize}.
When this instruction is executed, the integrity labels of all registers are set to \textit{trusted}, i.e. \minrv{1}.
The formal implementation of \smv{SAN_ON_CALL} can be found in snippet \ref{snpt:san-on-call}.

Without assuming \smv{SAN_ON_CALL} nuXmv manages to find two counter-examples.
One for property \smv{CSR_INTEGRITY} (\ref{itm:prop-csr-i}) and one for \smv{MEMORY_OP_INTEGRITY} (\ref{itm:prop-mem-i}).
The traces for both counter-examples are depicted in tables \ref{tbl:cex-csr-i-soc} and \ref{tbl:cex-mem-i-soc} respectively.
Note that both traces are very similar.
In both traces, the processor starts in user-mode with some untrusted data in the registers.
User-mode then calls machine-mode which decides to use the contents of the registers without sanitization to either write a \gls{csr} or to memory.

\begin{table}
    \begin{subtable}{\textwidth}
        \centering
        \input{../results/SANITIZE-ON-CALL/MEMORY-OP-INTEGRITY.tex}
        \caption{\smv{MEMORY_OP_INTEGRITY} (\ref{itm:prop-mem-i})}
        \label{tbl:cex-mem-i-soc}
    \end{subtable}

    \begin{subtable}{\textwidth}
        \centering
        \input{../results/SANITIZE-ON-CALL/CSR-INTEGRITY.tex}
        \caption{\smv{CSR_INTEGRITY} (\ref{itm:prop-csr-i})}
        \label{tbl:cex-csr-i-soc}
    \end{subtable}

    \begin{subtable}{\textwidth}
        \centering
        \input{../results/CLEAR-ON-RET/NO-LEAK.tex}
        \caption{\smv{NO_LEAK} (\ref{itm:prop-no-leak})}
        \label{tbl:cex-no-leak-cor}
    \end{subtable}
    \caption{Counter-examples for \smv{SAN_ON_CALL} and \smv{CLR_ON_RET}}
\end{table}

It has already been touched that both assumptions \smv{CLR_ON_RET} (cf. snippet \ref{snpt:clr-on-ret}) and \smv{SAN_ON_CALL} (cf. snippet \ref{snpt:san-on-call}) are similar to each other.
This relation characterizes a pattern that can be recognized for other groups of assumptions.
It turned out that for every confidentiality related assumption such as \smv{CLR_ON_RET}, there was a similar integrity related assumption such as \smv{SAN_ON_CALL}.
This can be easily seen in table \ref{tbl:assumptions-overview} where in alternating rows, two groups of assumptions can be distinguished those which are relevant to the \smv{NO_LEAK} property and those which are relevant to the \smv{MEMORY_OP_INTEGRITY} and \smv{CSR_INTEGRITY} property.
Additionally it is noteworthy that these two groups of assumptions can be characterized by the way they constrain information flow.
Whereas confidentiality related assumptions always constrain flow of information going \textit{out} of machine-mode, integrity related assumptions always constrain flow of information going \textit{in} machine-mode.

\paragraph{Memory related assumptions}
Two assumptions about memory reads and writes join the ranks of these groups, namely \smv{NO_PUBLIC_WRITES} and \smv{NO_PUBLIC_READS} which are formally given in snippet \ref{snpt:no-public-writes} and \ref{snpt:no-public-reads} respectively.
These two assumptions don't express more than the title says; they require machine-mode to never read from or write to public memory.

\begin{figure}
    \begin{lstlisting}[
        language=smv,
        caption={Assumption \lstinline{NO_PUBLIC_READS}},
        label={snpt:no-public-reads}
    ]
        G (priv & op = LOAD -> (
            mem_addr < $REGION0_SIZE
                ? !pmpcfg0.write
                : !pmpcfg1.write
        ))
    \end{lstlisting}

    \begin{lstlisting}[
        language=smv,
        caption={Assumption \lstinline{NO_PUBLIC_WRITES}},
        label={snpt:no-public-writes}
    ]
        G (priv & op = STORE -> (
            mem_addr < $REGION0_SIZE
                ? !pmpcfg0.read
                : !pmpcfg1.read
        ))
    \end{lstlisting}
\end{figure}

The three counter-examples involved in this two assumptions are rather straight-forward as well.
If machine-mode is allowed to store arbitrary words into public memory, a simple counter-example to the \smv{NO_LEAK} property (\ref{itm:prop-no-leak}) is that machine-mode simply stores a secret into public memory which is then loaded by user-mode as illustrated by the trace in table \ref{tbl:cex-no-leak-npw}.
On the other hand, if machine-mode is allowed to load arbitrary words from public memory nuXmv gives a counter-example to the properties \smv{CSR_INTEGRITY} (\ref{itm:prop-csr-i}) and \smv{MEMORY_OP_INTEGRITY} (\ref{itm:prop-mem-i}) where all memory is untrusted in the initial state, machine-mode loads some word from memory and uses it to write a \gls{csr} with or as target address.
These counter-examples are illustrated in table \ref{tbl:cex-csr-i-npw} and \ref{tbl:cex-mem-i-npw} respectively.

\begin{table}
    \begin{subtable}{\textwidth}
        \centering
        \input{../results/NO-PUBLIC-WRITES/NO-LEAK.tex}
        \caption{\smv{NO_LEAK} (\ref{itm:prop-no-leak})}
        \label{tbl:cex-no-leak-npw}
    \end{subtable}

    \begin{subtable}{\textwidth}
        \centering
        \input{../results/NO-PUBLIC-READS/CSR-INTEGRITY.tex}
        \caption{\smv{CSR_INTEGRITY} (\ref{itm:prop-csr-i})}
        \label{tbl:cex-csr-i-npw}
    \end{subtable}

    \begin{subtable}{\textwidth}
        \centering
        \input{../results/NO-PUBLIC-READS/MEMORY-OP-INTEGRITY.tex}
        \caption{\smv{MEMORY_OP_INTEGRITY} (\ref{itm:prop-mem-i})}
        \label{tbl:cex-mem-i-npw}
    \end{subtable}
    \caption{Counter-examples for \smv{NO_PUBLIC_WRITES} and \smv{NO_PUBLIC_READS}}
\end{table}

\paragraph{Memory privilege related assumptions}
The four assumptions that have been introduced up to this point seem to cover all relevant media of information transmission: registers and memory.
However, these are not enough to ensure that the MINRV8 architecture implements all information flow properties subject to this thesis.
Whereas the last two memory related properties covered the group of actions by machine-mode where information directly is given to or taken from user-mode, it is also possible to transmit information indirectly via memory by writing it to or reading it from safe memory regions but doing so while changing the attributes of respective memory regions.
The two assumptions \smv{CLR_ON_DECLASSIFICATION} and \smv{SANITIZE_ON_DECLASSIFICATION} express this notion.
The former demands from machine-mode to always ensure that a memory region does not contain confidential information when its made publicly accessible.
This assumption is formalized in snippet \ref{snpt:clr-on-declassify}.
The latter assumption demands from machine-mode to ensure that a memory region does not contain malicious information when its set to be publicly inaccessible.
This assumption is formalized in snippet \ref{snpt:san-on-classify}.

\begin{figure}
    \begin{lstlisting}[
        language=smv,
        caption={Assumption \lstinline{SAN_ON_CLASSIFICATION}},
        label={snpt:san-on-classify}
    ]
        G (pmpcfg0.write & X !pmpcfg0.write
            -> memory_integrity[0] = 0h_FF
             & memory_integrity[1] = 0h_FF)
        & G (pmpcfg1.write & X !pmpcfg1.write
            -> memory_integrity[2] = 0h_FF
             & memory_integrity[3] = 0h_FF)
    \end{lstlisting}

    \begin{lstlisting}[
        language=smv,
        caption={Assumption \lstinline{CLR_ON_DECLASSIFICATION}},
        label={snpt:clr-on-declassify}
    ]
        G (!pmpcfg0.read & X pmpcfg0.read
            -> memory_conf[0] = 0h_00
             & memory_conf[1] = 0h_00)
        & G (!pmpcfg1.read & X pmpcfg1.read
            -> memory_conf[2] = 0h_00
             & memory_conf[3] = 0h_00)
    \end{lstlisting}
\end{figure}

The counter-example given when not assuming \smv{CLR_ON_DECLASSIFICATION} (cf. table \ref{tbl:cex-no-leak-cod}) illustrates exactly what has been given as intuition for this assumption in the introduction of this paragraph.
The architecture starts with some confidential data in the memory of the second memory region which is not publicly readable.
In the first step, machine-mode however sets just that memory to being publicly readable.
Machine-mode does clear its registers before giving control back to user-mode, yet this is irrelevant since user-mode can just load the contents from the now accessible memory region one which violates the \smv{NO_LEAK} property (cf. \ref{itm:prop-no-leak}).

The counter-examples when not assuming \smv{SAN_ON_CLASSIFICATION} for properties \smv{CSR_INTEGRITY} and \smv{MEMORY_OP_INTEGRITY} - as usual - work analogously (cf. tables \ref{tbl:cex-csr-i-socl}, \ref{tbl:cex-mem-i-socl}).
This time, the both memory regions are writable for user-mode to begin with and initially contain untrusted data.
Again, machine-mode changes the privilege settings of one memory region making it non-writable to user-mode and then loads and uses a machine-word which is untrusted violating the respective integrity related property.

\begin{table}
    \begin{subtable}{\textwidth}
        \centering
        \input{../results/CLEAR-ON-DECLASSIFICATION/NO-LEAK.tex}
        \caption{\smv{NO_LEAK} (\ref{itm:prop-no-leak})}
        \label{tbl:cex-no-leak-cod}
    \end{subtable}

    \begin{subtable}{\textwidth}
        \centering
        \input{../results/SANITIZE-ON-CLASSIFICATION/CSR-INTEGRITY.tex}
        \caption{\smv{CSR_INTEGRITY} (\ref{itm:prop-csr-i})}
        \label{tbl:cex-csr-i-socl}
    \end{subtable}

    \begin{subtable}{\textwidth}
        \centering
        \input{../results/SANITIZE-ON-CLASSIFICATION/MEMORY-OP-INTEGRITY.tex}
        \caption{\smv{MEMORY_OP_INTEGRITY} (\ref{itm:prop-mem-i})}
        \label{tbl:cex-mem-i-socl}
    \end{subtable}
    \caption{Counter-examples for \smv{CLR_ON_DECLASSIFICATION} and \smv{SAN_ON_CLASSIFICATION}}
\end{table}

Yet, these two assumptions still not suffice to grant the absence of memory privilege related property counter-examples.
It turns out that only ensuring memory regions to not contain confidential/malicious words when (de-)classifying respective regions allows problematic information to remain in cache and bypasses \smv{CLR_ON_DECLASSIFICATION} and \smv{SAN_ON_CLASSIFICATION}.
This brings the need to also assume that the cache is cleared and sanitized by the architecture whenever a memory region is (de-)classified.
This is expressed in the the assumptions \smv{CLR_CACHE_ON_DECLASSFICATION} and \smv{SAN_ON_CLASSIFICATION} (cf. snippets \ref{snpt:clrc-on-declassify}, \ref{snpt:sanc-on-classify}).

\begin{figure}
    \begin{lstlisting}[
        language=smv,
        caption={Assumption \lstinline{SAN_CACHE_ON_CLASSIFICATION}},
        label={snpt:sanc-on-classify}
    ]
        G (pmpcfg0.write & X !pmpcfg0.write
                & cache.valid & cache.addr < $REGION0_SIZE
            -> cache.integrity = 0h_FF) &
        G (pmpcfg1.write & X !pmpcfg1.write
                & cache.valid & $REGION0_SIZE <= cache.addr
            -> cache.integrity = 0h_FF)
    \end{lstlisting}

    \begin{lstlisting}[
        language=smv,
        caption={Assumption \lstinline{CLR_CACHE_ON_DECLASSIFICATION}},
        label={snpt:clrc-on-declassify}
    ]
        G (!pmpcfg0.read & X pmpcfg0.read
                & cache.valid & cache.addr < $REGION0_SIZE
            -> cache.conf = 0h_00) &
        G (!pmpcfg1.read & X pmpcfg1.read
                & cache.valid & $REGION0_SIZE <= cache.addr
            -> cache.conf = 0h_00)
    \end{lstlisting}
\end{figure}

\begin{table}
    \begin{subtable}{\textwidth}
        \centering
        \input{../results/SANITIZE-CACHE-ON-CLASSIFICATION/MEMORY-OP-INTEGRITY.tex}
        \caption{\smv{MEMORY_OP_INTEGRITY} (\ref{itm:prop-mem-i})}
        \label{tbl:cex-mem-i-scocl}
    \end{subtable}
    \caption{Counter-examples for \smv{CLR_CACHE_ON_DECLASSIFICATION} and \smv{SAN_CACHE_ON_CLASSIFICATION}}
\end{table}

This time around, the counter-examples given by nuXmv are not completely straight forward.
As a start, consider the counter-examples generated when not assuming \smv{SAN_CACHE_ON_DECLASSFICATION} for the \smv{MEMORY_OP_INTEGRITY} property in table \ref{tbl:cex-mem-i-scocl}.
In the first three instructions, machine-mode sets memory region zero to be writable by user-mode which is also set to be write-back-cacheable and hands back control to user-mode.
User-mode generates an untrusted constant by loading an immediate value and stores respective value in memory region zero.
Since this region is set to be write-back-cacheable, the store is not persisted in memory but only reflected in cache.
In the next instruction, control is transferred back to machine-mode again.
Since no \minrv{Ecall} instruction has been executed, an external interrupt must have been set pending in the past which is not being handled.
Machine-mode first clears the inputs from user-mode by executing the \minrv{San} instruction and then prevents write accesses to memory region zero for user-mode which is permitted by the current assumptions since all memory cells of the respective region contain trusted values.
However, when machine-mode then attempts to load a word from said region, an untrusted word is loaded which has only been reflected in cache.
This word is then used as address for a \minrv{Store} instruction violating property \ref{itm:prop-mem-i}.
The counter-example for property \smv{CSR_INTEGRITY} (\ref{itm:prop-csr-i}) depicted in table \ref{tbl:cex-csr-i-scocl} follows the same pattern and therefore will not be handled separately in this context.

The trace generated to prove the \smv{NO_LEAK} property (\ref{itm:prop-no-leak}) is much simpler.
It is given in table \ref{tbl:cex-no-leak-ccod}.
Again, memory region zero is set to be write-back-cacheable.
As a first step, machine-mode set this region to be unreadable for user-mode and then stores some confidential data to it.
This write, however, is only reflected in cache.
Since only \smv{CLR_ON_DECLASSFICATION} is assumed, nothing prevents machine-mode to declassify memory region zero after the write.
Machine-mode gives back control to user-mode which is than able to gain access to the secret by loading it from cache.

\begin{table}
    \ContinuedFloat
    \begin{subtable}{\textwidth}
        \centering
        \input{../results/SANITIZE-CACHE-ON-CLASSIFICATION/CSR-INTEGRITY.tex}
        \caption{\smv{CSR_INTEGRITY} (\ref{itm:prop-csr-i})}
        \label{tbl:cex-csr-i-scocl}
    \end{subtable}
    \caption{Counter-examples for \smv{CLR_CACHE_ON_DECLASSIFICATION} and \smv{SAN_CACHE_ON_CLASSIFICATION} (cont.)}
\end{table}

\begin{table}
    \ContinuedFloat
    \begin{subtable}{\textwidth}
        \centering
        \input{../results/CLEAR-CACHE-ON-DECLASSIFICATION/NO-LEAK.tex}
        \caption{\smv{NO_LEAK} (\ref{itm:prop-no-leak})}
        \label{tbl:cex-no-leak-ccod}
    \end{subtable}
    \caption{Counter-examples for \smv{CLR_CACHE_ON_DECLASSIFICATION} and \smv{SAN_CACHE_ON_CLASSIFICATION} (cont.)}
\end{table}

\subsection{Alternative Approaches}
\label{sec:alt-approaches}

\subsection{Canaries}
\label{sec:canaries}

\subsection{Limitations}
