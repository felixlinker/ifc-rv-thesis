%!TEX root = ../thesis.tex

\section{Results}

This section will cover the results of the verification process as it was described in section \ref{sec:checking}.
The main finding was that there are 8 assumptions which in total grant that the properties as described in section \ref{sec:props} can not be violated, in other words: the MINRV8 architecture models the information flow properties introduced in this thesis, namely \smv{MEMORY_OP_INTEGRITY}, \smv{CSR_INTEGRITY} and \smv{NO_LEAK}, if and only if we assume the 8 assumptions that will be introduced in subsequent sections.

Additionally, roughly 22 bug fix patches\footnote{%
    The number of 22 bug fix patches was measured by counting the amount of patches containing the word \enquote{fix} in its description and being applied to the model file.
} and some \smv{INIT} constraints were applied to the model.
Taken together with aforementioned assumptions these changes to the model mark a fixpoint of the verification process as depicted in figure \ref{fig:ver-process}.

This section is grouped as follows: section \ref{sec:assumptions} will introduce aforementioned assumptions and \smv{INIT} constraints that have been added to the model during the verification process.

Since only assumptions and no architectural refinements were introduced to the model, it was also tested how the model would behave when deliberate breaking points were introduced to it.
These breaking points tried to mimic known vulnerabilities to real-world architectures and will therefore also give an overview of the capabilities of the verification approach of this thesis.
The results to these tests will finally be presented in section \ref{sec:canaries}.

\subsection{Assumptions}
\label{sec:assumptions}

Technically, \smv{INIT} constraints and assumptions serve the same purpose: They limit the state spaces that will be searched for property violations.
Semantically, however, these two concepts should be distinguished in this thesis.
In the model, \smv{INIT} constraints are used to only limit the search of the state space to \textit{valid} counter-examples only.
Validity here means, that properties are not false to begin with and that the initial state of the architecture complies with the specification.

The former aspect of validity is guaranteed by constraining the contents of registers to only contain confidential data when the model starts in machine-mode and to only contain malicious data when the model starts in user-mode.
Furthermore, cache and memory can only contain confidential data if the respective memory region is set to \textit{not} be readable for user-mode and can only contain malicious data if the respective memory region \textit{is} set to be writable by user-mode.
The aforementioned \smv{INIT} constraints simply ensure that the properties to prove are not false upfront.
If, for example, the model would not be constrained to initially only contain confidential data in some register when in machine-mode, nuXmv could find a counter-example violating the \smv{NO_LEAK} property (\ref{itm:prop-no-leak}) where the architecture starts in user-mode and has confidential data in some register trivially violating the respective property.

The latter aspect of validity is guaranteed by two constraints.
The first is rather simple and is depicted in the following snippet:
\begin{lstlisting}[
    language=smv,
    caption={\gls{mstatus} \smv{INIT} constraint for the model}
]
    INIT MIE = 0b_1 -> MPP = 0b_0;
\end{lstlisting}
This constraint ensures that the interrupt handling mechanisms are set up correctly and is mandated by the \gls{riscv} specification (cf. section \ref{sec:rv-exn} and figure \ref{fig:interrupt-handling}).
No other \smv{INIT} constraints are required to set up the initial state of the model correctly and sensibly.
The second constraint sets up caching correctly, i.e. if the cache is valid, it can only point to an address of a region that is cacheable and must match that addresses content unless the respective region is set to be write-back-cacheable.

The 8 assumptions that have been introduced throughout the verification process can be grouped into three categories:
\begin{itemize}
    \item Mode-boundary crossing related assumptions
    \item Memory related assumptions
    \item Memory privilege related assumptions
\end{itemize}

Find an overview of all these assumptions in table \ref{tbl:assumptions-overview}.
Each row represents one assumption and each column one property.
A check mark denotes that the respective assumption is critical for the respective property, i.e. there exists a counter-example proving the property to be false if the assumption at hand is not assumed.
Note that each of the assumptions is critical for at least one property.
This stresses that \enquote{$ \text{assumptions} \Leftrightarrow \text{properties} $} as opposed to \enquote{$ \text{assumptions} \Rightarrow \text{properties} $} since \enquote{$ \neg \text{assumptions} \Rightarrow \neg \text{properties} $}.

\begin{table}
    \centering
    \begin{tabular}{| c r | c | c | c |}
        \multicolumn{1}{r}{} & \multicolumn{1}{r}{} &
        \multicolumn{1}{l}{\tilthdr{\smv{MEMORY_OP_INTEGRITY} (\ref{itm:prop-mem-i})}} &
        \multicolumn{1}{l}{\tilthdr{\smv{CSR_INTEGRITY} (\ref{itm:prop-csr-i})}} &
        \multicolumn{1}{l}{\tilthdr{\smv{NO_LEAK} (\ref{itm:prop-no-leak})}} \\
        \hline % \cline{3-5}
        \multirow{2}{*}{Mode-boundary} & \smv{SAN_ON_CALL} & \checkmark & \checkmark & \\
        \cline{3-5}
        & \smv{CLR_ON_RET} &&& \checkmark \\
        \hline % \cline{3-5}
        \multirow{2}{*}{Memory} & \smv{NO_PUBLIC_READS} & \checkmark & \checkmark & \\
        \cline{3-5}
        & \smv{NO_PUBLIC_WRITES} &&& \checkmark \\
        \hline % \cline{3-5}
        \multirow{4}{*}{Memory privilege} & \smv{SAN_ON_CLASSIFICATION} & \checkmark & \checkmark & \\
        \cline{3-5}
        & \smv{CLR_ON_DECLASSIFICATION} &&& \checkmark \\
        \cline{3-5}
        & \smv{SAN_CACHE_ON_CLASSIFICATION} & \checkmark & \checkmark & \\
        \cline{3-5}
        & \smv{CLR_CACHE_ON_DECLASSIFICATION} &&& \checkmark \\
        \hline % \cline{3-5}
    \end{tabular}
    \caption{Assumptions Compared to Properties}
    \label{tbl:assumptions-overview}
\end{table}

\paragraph{Mode-boundary crossing related assumptions}
The first assumption to be introduced is called \smv{SAN_ON_CALL} and mandates from machine-mode to clear the registers from any untrusted data before continuing to use their contents when entering machine-mode from user-mode.
% TODO: Explain why we had to add this instruction
To allow this, an abstract instruction was added to the model: \minrv{San}, which stands for \textit{sanitize}.
When this instruction is executed, the integrity labels of all registers are set to trusted, i.e. \minrv{1}.
The formal implementation of \smv{SAN_ON_CALL} can be found in snippet \ref{snpt:san-on-call}.

\begin{figure}
    \begin{lstlisting}[
        language=smv,
        caption={Assumption \lstinline{SAN_ON_CALL}},
        label={snpt:san-on-call}
    ]
        G (!priv & X priv -> X op = SAN)
    \end{lstlisting}

    \begin{lstlisting}[
        language=smv,
        caption={Assumption \smv{CLR_ON_RET}},
        label={snpt:clr-on-ret}
    ]
        G (
            priv & X !priv -> regs_conf[0] = 0h_00
                & regs_conf[1] = 0h_00
                & regs_conf[2] = 0h_00
                & regs_conf[3] = 0h_00
        )
    \end{lstlisting}
\end{figure}

Without assuming \smv{SAN_ON_CALL} nuXmv manages to find two counter-examples.
One for property \smv{MEMORY_OP_INTEGRITY} (\ref{itm:prop-mem-i}) and one for \smv{CSR_INTEGRITY} (\ref{itm:prop-csr-i}).
The traces for both counter-examples are depicted in tables \ref{tbl:cex-mem-i-soc} and \ref{tbl:cex-csr-i-soc} respectively.

The format of these tables will be used frequently throughout this thesis to illustrate counter-examples.
To introduce it, table \ref{tbl:cex-mem-i-soc} will be explained in detail now.
Each row of the table represents an instruction being executed and the changes in result of this instruction with the exception of the first row which depicts the processor's initial state.
Whenever a cell is empty, the value represented by it did not change as a result of execution the respective instruction.
Furthermore, the table is separated in three main columns: The first column shows the instructions being executed.
In case of table \ref{tbl:cex-mem-i-soc}, three instructions were executed: \minrv{Ecall}, \minrv{Load} and \minrv{Store}.

The second group of columns hold the information flow labels for the registers and memory on a per-word basis.
During the verification process it was found that no counter-example required information flow labels of a per-bit granularity.
Therefore, for the sake of simplicity, the information flow labels of machine-words in memory or registers were combined to a single label.
The two inner rows in the cells of the second major column denote the labels of the registers (\minrv{r}) and memory (\minrv{m}) respectively whereas the inner columns mark the index of the labels, e.g. in table \ref{tbl:cex-mem-i-soc} all registers and the cells of memory region zero are labelled with \PU{}, i.e. public and untrusted, whereas the cells of memory region one are labelled with \PT{}, i.e. public and trusted, in the initial state.

The third major column shows the status of the processor.
This column is separated into five inner columns as well.
The first (labelled with \minrv{p}) shows the privilege mode of execution where \minrv{U} stands for user-mode and \minrv{M} stands for machine-mode.
The other four columns show the current memory settings per region.
Inner columns starting with \minrv{0} give the settings for first memory region and starting with \minrv{1} for the second memory region respectively.
Inner columns ending with \minrv{c} hold the cacheability settings.
Here, \minrv{UN} stands for uncacheable, \minrv{WB} for write-back-cacheable, \minrv{WT} for write-through-cacheable and \minrv{WP} for write-protected-cacheable (cf. section \ref{sec:minrv8}).
Inner columns ending with \minrv{p} hold the memory privilege settings for the respective region.
Memory privilege settings are indicated by a string of the form:
\begin{grammar}
    <privelege-string> ::= (`-' | `L') (`-' | `R') (`-' | `W')
\end{grammar}

The first letter in the privilege string denotes whether the region is locked (\minrv{L}) or not (\minrv{-}), the second whether user-mode can read the region (\minrv{R}) or not (\minrv{-}) and the third whether user mode can write to the region (\minrv{W}) or not (\minrv{-}).
In table \ref{tbl:cex-mem-i-soc}, none of the regions is locked or cacheable and user mode can write to region zero only and has not further permissions.

Traces generated by nuXmv are infinitely long but finitely representable by including a loop.
In this setting, counter-examples generated by nuXmv always violated the property at hand after having executed the second last instruction whereas the last instruction introduced the loop and led to a fixpoint in the state-space.
For the sake of completeness, the last instruction of counter-example traces will be included nonetheless.

Note that the traces for property \smv{MEMORY_OP_INTEGRITY} in table \ref{tbl:cex-mem-i-soc} and for property \smv{CSR_INTEGRITY} in table \ref{tbl:cex-csr-i-soc} are very similar.
In both traces, the processor starts in user-mode with some untrusted data in the registers.
User-mode then calls machine-mode which decides to use the contents of the registers without sanitization to either write a \gls{csr} or to memory.

The next assumption to be introduced is similar to \smv{SAN_ON_CALL} and is called \smv{CLR_ON_RET}; it says: Whenever machine-mode hands back control to user-mode, the registers must be cleared of any confidential information.
The formal implementation of \smv{CLR_ON_RET} is given in snippet \ref{snpt:clr-on-ret}.
Table \ref{tbl:cex-no-leak-cor} illustrates a counter-example for the \smv{NO_LEAK} (\ref{itm:prop-no-leak}) property when not assuming \smv{CLR_ON_RET} since machine-mode directly hands over confidential data to user-mode by returning control to user-mode without clearing its registers.

\begin{table}
    \begin{subtable}{\textwidth}
        \centering
        \input{../results/SANITIZE-ON-CALL/MEMORY-OP-INTEGRITY.tex}
        \caption{\smv{MEMORY_OP_INTEGRITY} (\ref{itm:prop-mem-i})}
        \label{tbl:cex-mem-i-soc}
    \end{subtable}

    \begin{subtable}{\textwidth}
        \centering
        \input{../results/SANITIZE-ON-CALL/CSR-INTEGRITY.tex}
        \caption{\smv{CSR_INTEGRITY} (\ref{itm:prop-csr-i})}
        \label{tbl:cex-csr-i-soc}
    \end{subtable}

    \begin{subtable}{\textwidth}
        \centering
        \input{../results/CLEAR-ON-RET/NO-LEAK.tex}
        \caption{\smv{NO_LEAK} (\ref{itm:prop-no-leak})}
        \label{tbl:cex-no-leak-cor}
    \end{subtable}
    \caption{Counter-examples for \smv{SAN_ON_CALL} and \smv{CLR_ON_RET}}
\end{table}

It has already been touched that both assumptions \smv{SAN_ON_CALL} (cf. snippet \ref{snpt:san-on-call}) and \smv{CLR_ON_RET} (cf. snippet \ref{snpt:clr-on-ret}) are similar to each other.
Both were introduced under the label of being \textit{mode-boundary crossing related}, which means that both assumptions are about information flow tracking labels when changing privilege mode - more precisely both are about the labels of register contents.
The relation of these two assumptions, however, also characterizes a pattern that can be recognized for other groups of assumptions as well.
It turned out that for every integrity related assumption such as \smv{SAN_ON_CALL}, there was a similar confidentiality related assumption such as \smv{CLR_ON_RET}.
This can be easily seen in table \ref{tbl:assumptions-overview} where in alternating rows, two groups of assumptions can be distinguished those which are relevant to the properties \smv{MEMORY_OP_INTEGRITY} and \smv{CSR_INTEGRITY} and those which are relevant to the property \smv{NO_LEAK}.
Additionally it is noteworthy that these two groups of assumptions can be characterized by the way they constrain information flow.
Whereas confidentiality related assumptions always constrain flow of information going \textit{out of} machine-mode, integrity related assumptions always constrain flow of information going \textit{into} machine-mode.

\paragraph{Memory related assumptions}
Two assumptions about memory reads and writes join the ranks of these groups, namely \smv{NO_PUBLIC_READS} and \smv{NO_PUBLIC_WRITES} which are formally given in snippet \ref{snpt:no-public-reads} and \ref{snpt:no-public-writes} respectively.
These two assumptions don't express more than the title says; they require machine-mode to never read from or write to public memory.

\begin{figure}
    \begin{lstlisting}[
        language=smv,
        caption={Assumption \lstinline{NO_PUBLIC_READS}},
        label={snpt:no-public-reads}
    ]
        G (priv & op = LOAD -> (
            mem_addr < $REGION0_SIZE
                ? !pmpcfg0.write
                : !pmpcfg1.write
        ))
    \end{lstlisting}

    \begin{lstlisting}[
        language=smv,
        caption={Assumption \lstinline{NO_PUBLIC_WRITES}},
        label={snpt:no-public-writes}
    ]
        G (priv & op = STORE -> (
            mem_addr < $REGION0_SIZE
                ? !pmpcfg0.read
                : !pmpcfg1.read
        ))
    \end{lstlisting}
\end{figure}

The three counter-examples involved in this two assumptions are rather straight-forward as well.
If machine-mode is allowed to load arbitrary words from public memory nuXmv gives a counter-example to the properties \smv{MEMORY_OP_INTEGRITY} (\ref{itm:prop-mem-i}) and \smv{CSR_INTEGRITY} (\ref{itm:prop-csr-i}) where some or all memory is untrusted in the initial state, machine-mode in the next step decides to load some word from an untrusted source in memory and then uses that as target address of a \minrv{Store} instruction or to write a \gls{csr} with.
These counter-examples are illustrated in table \ref{tbl:cex-mem-i-npw} and \ref{tbl:cex-csr-i-npw} respectively.
On the other hand, if machine-mode is allowed to store arbitrary words into public memory, a simple counter-example to the \smv{NO_LEAK} property (\ref{itm:prop-no-leak}) is that machine-mode simply stores a secret into public memory which is then loaded by user-mode as illustrated by the trace in table \ref{tbl:cex-no-leak-npw}.

Additionally, in this counter-example the consequences of assuming \minrv{CLR_ON_RET} can be seen.
Machine-mode tries to hide secrets from user-mode by writing a public value into register zero before returning which is mandated by aforementioned assumption.
Yet, as shown in the last paragraph, this assumption taken alone, does not ensure the absence of \smv{NO_LEAK} related counter-examples.

\begin{table}
    \begin{subtable}{\textwidth}
        \centering
        \input{../results/NO-PUBLIC-READS/MEMORY-OP-INTEGRITY.tex}
        \caption{\smv{MEMORY_OP_INTEGRITY} (\ref{itm:prop-mem-i})}
        \label{tbl:cex-mem-i-npw}
    \end{subtable}

    \begin{subtable}{\textwidth}
        \centering
        \input{../results/NO-PUBLIC-READS/CSR-INTEGRITY.tex}
        \caption{\smv{CSR_INTEGRITY} (\ref{itm:prop-csr-i})}
        \label{tbl:cex-csr-i-npw}
    \end{subtable}

    \begin{subtable}{\textwidth}
        \centering
        \input{../results/NO-PUBLIC-WRITES/NO-LEAK.tex}
        \caption{\smv{NO_LEAK} (\ref{itm:prop-no-leak})}
        \label{tbl:cex-no-leak-npw}
    \end{subtable}
    \caption{Counter-examples for \smv{NO_PUBLIC_WRITES} and \smv{NO_PUBLIC_READS}}
\end{table}

\paragraph{Memory privilege related assumptions}
The four assumptions that have been introduced up to this point seem to cover all relevant channels of information transmission: registers and memory.
However, these are not enough to ensure that the MINRV8 architecture implements all information flow properties subject to this thesis.
Whereas the two memory related properties covered the group of actions by machine-mode where information directly is given to or taken from user-mode, it is also possible to transmit information indirectly via memory by writing it to or reading it from safe memory regions but doing so while changing the attributes of respective memory regions.
The two assumptions \smv{SANITIZE_ON_DECLASSIFICATION} and \smv{CLR_ON_DECLASSIFICATION} counter issues arising from these vectors.
The former assumption demands from machine-mode to ensure that a memory region does not contain malicious information when its set to be publicly inaccessible.
This assumption is formalized in snippet \ref{snpt:san-on-classify}.
The latter demands from machine-mode to always ensure that a memory region does not contain confidential information when its made publicly accessible.
This assumption is formalized in snippet \ref{snpt:clr-on-declassify}.

\begin{figure}
    \begin{lstlisting}[
        language=smv,
        caption={Assumption \lstinline{SAN_ON_CLASSIFICATION}},
        label={snpt:san-on-classify}
    ]
        G (pmpcfg0.write & X !pmpcfg0.write
            -> memory_integrity[0] = 0h_FF
             & memory_integrity[1] = 0h_FF)
        & G (pmpcfg1.write & X !pmpcfg1.write
            -> memory_integrity[2] = 0h_FF
             & memory_integrity[3] = 0h_FF)
    \end{lstlisting}

    \begin{lstlisting}[
        language=smv,
        caption={Assumption \lstinline{CLR_ON_DECLASSIFICATION}},
        label={snpt:clr-on-declassify}
    ]
        G (!pmpcfg0.read & X pmpcfg0.read
            -> memory_conf[0] = 0h_00
             & memory_conf[1] = 0h_00)
        & G (!pmpcfg1.read & X pmpcfg1.read
            -> memory_conf[2] = 0h_00
             & memory_conf[3] = 0h_00)
    \end{lstlisting}
\end{figure}

The counter-examples when not assuming \smv{SAN_ON_CLASSIFICATION} for properties \smv{MEMORY_OP_INTEGRITY} and \smv{CSR_INTEGRITY} (cf. tables \ref{tbl:cex-csr-i-socl}, \ref{tbl:cex-mem-i-socl}) - as usual - work analogously and illustrate exactly what has been given as intuition for this assumption in the introduction of this paragraph.
In each counter-example, at least one memory region initially is writable for user-mode and contains untrusted data.
Machine-mode changes the privilege settings of that memory region making it non-writable to user-mode and then loads and uses a machine-word which is untrusted violating the respective integrity related property.

The counter-example given when not assuming \smv{CLR_ON_DECLASSIFICATION} is given in table \ref{tbl:cex-no-leak-cod}.
The architecture starts with some confidential data in the memory of the first memory region which is not publicly readable.
In the first step, machine-mode however sets just that memory to being publicly readable.
Machine-mode does clear its registers before giving control back to user-mode, yet this is irrelevant since user-mode can just load the contents from the now accessible memory region one which violates the \smv{NO_LEAK} property (cf. \ref{itm:prop-no-leak}).

\begin{table}
    \begin{subtable}{\textwidth}
        \centering
        \input{../results/SANITIZE-ON-CLASSIFICATION/MEMORY-OP-INTEGRITY.tex}
        \caption{\smv{MEMORY_OP_INTEGRITY} (\ref{itm:prop-mem-i})}
        \label{tbl:cex-mem-i-socl}
    \end{subtable}

    \begin{subtable}{\textwidth}
        \centering
        \input{../results/SANITIZE-ON-CLASSIFICATION/CSR-INTEGRITY.tex}
        \caption{\smv{CSR_INTEGRITY} (\ref{itm:prop-csr-i})}
        \label{tbl:cex-csr-i-socl}
    \end{subtable}

    \begin{subtable}{\textwidth}
        \centering
        \input{../results/CLEAR-ON-DECLASSIFICATION/NO-LEAK.tex}
        \caption{\smv{NO_LEAK} (\ref{itm:prop-no-leak})}
        \label{tbl:cex-no-leak-cod}
    \end{subtable}
    \caption{Counter-examples for \smv{CLR_ON_DECLASSIFICATION} and \smv{SAN_ON_CLASSIFICATION}}
\end{table}

Yet, these two assumptions still not suffice to grant the absence of memory privilege related property counter-examples.
It turns out that only ensuring memory regions to not contain confidential/malicious words when (de-)classifying respective regions allows problematic data to remain in cache which bypasses \smv{SAN_ON_CLASSIFICATION} and \smv{CLR_ON_DECLASSIFICATION}.
This brings the need to also assume that the cache is cleared and sanitized by the architecture whenever a memory region is (de-)classified.
This is expressed in the assumptions \smv{SAN_CACHE_ON_CLASSIFICATION} and \smv{CLR_CACHE_ON_DECLASSFICATION} (cf. snippets \ref{snpt:sanc-on-classify}, \ref{snpt:clrc-on-declassify}).

\begin{figure}
    \begin{lstlisting}[
        language=smv,
        caption={Assumption \lstinline{SAN_CACHE_ON_CLASSIFICATION}},
        label={snpt:sanc-on-classify}
    ]
        G (pmpcfg0.write & X !pmpcfg0.write
                & cache.valid & cache.addr < $REGION0_SIZE
            -> cache.integrity = 0h_FF) &
        G (pmpcfg1.write & X !pmpcfg1.write
                & cache.valid & $REGION0_SIZE <= cache.addr
            -> cache.integrity = 0h_FF)
    \end{lstlisting}

    \begin{lstlisting}[
        language=smv,
        caption={Assumption \lstinline{CLR_CACHE_ON_DECLASSIFICATION}},
        label={snpt:clrc-on-declassify}
    ]
        G (!pmpcfg0.read & X pmpcfg0.read
                & cache.valid & cache.addr < $REGION0_SIZE
            -> cache.conf = 0h_00) &
        G (!pmpcfg1.read & X pmpcfg1.read
                & cache.valid & $REGION0_SIZE <= cache.addr
            -> cache.conf = 0h_00)
    \end{lstlisting}
\end{figure}

This time around, the counter-examples given by nuXmv are not completely straight forward.
As a start, consider the counter-examples generated when not assuming \smv{SAN_CACHE_ON_DECLASSFICATION} for the \smv{MEMORY_OP_INTEGRITY} property in table \ref{tbl:cex-mem-i-scocl}.
In the first instruction, machine-mode sets memory region one to be inaccessible by user-mode which does not violate assumption \minrv{SAN_ON_CLASSIFICATION} since all memory provides trusted values.
In the next instruction, machine-mode decides to load a word from memory which happens to be untrusted.
This must come from cache since no other memory cell matches this label.
This is only possible because memory region one is set to be write-back-cacheable where writes not necessarily must be reflect in memory.
This word is then used as address for a \minrv{Load} instruction violating property \ref{itm:prop-mem-i}.
The counter-example for property \smv{CSR_INTEGRITY} (\ref{itm:prop-csr-i}) depicted in table \ref{tbl:cex-csr-i-scocl} follows the same pattern and therefore will not be handled separately in this context.

The trace generated to prove the \smv{NO_LEAK} property (\ref{itm:prop-no-leak}) wrong when not assuming \minrv{CLR_CACHE_ON_DECLASSIFICATION} flips the integrity related counter-examples.
It is given in table \ref{tbl:cex-no-leak-ccod}.
Here, memory region zero is set to be write-back-cacheable.
This time though, machine-mode declassifies it in the first instruction as opposed to the previous counter-examples where the respective region was being classified.
Machine-mode then gives back control to user-mode which performs a load.
Again, a mysterious confidential word appears in register three which must have come from the cache of memory region one since only this region is accessible to user-mode.

\begin{table}
    \begin{subtable}{\textwidth}
        \centering
        \input{../results/SANITIZE-CACHE-ON-CLASSIFICATION/MEMORY-OP-INTEGRITY.tex}
        \caption{\smv{MEMORY_OP_INTEGRITY} (\ref{itm:prop-mem-i})}
        \label{tbl:cex-mem-i-scocl}
    \end{subtable}

    \begin{subtable}{\textwidth}
        \centering
        \input{../results/SANITIZE-CACHE-ON-CLASSIFICATION/CSR-INTEGRITY.tex}
        \caption{\smv{CSR_INTEGRITY} (\ref{itm:prop-csr-i})}
        \label{tbl:cex-csr-i-scocl}
    \end{subtable}

    \begin{subtable}{\textwidth}
        \centering
        \input{../results/CLEAR-CACHE-ON-DECLASSIFICATION/NO-LEAK.tex}
        \caption{\smv{NO_LEAK} (\ref{itm:prop-no-leak})}
        \label{tbl:cex-no-leak-ccod}
    \end{subtable}
    \caption{Counter-examples for \smv{CLR_CACHE_ON_DECLASSIFICATION} and \smv{SAN_CACHE_ON_CLASSIFICATION}}
\end{table}

\subsection{Canaries}
\label{sec:canaries}

% TODO: Introduce Intel x86 architecture
In this section, it will be presented how the model of the MINRV8 architecture was altered in order to implement real-world attacks to the Intel x86 architecture.
By default, the MINRV8 architecture was not vulnerable to these attacks, however, making the architecture vulnerable will put the approach of this thesis to formally verify an instruction set architecture to a test.

\subsubsection{Cache Poisoning Attack on x86}

The - as it will be called here - cache poisoning attack was discovered and presented by Rafal Wojtczuk and Joanna Rutkowska in their publication \textit{Attacking SMM Memory via Intel\textsuperscript{\textregistered} CPU Cache Poisoning} \cite{Wojtczuk09}.
The term \enquote{SMM memory} refers to a specific region of memory that is designed to be only accessible by the mode of highest privilege in x86 architectures: System Management Mode.
This memory should be written only on start-up and then locked down for later write-accesses.
Wojtczuk and Rutkowska, however, managed to find a vulnerability to the x86 architecture which allowed them to effectively write to SMM memory without SMM privileges by marking respective memory region as write-back-cacheable.
The attack comprises the following steps and requires administrator privileges on the machine to be attacked:
\begin{enumerate}
    \item Mark SMM memory as write-back-cacheable using administrator privileges
    \item \label{itm:cache-pois-mem}
    Generate write accesses to the memory.
    Since the region is marked as write-back-cacheable, the writes will not be propagated to the memory controller which would drop these accesses but will be cached.
    \item \label{itm:cache-pois-smi}
    Trigger an System Management Interrupt to transfer control to System Management Mode.
    Depending on the specific addresses written System Management Mode will now execute code written with administrator privileges.
\end{enumerate}

Steps \ref{itm:cache-pois-mem} and \ref{itm:cache-pois-smi} can also be swapped.
If instead of a write access the cache is read in this case, this attack vector can then be utilized to read SMM memory.

This attack does not fully apply to the MINRV8 architecture since it does not support as fine grained privilege modes.
However, the basic idea can still be implemented if the following changes are made to the model:
\begin{itemize}
    \item For all cache transition relations, do not check whether current privilege mode suffices for the memory operation at hand
    \item For load accesses to memory, do not check whether current privilege mode suffices for the memory read if the address is being cached
\end{itemize}

These changes manage to introduce a vulnerability to the MINRV8 architecture.
If assuming all assumptions introduced in section \ref{sec:assumptions}, nuXmv manages to find a counter-example for all three information flow properties.
These are depicted in table \ref{tbl:cex-cache-vuln}.
As usual, the traces for \smv{MEMORY_OP_INTEGRITY} (\ref{itm:prop-mem-i}) and \smv{CSR_INTEGRITY} (\ref{itm:prop-csr-i}) as depicted in tables \ref{tbl:cex-mem-i-cache-vuln} and \ref{tbl:cex-csr-i-cache-vuln} are highly similar.
In both cases, the user-mode initially executes a \minrv{Store} instruction which is not reflected in memory.
The changes are written to cache-only and therefore must target memory region one since this is set to be write-back cacheable.
Here, it can be clearly seen that dropping memory privilege controls on cache-writes and -reads leads to certain states which are inconsistent with the MINRV8 specification since memory region one is locked and as neither the read- nor the write- bit is set, both user- and machine-mode should not be able to read from or write to memory region one.
Yet, the cache-access succeeds.

In the next step, a pending external interrupt is taken which leads to the transition to machine-mode.
Machine-mode sanitizes the input registers and performs a load instruction targeting the same address as the user's store instruction.
Which leads to an untrusted value being stored in register two.
This value is then used to perform a load or store operation.
In the case of the original cache-poisoning attack, the authors wrote to executable memory directly influencing what would be executed by System Management Mode.
Since the MINRV8 model does not support a model of executable memory, it is not possible to implement this exact vulnerability.
However, these counter-examples show that it is still possible to implement the very core of the cache poisoning attack into the MINRV8 model which leads to a similar vulnerability in the architecture.

This carries over to the counter-example for property \smv{NO_LEAK} (\ref{itm:prop-no-leak}) which is depicted in table \ref{tbl:cex-no-leak-cache-vuln}.
This counter-example more closely matches the alternative version of the cache-poisoning attack used for reading SMM memory.
nuXmv sets the initial state up such that the cache holds some confidential data for one of the memory regions which both are set to be write-back-cacheable and non-readable to user-mode.
Yet still, user-mode can gain access to the confidential word in cache as no access controls are performed when reading from cache.

One distinction from the original cache-poisoning attack to these counter-examples is that here the attacker does need need to set the attacked memory region to be cacheable in the first place.
This difference does not play a major role since the attack can take place nonetheless if some memory region happens to be locked down to user-mode and is set to be write-back-cacheable, still this weakens the attack to some degree.

What can be done to mitigate this attack?
Obviously, the vulnerability purposefully introduced to the architecture could be dropped.
It is not clear, though, how realistic this characteristic of the MINRV8 architecture is since at least in the case of the x86 architecture, the findings of \cite{Wojtczuk09} suggest that is not possible for the hardware to perform privilege checks when writing to the cache.
Therefore this vulnerability stresses a weakness of the model as implemented in this thesis.
Since the MINRV8 architecture only knows two privilege modes, the problem of setting potentially \enquote{interesting} regions of memory to be cacheable for an attack does not come into play.
If, however, three or more privilege modes were given the question would arise which of the non-user-modes should be able to set caching methods for memory regions.
If for example the supervisor-mode of \gls{riscv} also was part of the MINRV8 architecture and additionally would be allowed to write \gls{pmacfg} registers, a possible attack vector to gain access to machine-mode would be to first gain access to supervisor-mode and then set memory regions of interest to be write-back-cacheable.

One possible approach to this would be to extend the MINRV8 architecture by said supervisor-mode and to test how architectural measures could mitigate this vulnerability, if for hardware-reasons, the platform could not check privileges for cache accesses.

\begin{table}
    \begin{subtable}{\textwidth}
        \centering
        \input{../results/CACHE-VULN/MEMORY-OP-INTEGRITY.tex}
        \caption{\smv{MEMORY_OP_INTEGRITY} (\ref{itm:prop-mem-i})}
        \label{tbl:cex-mem-i-cache-vuln}
    \end{subtable}

    \begin{subtable}{\textwidth}
        \centering
        \input{../results/CACHE-VULN/CSR-INTEGRITY.tex}
        \caption{\smv{CSR_INTEGRITY} (\ref{itm:prop-csr-i})}
        \label{tbl:cex-csr-i-cache-vuln}
    \end{subtable}

    \begin{subtable}{\textwidth}
        \centering
        \input{../results/CACHE-VULN/NO-LEAK.tex}
        \caption{\smv{NO_LEAK} (\ref{itm:prop-no-leak})}
        \label{tbl:cex-no-leak-cache-vuln}
    \end{subtable}
    \caption{Counter-examples for the Cache Vulnerability}
    \label{tbl:cex-cache-vuln}
\end{table}

\subsection{Limitations}
