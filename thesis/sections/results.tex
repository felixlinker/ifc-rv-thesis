%!TEX root = ../thesis.tex

\section{Results}

For the model as it was described in section \ref{sec:model-implementation} a fixpoint of the verification process as depicted in figure \ref{fig:ver-process} was reached after introducing 8 assumptions in total and applying roughly 19 bug fix patches\footnote{%
    A patch was considered to be a bug fix if it contained the word \enquote{fix} in its description and was applied to the model file.
} to the model.
After applying these changes to the model all of the properties were proven successfully.
In the next section these 8 assumptions will be presented each of which comes with at least one counter-example stressing the assumption's necessity.

Since only assumptions and no architectural refinements were introduced to the model, it was also tested how the model would behave when deliberate breaking points were introduced to it.
These breaking points tried to mimic known vulnerabilities to real-world architectures and will therefore also give an overview of the capabilities of the verification approach of this thesis.
The results to these tests will be presented in section \ref{sec:canaries}.

\subsection{Properties}

As already mentioned, 8 assumptions have been introduced throughout the verification process.
Find an overview of all these assumptions in table \ref{tbl:assumptions-overview}.
Each row represents one assumption and each column one property.
A check mark denotes that the respective assumption is critical for the respective property, i.e. there exists a counter-example proving the property to be false if the given assumption is not assumed.

\begin{table}
    \centering
    \begin{tabular}{ r | c | c | c |}
        \multicolumn{1}{r}{} &
        \multicolumn{1}{l}{\tilthdr{\smv{MEMORY_OP_INTEGRITY} (\ref{itm:prop-mem-i})}} &
        \multicolumn{1}{l}{\tilthdr{\smv{CSR_INTEGRITY} (\ref{itm:prop-csr-i})}} &
        \multicolumn{1}{l}{\tilthdr{\smv{NO_LEAK} (\ref{itm:prop-no-leak})}} \\
        \cline{2-4}
        \smv{CLEAR_ON_RET} &&& \checkmark \\
        \cline{2-4}
        \smv{SANITIZE_ON_CALL} & \checkmark & \checkmark & \\
        \cline{2-4}
        \smv{NO_PUBLIC_WRITES} &&& \checkmark \\
        \cline{2-4}
        \smv{NO_PUBLIC_READS} & \checkmark & \checkmark & \\
        \cline{2-4}
        \smv{CLEAR_ON_DECLASSIFICATION} &&& \checkmark \\
        \cline{2-4}
        \smv{SANITIZE_ON_CLASSIFICATION} & \checkmark & \checkmark & \\
        \cline{2-4}
        \smv{CLEAR_CACHE_ON_DECLASSIFICATION} &&& \checkmark \\
        \cline{2-4}
        \smv{SANITIZE_CACHE_ON_CLASSIFICATION} & \checkmark & \checkmark & \\
        \cline{2-4}
    \end{tabular}
    \caption{Assumptions Compared to Properties}
    \label{tbl:assumptions-overview}
\end{table}

\paragraph{Clear registers on return to user-mode}
The first assumption that was introduced to the model is called \smv{CLEAR_ON_RET} and mandates from machine-mode to always clear the registers of confidential information when returning control to user-mode.
For the sake of simplicity the instruction \minrv{Clr} (\textit{clear}) was added to the model.
This instruction simply changes the confidentiality labels of all register to \textit{public}, i.e. \minrv{0}.
It is meant to allow machine-mode to deliberately make the decision of evaluating all registers contents and clearing whatever is confidential.
Therefore, the \minrv{CLR} instruction simulates a routine that might be executed on real-world implementations of code managing a platform.
The \smv{CLEAR_ON_RET} assumption mandates from machine-mode to always execute the \minrv{Clr} instruction before privilege mode changes from machine- to user-mode.
The formal implementation of \smv{CLEAR_ON_RET} is given in snippet \ref{snpt:clr-on-ret}.

\begin{figure}
    \begin{lstlisting}[
        language=smv,
        caption={Assumption \smv{CLEAR_ON_RET}},
        label={snpt:clr-on-ret}
    ]
        G (priv & X !priv -> Y op = CLR)
    \end{lstlisting}
\end{figure}

A counter-example stressing the relevance of this assumption can be found in table \ref{tbl:cex-no-leak-cor}.
The format of this table will be used frequently throughout this thesis to illustrate counter-examples.
Each row of the table represents an instruction being executed and the changes in result of this instruction with the exception of the first row which depicts the processor's initial state.
Whenever labels do not change, the values do not change as well.
Furthermore, the table is separated in three main columns: The first column shows the instructions being executed.
In case of table \ref{tbl:cex-no-leak-cor}, two instructions were executed both of which are the \minrv{Mret} instruction.

The second group of columns hold the information flow labels for the registers and memory on a per-word basis.
During the verification process it was found that no counter-example required information flow labels of a per-bit granularity.
Therefore, for the sake of simplicity, the information flow labels of machine-words in memory or registers were combined to a single label.
The two inner rows in the cells of the second major column denote the labels of the registers (\minrv{r}) and memory (\minrv{m}) respectively whereas the inner columns mark the index of the labels, e.g. in table \ref{tbl:cex-no-leak-cor} all registers are labelled with \CT{} whereas all of the memory is labelled with \CU{} in the initial state.

The third major column shows the status of the processor.
This column is separated into five inner columns as well.
The first (labelled with \minrv{p}) shows the privilege mode of execution where \minrv{U} stands for user-mode and \minrv{M} stands for machine-mode.
The other four columns show the current memory settings per region.
Inner columns starting with \minrv{0} give the settings for first memory region and starting with \minrv{1} for the second memory region respectively.
Inner columns ending with \minrv{c} hold the cacheability settings.
Here, \minrv{UN} stands for uncacheable, \minrv{WB} for write-back-cacheable, \minrv{WT} for write-through-cacheable and \minrv{WP} for write-protected-cacheable (cf. section \ref{sec:minrv8}).
Inner columns ending with \minrv{p} hold the memory privilege settings for the respective region.
Memory privilege settings are indicated by a string of the form:
\begin{grammar}
    <privelege-string> ::= (`-' | `L') (`-' | `R') (`-' | `W')
\end{grammar}

The first letter in the privilege string denotes whether the region is locked (\minrv{L}) or not (\minrv{-}), the second whether user-mode can read the region (\minrv{R}) or not (\minrv{-}) and the third whether user mode can write to the region (\minrv{W}) or not (\minrv{-}).
In table \ref{tbl:cex-no-leak-cor}, none of the regions is locked and user mode can write to both regions but can only read region 1.

Traces generated by nuXmv must be infinitely long but finitely representable.
This means that each trace includes a loop.
In this setting, counter-examples generated by nuXmv always violated the property at hand after having executed the second last instruction whereas the last instruction introduced the loop and led to a fixpoint in the state-space.
For the sake of completeness, the last instruction of counter-example traces will be included nonetheless.

To fully understand the counter-example to the \smv{NO_LEAK} (cf. \ref{sec:props}, \ref{itm:prop-no-leak}) property recall that it says: Never can the processor be in user-mode and there is some confidential data in some register.
Table \ref{tbl:cex-no-leak-cor} illustrates a counter-example since machine-mode directly hands over confidential data to user-mode by returning control to user-mode without clearing its registers.
This clearly is a problem that can never be mitigated by architectural measures since the architecture has no way to tell whether data is confidential.
This led to the addition of the assumption \smv{CLEAR_ON_RET} (cf. snippet \ref{snpt:clr-on-ret}) being added to the model which demands exactly that.

\begin{table}
    \centering
    \input{../results/CLEAR-ON-RET/NO-LEAK.tex}
    \caption{\smv{CLEAR_ON_RET} counter-example for \smv{NO_LEAK} (\ref{itm:prop-no-leak})}
    \label{tbl:cex-no-leak-cor}
\end{table}

\paragraph{Sanitize registers on calling machine-mode}
The next assumption to be introduced is similar to \smv{CLEAR_ON_RET}.
\smv{SANITIZE_ON_CALL} demands from machine-mode to clear the registers from any untrusted data before continuing to use their contents when entering machine-mode from user-mode.
To allow this, another abstract instruction was added to the model: \minrv{San}, which stands for \textit{sanitize}.
When this instruction is executed, the integrity labels of all registers are set to \textit{trusted}, i.e. \minrv{1}.
The formal implementation of \smv{SANITIZE_ON_CALL} can be found in snippet \ref{snpt:san-on-call}.

\begin{figure}
    \begin{lstlisting}[
        language=smv,
        caption={Assumption \lstinline{SANITIZE_ON_CALL}},
        label={snpt:san-on-call}
    ]
        G (!priv & X priv -> X op = SAN)
    \end{lstlisting}
\end{figure}

Without assuming \smv{SANITIZE_ON_CALL} nuXmv manages to find two counter-examples.
One for property \smv{CSR_INTEGRITY} (\ref{itm:prop-csr-i}) and one for \smv{MEMORY_OP_INTEGRITY} (\ref{itm:prop-mem-i}).
The traces for both counter-examples are depicted in tables \ref{tbl:cex-csr-i-soc} and \ref{tbl:cex-mem-i-soc} respectively.
Note that both traces are very similar.
In both traces, the processor starts in user-mode with some untrusted data in the registers.
User-mode then calls machine-mode which decides to use the contents of the registers without sanitization to either write a \gls{csr} or to memory.

\begin{table}
    \centering
    \input{../results/SANITIZE-ON-CALL/CSR-INTEGRITY.tex}
    \caption{\smv{SANITIZE_ON_CALL} counter-example for \smv{CSR_INTEGRITY} (\ref{itm:prop-csr-i})}
    \label{tbl:cex-csr-i-soc}
\end{table}

\begin{table}
    \centering
    \input{../results/SANITIZE-ON-CALL/MEMORY-OP-INTEGRITY.tex}
    \caption{\smv{SANITIZE_ON_CALL} counter-example for \smv{MEMORY_OP_INTEGRITY} (\ref{itm:prop-mem-i})}
    \label{tbl:cex-mem-i-soc}
\end{table}

It has already been touched that both assumptions \smv{CLEAR_ON_RET} (cf. snippet \ref{snpt:clr-on-ret}) and \smv{SANITIZE_ON_CALL} (cf. snippet \ref{snpt:san-on-call}) are similar to each other.
This relation characterizes a pattern that can be recognized for other groups of assumptions.
It turned out that for every confidentiality related assumption such as \smv{CLEAR_ON_RET}, there was a similar integrity related assumption such as \smv{SANITIZE_ON_CALL}.
This can be easily seen in table \ref{tbl:assumptions-overview} where in alternating rows, two groups of assumptions can be distinguished those which are relevant to the \smv{NO_LEAK} property and those which are relevant to the \smv{MEMORY_OP_INTEGRITY} and \smv{CSR_INTEGRITY} property.
Additionally it is noteworthy that these two groups of assumptions can be characterized by the way they constrain information flow.
Whereas confidentiality related assumptions always constrain flow of information going \textit{out} of machine-mode, integrity related assumptions always constrain flow of information going \textit{in} machine-mode.

\paragraph{No public memory accesses in machine-mode}
Two assumptions about memory reads and writes join the ranks of these groups, namely \smv{NO_PUBLIC_WRITES} and \smv{NO_PUBLIC_READS} which are formally given in snippet \ref{snpt:no-public-writes} and \ref{snpt:no-public-reads} respectively.
These two assumptions don't express more than the title says; they require machine-mode to never read from or write to public memory.

\begin{figure}
    \begin{lstlisting}[
        language=smv,
        caption={Assumption \lstinline{NO_PUBLIC_WRITES}},
        label={snpt:no-public-writes}
    ]
        G (priv & op = STORE -> (
            mem_addr < $REGION0_SIZE
                ? !pmpcfg0.read
                : !pmpcfg1.read
        ))
    \end{lstlisting}
\end{figure}

\begin{figure}
    \begin{lstlisting}[
        language=smv,
        caption={Assumption \lstinline{NO_PUBLIC_READS}},
        label={snpt:no-public-reads}
    ]
        G (priv & op = LOAD -> (
            mem_addr < $REGION0_SIZE
                ? !pmpcfg0.write
                : !pmpcfg1.write
        ))
    \end{lstlisting}
\end{figure}

The three counter-examples involved in this two assumptions are rather straight-forward as well.
If machine-mode is allowed to store arbitrary words into public memory, a simple counter-example to the \smv{NO_LEAK} property (\ref{itm:prop-no-leak}) is that machine-mode simply stores a secret into public memory which is then loaded by user-mode as illustrated by the trace in table \ref{tbl:cex-no-leak-npw}.
On the other hand, if machine-mode is allowed to load arbitrary words from public memory nuXmv gives a counter-example to the properties \smv{CSR_INTEGRITY} (\ref{itm:prop-csr-i}) and \smv{MEMORY_OP_INTEGRITY} (\ref{itm:prop-mem-i}) where all memory is untrusted in the initial state, machine-mode loads some word from memory and uses it to write a \gls{csr} with or as target address.
These counter-examples are illustrated in table \ref{tbl:cex-csr-i-npw} and \ref{tbl:cex-mem-i-npw} respectively.

\begin{table}
    \centering
    \input{../results/NO-PUBLIC-WRITES/NO-LEAK.tex}
    \caption{\smv{NO_PUBLIC_WRITES} counter-example for \smv{NO_LEAK} (\ref{itm:prop-no-leak})}
    \label{tbl:cex-no-leak-npw}
\end{table}

\begin{table}
    \centering
    \input{../results/NO-PUBLIC-READS/CSR-INTEGRITY.tex}
    \caption{\smv{NO_PUBLIC_READS} counter-example for \smv{CSR_INTEGRITY} (\ref{itm:prop-csr-i})}
    \label{tbl:cex-csr-i-npw}
\end{table}

\begin{table}
    \centering
    \input{../results/NO-PUBLIC-READS/MEMORY-OP-INTEGRITY.tex}
    \caption{\smv{NO_PUBLIC_READS} counter-example for \smv{MEMORY_OP_INTEGRITY} (\ref{itm:prop-mem-i})}
    \label{tbl:cex-mem-i-npw}
\end{table}

\subsection{Canaries}
\label{sec:canaries}

\subsection{Limitations}
