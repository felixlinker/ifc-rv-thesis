%!TEX root = ../thesis.tex

\section{Information Flow Control}

% TODO: Introduction

\subsection{Information Flow Semantics for Instructions}
\label{sec:ifc-model}

% TODO: reference to introduction of Ferraiuolo17 paper

% 1. Introduce Ferraiuolo17 type system rules (only relevant ones)
% 2. Transform lattice transitions to two independent labelings with sup and inf operation
% 3. Introduce defaults
% 4. Translate transitions

% TODO: ensure that this introduction is free of redundancies
In \cite{Ferraiuolo17} the authors introduce an extension to the \gls{hdl} SecVerilog in form of a type system that implements static information flow control forming the new language SecVerilogBL.
They evaluated their approach by successfully finding some known bugs in the Arm architecture.
% TODO: evaluate their results more strongly and compare them to mine
Their approach includes two key ideas:
\begin{enumerate}
    % TODO: "that annotate information" is too broad
    \item A lattice of security labels that annotate information
    \item A type system that allows them to statically track information through Verilog code
\end{enumerate}
In short, the security labels represent the semantics of pieces of information while the type system rules define how information moves through the \gls{hdl} code.
In this section, we will apply these two ideas to an \gls{isa}.
We will apply the ideas of the type system developed in \cite{Ferraiuolo17} to the semantics of the instructions specified by the \gls{isa} of MINRV8 by giving information flow semantics on a per-instruction basis.
This transformation is necessary because in our practical scenario, we cannot rely on the same computational power as a static type checker can.
In our implementation, we will need to realize the information flow control via state-system-transition rules expressed in propositional logic.

\cite{Ferraiuolo17} introduces four information flow labels $ \Sigma = \{ \PT, \PU, \CT, \CU \} $ which stand for public/trusted, public/untrusted, confidential/trusted and confidential/untrusted.
As you can see, each of these four labels comprises two tokens from two domains of information flow control.
The first of these domains is the one of \textit{confidentiality} - each of the labels states that a piece of information is either public (\P{}) or confidential (\C{}).
The second of these domains is the one of \textit{integrity}, i.e. are the values we deal with integrous or - in other words - not malicious?
Each of the labels states that a piece of information is either trusted (\T{}) or untrusted (\U{}).

These labels have a partial order defined $ \preceq $ on them which induces a supremum $ \sqcup $ and an infimum $ \sqcap $ operator on $ \Sigma $.
This partial order is depicted in figure \ref{fig:sec-lattice} as a hasse diagram.
The intuition behind the ordering is that information is always allowed to flow up in the hasse diagram while it is not allowed to flown down.

\begin{example}
    Remember, that this lattice was defined with a type system in mind.
    For information to flow up in this context is best illustrated with the following code snippet\footnote{%
        The syntax of this snippet is \textit{not} SecVerilogBL.%
    }:
    \begin{lstlisting}
        int a : PT = 0;
        int b : PU = a;
    \end{lstlisting}

    In this example, first a variable called \asl{a} is initialized and labelled with \PT{}.
    Then, the value of \asl{a} is assigned to another newly initialized variable labelled with \PU{}.
    This flow of information would be permitted by the lattice $ (\Sigma, \sqcup, \sqcap) $ as information that is labelled with \PT{} flows to a destination that is labelled with \PU{} which is $ \preceq $-greater than \PT{}.

    However, if this flow of information was to occur the other way round, it would have been prohibited.
\end{example}

\begin{figure}
    \centering
    \begin{tikzpicture}
        \begin{scope}
            \node (pt) {\PT};
            \node[above right=of pt] (ct) {\CT}
                edge (pt);
            \node[above left=of pt] (pu) {\PU}
                edge (pt);
            \node[above right=of pu] (cu) {\CU}
                edge (ct)
                edge (pu);
        \end{scope}
    \end{tikzpicture}
    \caption{Security lattice for SecVerilogBL \cite{Ferraiuolo17}}
    \label{fig:sec-lattice}
\end{figure}

% TODO: Do I need a reference for the sequent calculus?
Of course, there are more complex operations in SecVerilogBL than simply assigning values to variables.
In reaction to that, the authors of \cite{Ferraiuolo17} introduce type system rules to define how information flows throughout the system, i.e. how operations generate new security labelings in the form of types.
Type system rules are written like proofs of sequent calculus.

\begin{example}
    Consider this example of a proof written in sequent calculus:
    \begin{prooftree}
        \AxiomC{$ A $}
        \AxiomC{$ B $}
        \BinaryInfC{$ C $}
    \end{prooftree}

    This proof states that the formula $ C $ can be derived from the formulas $ A $ and $ B $ or more formally that: $ A, B \vdash C $.
\end{example}

In the context of type systems, formulas used in proofs of sequent calculus often are so called \textcquote{Ferraiuolo17}{typing judgements} where some \textit{environment} types some \textit{expression}, e.g. if $ X $ is a type environment, $ x $ an expression and $ \tau $ a type one possible typing judgement would be $ X \vdash x : \tau $ which means that $ x $ is of type $ \tau $ under the environment $ X $.
The authors of \cite{Ferraiuolo17} introduce three environments:

\begin{description}
    \item[Standard environment] $ \Gamma $ maps variables to their respective security labeling type, i.e. a function mapping \texttt{int}s as bit indices to security labels (more on this later).
    % TODO: Why must there be a width environment? Introduce how HDLs look like at the beginning of this passage
    \item[Width environment] $ \W $ maps variables to their respective bit vector length.
    \item[Kind environment] $ \Theta $ allows the lifting of security labels to functions mapping bit indices to security labels and can make type judgements of the form $ \Theta \vdash \tau : \texttt{int} \rightarrow l $ where $ l $ is the type of the security labels and $ \tau $ is a type mapped to by $ \Gamma $.
\end{description}

You can find an overview of those type system rules of \cite{Ferraiuolo17} which are relevant to us in figure \ref{fig:type-rules}.
The most simple type system rule probably is T-Const which types constant expressions $ n $.
% TODO: reflect on why it is sensible to assume that constants are trusted in their scenario but not in ours
These are always of type $ \bot $, i.e. \PT, and of the corresponding width $ w $.
The other type system rules share a pattern.
They assume one or two expressions ($ e $ or $ e_1 $ and $ e_2 $) to be typed in $ \Gamma; \W; \Theta $ and ensure that their corresponding types ($ \tau $ or $ \tau_1 $ and $ \tau_2 $) are of the right kind in $ \Theta $.
Then, they create a new type ($ \tau $ or $ \tau' $) and infer a type judgement for a new expression involving $ e $, $ e_1 $ or $ e_2 $ and maybe some constant $ n $.
This structure of type system rules follows the pattern of an inductive proof or inductive definition of a set where T-Const is the start of induction.

\begin{figure}
    \centering
    \begin{subfigure}[t]{.5\linewidth}
        \begin{prooftree}
            \AxiomC{}
            \UnaryInfC{$ \Gamma; \W; \Theta \vdash n: \bot, w $}
        \end{prooftree}
        \caption{T-Const}
    \end{subfigure}

    \begin{subfigure}[t]{.5\linewidth}
        \begin{prooftree}
            \alwaysNoLine
            \AxiomC{$ \Gamma; \W; \Theta \vdash e_1 : \tau_1, w $}
            \UnaryInfC{$ \Theta \vdash \tau_1 : \texttt{int} \rightarrow l $}

            \AxiomC{$ \Gamma; \W; \Theta \vdash e_2 : \tau_2, w $}
            \UnaryInfC{$ \Theta \vdash \tau_2 : \texttt{int} \rightarrow l $}

            \BinaryInfC{$ \tau = i \mapsto \tau_1( i) \sqcup \tau_2(i) $}

            \singleLine
            \UnaryInfC{$ \Gamma; \W; \Theta \vdash e_1 \circ e_2 : \tau, w $}
        \end{prooftree}
        \caption{T-Logical for $ \circ \in \{ \land, \lor \} $}
    \end{subfigure}

    \begin{subfigure}[t]{.5\linewidth}
        \begin{prooftree}
            \alwaysNoLine
            \AxiomC{$ \Gamma; \W; \Theta \vdash e_1 : \tau_1, w $}
            \UnaryInfC{$ \Theta \vdash \tau_1 : \texttt{int} \rightarrow l $}

            \AxiomC{$ \Gamma; \W; \Theta \vdash e_1 : \tau_2, w $}
            \UnaryInfC{$ \Theta \vdash \tau_2 : \texttt{int} \rightarrow l $}

            \BinaryInfC{$ \tau = i \mapsto \bigsqcup_{j \in [1, i]} (\tau_1(j) \sqcup \tau_2(j)) $}

            \singleLine
            \UnaryInfC{$ \Gamma; \W; \Theta \vdash e_1 \circ e_2 : \tau, w $}
        \end{prooftree}
        \caption{T-Arith for $ \circ \in \{ +, - \} $}
    \end{subfigure}

    \begin{subfigure}[t]{.5\linewidth}
        \begin{prooftree}
            \alwaysNoLine
            \AxiomC{$ \Gamma; \W; \Theta \vdash e : \tau, w $}
            \AxiomC{$ \Theta \vdash \tau : \texttt{int} \rightarrow l $}
            \BinaryInfC{$ \tau' = i \mapsto \ite{(i < n)}{\tau(i - n + 1)}{\bot} $}

            \singleLine
            \UnaryInfC{$ \Gamma; \W; \Theta \vdash e \ll n : \tau', w $}
        \end{prooftree}
        \caption{T-LShift}
    \end{subfigure}

    \begin{subfigure}[t]{.5\linewidth}
        \begin{prooftree}
            \alwaysNoLine
            \AxiomC{$ \Gamma; \W; \Theta \vdash e : \tau, w $}
            \AxiomC{$ \Theta \vdash \tau : \texttt{int} \rightarrow l $}
            \BinaryInfC{$ \tau' = i \mapsto \ite{(i > w - n)}{\bot}{\tau(i + n)} $}

            \singleLine
            \UnaryInfC{$ \Gamma; \W; \Theta \vdash e \gg n : \tau', w $}
        \end{prooftree}
        \caption{T-RShift}
    \end{subfigure}
    \caption{A selection of typing rules for SecVerilogBL expressions \cite{Ferraiuolo17}}
    \label{fig:type-rules}
\end{figure}

In order to apply these type system rules to instructions, the idea behind each rule will be investigated next to generate information flow semantics for instructions from those.
An interpretation function $ \I $ is introduced that maps each instruction to its information flow semantics.
We will give the semantics for instruction in a formal way as functions.
These functions receive the input values to the instruction as arguments and map these to the new security labels generated by the instruction.
Such input values are abstract entities.
We denote the integer value of some input $ x $ by $ v(x) \in \mathbb{Z} $ and its security labeling by $ l(x) $.
The security labels in the architecture are tracked bitwise as words of length 8 over the alphabet $ \Sigma = \{ \PT, \PU, \CT, \CU \} $, i.e. $ l(x) \in \Sigma^8 $.

\begin{example}
    The \minrv{Sll} instruction receives two arguments: the word to shift and the word indicating the amount to shift the former by.
    It assigns the result of this operation to some register.
    The security labeling assigned to the result of \minrv{Sll} is denoted by:
    \begin{equation*}
        \I(\textsc{Sll})(\texttt{rs1}, \texttt{rs2})
    \end{equation*}

    Note, that $ \I $ does not hold semantics for \textit{where} information will flow; $ \I $ solely determines \textit{how} information flows.
\end{example}

As we will be working with formal words, we will introduce some definitions to work with these first.
For $ w  \in \Sigma^* $, $ |w| $ denotes its length,
$ \cdot $ is used as word concatenation with its generalization over indices $ \prod $, $ \times $ is the repeated concatenation of a word.
As we try to stay close to bit vectors with these security label words, we zero index and slice them from right to left, i.e. $ abcd[0] = d $ and $ abcd[1:0] = cd $.

\begin{example}
    Let $ w = abcd \in \Sigma^* $.
    \begin{itemize}
        \item $ ab \cdot cd = abcd $
        \item $ \prod_{i \in (|w|, 0]} w[i:0] = abcd \cdot abc \cdot ab \cdot a $
        \item $ 3 \times abc = abc \cdot abc \cdot abc $
    \end{itemize}
\end{example}

Furthermore, we introduce $ \ll : \Sigma^8 \times \mathbb{Z} \rightarrow \Sigma^8 $ as well as $ \gg : \Sigma^8 \times \mathbb{Z} \rightarrow \Sigma^8 $ as bit shift counterparts for words; these word shift operators are recursively defined on $ \Sigma $ as follows:

Let $ w \in \Sigma^8 $ and $ w', w'' \in \Sigma^* $ such that $ a \cdot w' = a \cdot w'' \cdot a' = w $ and $ 1 < n $.
\begin{align*}
    (a \cdot w') \ll 1 &= w' \cdot \bot \\
    w \ll n &= (w \ll 1) \ll (n - 1)
\end{align*}
\begin{align*}
    (a \cdot w'' \cdot a') \gg 1 &= a \cdot a \cdot w'' \\
    w \gg n &= (w \gg 1) \gg (n - 1)
\end{align*}

To extend this definition for shifts by amounts in $ \mathbb{Z} $ we say that $ w \ll 0 = w \gg 0 = w $ and:

Let $ n < 0 $.
\begin{align*}
    w \ll n &= w \gg |n| \\
    w \gg n &= w \ll |n|
\end{align*}

As you can see, the left shift behaves as to be expected and shifts in the least element of $ \Sigma $.
For actual bit vectors this would be the 0.
The right shift operation on the other hand does a sign extension because MINRV8 knows signed words only.

\begin{example}
    Let $ w \in \Sigma^5 $.

    \begin{align*}
        \PT \cdot \PU \cdot w \cdot \CT \ll 2 &= \PU \cdot w \cdot \CT \cdot \bot \ll 1 \\
        &= w \cdot \CT \cdot \bot \cdot \bot \\
        &= w \cdot \CT \cdot \PT \cdot \PT
    \end{align*}
    \begin{align*}
        \CU \cdot w \cdot \PU \cdot \CT \gg 2 &= \CU \cdot \CU \cdot w \cdot \PU \gg 1 \\
        &= \CU \cdot \CU \cdot \CU \cdot w
    \end{align*}
\end{example}

At last, the $ \sqcup $-supremum operator on $ \Sigma $ is extended to $ \Sigma^* $ by applying it literal-wise to a word, e.g. $ ab \sqcup cd = (a \sqcup c) \cdot (b \sqcup d) $.

With these tools at hand the translation of type system rules to semantic functions can be started.
Firstly, the type system rule T-Logical formalizing the information flow of logical operators shall be translated.
This rule infers the type $ \tau $ of the expressions $ e_1 \land e_2 $ and $ e_1 \lor e_2 $ when $ e_1 $ and $ e_2 $ are of type $ \tau_1 $ and $ \tau_2 $ respectively by mapping each bit of the resulting word to the supremum of the labels of the argument words.
This is intuitive as for $ \land $ and $ \lor $ each bit can only be influenced by the two bits of the same index in the argument words.
This leads us to the following semantical function of \minrv{And} and \minrv{Or}:
\begin{equation*}
    \I(\textsc{And}) = \I(\textsc{Or}) = (w, w') \mapsto l(w) \sqcup l(w')
\end{equation*}

The translation of the T-Arith rule which will apply to the interpretation of the instructions \minrv{Add} and \minrv{Sub} is analogously straight-forward.
In this case, the inferred type $ \tau $ of $ e_1 + e_2 $ and $ e_1 - e_2 $ is defined as:
\begin{equation*}
    \tau = i \mapsto \bigsqcup_{j \in [1, i]} (\tau_1(j) \sqcup \tau_2(j))
\end{equation*}

Although \cite{Ferraiuolo17} not explicitly mentions whether bit vectors are one- or zero-indexed, it can be assumed for them to be one-indexed as the authors write: \textcquote{Ferraiuolo17}{%
    The rule T-Arith must track the bits that are propagated by carry bits.
    The $ i^\textit{th} $ bit of the result is affected by all bits below $ i $ from both inputs.%
}
As the definition of $ \tau $ uses indexing over the set $ [ 1, i ] $ it can be assumed for bit vectors to be one indexed as the alternative would contradict each bit being affected by \enquote{all bits below}.

The label of each bit of the result is inferred by taking the supremum of all bits that come below.
This leads to a partially ordered sequence of security labels, i.e. we have $ \forall i' > i. \tau(i) \preceq \tau(i') $ where $ \preceq $ denotes the partial order on $ \Sigma $ induced by $ \sqcup $.
This notion is expressed by the helper function extendSup which is defined as follows:
\begin{equation*}
    \text{extendSup} = x \mapsto \prod_{i \in (|x|, 0]} \Big( \bigsqcup_{j \in [0, i]} x[j] \Big)
\end{equation*}

extendSup implements the idea of $ \tau $ and subsequently \textit{extends} the label of each index $ i $ to all indices greater than $ i $ which map to a $ \preceq $-smaller label.

\begin{example}
    \begin{equation*}
        \text{extendSup}(\CU \cdot
        \PU \cdot \PT) = \CU \cdot \PU \cdot \PT
    \end{equation*}

    \begin{equation*}
        \text{extendSup}(\PU \cdot \CU \cdot \PU \cdot \PT \cdot \PU) = \CU \cdot \CU \cdot \PU \cdot \PU \cdot \PU
    \end{equation*}
\end{example}

With extendSup we can define the semantics of the \minrv{Add} and \minrv{Sub} instructions.
\begin{equation*}
    \I(\textsc{Add}) = \I(\textsc{Sub}) = (w, w') \mapsto \text{extendSup}\big(l(w) \sqcup l(w') \big)
\end{equation*}

\begin{example}
    Consider the addition of two bit vectors which generally are considered to be public and untrusted with one bit being confidential and trusted.
    \begin{align*}
        & \I(\textsc{Add})(\PU \cdot \CT \cdot \PU, \PU \cdot \PU \cdot \PU) \\
        =& \text{extendSup}((\PU \cdot \CT \cdot \PU) \sqcup (\PU \cdot \PU \cdot \PU)) \\
        =& \text{extendSup}(\PU \cdot \CU \cdot \PU) \\
        =& \CU \cdot \CU \cdot \PU
    \end{align*}
\end{example}

T-LShift and T-RShift infer the type of $ e \ll n $ and $ e \gg n $ by simply shifting the labels.
Most of the work to translate these type system rules has already been done by the definition of $ \ll $ and $ \gg $ on security label words with the only difference being that shifts in SecVerilogBL are unsigned.
Therefore in the type system rules $ \bot $ is shifted in not only for left shifts but also for right shifts; this exception has been already coped with in the definition of $ \gg $.

However, in \cite{Ferraiuolo17} the authors also only know one source of labels, i.e. the word that is shifted, because shifts can only occur by constant amounts\footnote{%
    Recall that constants in SecVerilogBL are of type $ \bot $, i.e. do not need to be considered further as $ x \sqcup \bot = x $.
}.
In the context of this thesis, the value of a register determines the amount a word will be shifted by, i.e. that amount is dynamic and has its own security labels.
We therefore extend the interpretation of the \minrv{Sll} and \minrv{Sra} instructions by taking the maximum label of the amount the word will be shifted by and applying this label to all labels of the shifted word.
The reasoning behind this is that each bit of the word shifted is influenced by the amount it will be shifted by.
\begin{align*}
    \I(\textsc{Sll}) &= (w, s) \mapsto \big(l(w) \ll v(s) \big) \sqcup \Big(|l(s)| \times \bigsqcup l(s) \Big) \\
    \I(\textsc{Sra}) &= (w, s) \mapsto \big(l(w) \gg v(s) \big) \sqcup \Big(|l(s)| \times \bigsqcup l(s) \Big)
\end{align*}

Now, the only thing left is to give semantics for all the instruction that do not have an analogous type system rule, i.e. \minrv{Load}, \minrv{Store}, \minrv{Loadi}, \minrv{Mov}, \minrv{Slt}, \minrv{Csrrs} and \minrv{Csrrc}.

\minrv{Slt} sets only one bit of the targeted register thus its semantics also should set only one literal of the resulting security labeling.
As on a bit comparison of bit vectors all bits are taken into account to produce the comparison result, the resulting comparison bit is set to the maximum of all bits of both arguments.
\begin{equation*}
    \I(\textsc{Slt}) = (w, w') \mapsto \bot\bot\bot\bot\bot\bot\bot \cdot \Big(\bigsqcup l(w) \sqcup \bigsqcup l(w') \Big)
\end{equation*}

The semantics of \minrv{Mov} is rather simple.
Since \minrv{Mov} only \textit{moves} information, the labels of a moved word must not change:
\begin{equation*}
    \I(\textsc{Mov}) = w \mapsto l(w)
\end{equation*}

Similar is true for \minrv{Load} and \minrv{Store}.
These instructions also simply move values through the architecture and therefore also simply cascade security labels.
However, as memory addressing is dynamic via indices stored in registers.
The magic function \mbox{memoryLabel} that maps memory addresses to the corresponding labelings copes with this.
It allows to define the semantics of \minrv{Load} and \minrv{Store} as follows:
\begin{align*}
    \I(\textsc{Load}) &= a \mapsto \text{memoryLabel}\big(v(a) \big) \\
    \I(\textsc{Store}) &= (a, d) \mapsto l(d)
\end{align*}

A similar magic function is needed for the semantics of \minrv{Csrrs} and \minrv{Csrrc}.
The magic function \mbox{csrLabel} that maps \gls{csr}-indices to the corresponding security labelings deals with \gls{csr} reads as these happen via index as well.
\begin{align*}
    \I(\textsc{Csrrs}) = \I(\textsc{Csrrc}) &= (r, w) \mapsto \text{csrLabel}\big(v(r) \big)
\end{align*}

Finally, the semantics of \minrv{Loadi} is coupled to the current execution context.
% TODO: Did we explain the threat model?
Under the given threat-scenario, it is sensible to assume that constants loaded by machine-mode are always labelled with \CT{} and constants loaded by user-mode are always labeled with \PU{}.
\begin{equation*}
    \I(\textsc{Loadi}) = c \mapsto \begin{cases}
        8 \times \CT & \; \text{if current mode is machine-mode} \\
        8 \times \PU & \; \text{if current mode is user-mode}
    \end{cases}
\end{equation*}

% TODO: enhance summary

\paragraph{Summary}
A final overview of all information flow semantics for instructions that have been introduced in this section can be found in figure \ref{fig:ifc-semantics}.
Note that not all labels of all inputs are used when generating new labelings; these include\footnote{%
    The label of $ c $ for \minrv{Loadi} is also not being used but in this case, the constant $ c $ does not have a label assigned as it is not a proper value of the architecture.
    This is not made explicit by our formalisms as they don't differentiate between such \textit{proper values} and hard-coded constants but is inline with the type system rules in \cite{Ferraiuolo17}.
}:
\begin{itemize}
    \item The label of the address register $ a $ for the \minrv{Load} and \minrv{Store} instructions
    \item The label of the \gls{csr}-write register $ w $ for the \minrv{Csrrs} and \minrv{Csrrc} instructions
\end{itemize}

The labels of these values have been left untouched purposefully.
This does not mean that these labels don't matter to the system as a whole.
However, they don't constitute the new labels of the actual \textit{values} moved through the architecture.
The labels of these values will be used by the properties the architecture will be verified against.
More on this in section \ref{sec:checking}.

\begin{figure}
    \begin{align*}
        \text{extendSup} &= x \mapsto \prod_{i \in (|x|, 0]} \Big( \bigsqcup_{j \in [0, i]} x[j] \Big) \\
        \I(\textsc{And}) &= \I(\textsc{Or}) = (w, w') \mapsto l(w) \sqcup l(w') \\
        \I(\textsc{Add}) = \I(\textsc{Sub}) &= (w, w') \mapsto \text{extendSup}\big(l(w) \sqcup l(w') \big) \\
        \I(\textsc{Sll}) &= (w, s) \mapsto \big(l(w) \ll v(s) \big) \sqcup \Big(|l(s)| \times \bigsqcup l(s) \Big) \\
        \I(\textsc{Sra}) &= (w, s) \mapsto \big(l(w) \gg v(s) \big) \sqcup \Big(|l(s)| \times \bigsqcup l(s) \Big) \\
        \I(\textsc{Slt}) &= (w, w') \mapsto \bot\bot\bot\bot\bot\bot\bot \cdot \Big(\bigsqcup l(w) \sqcup \bigsqcup l(w') \Big) \\
        \I(\textsc{Mov}) &= w \mapsto l(w) \\
        \I(\textsc{Load}) &= a \mapsto \text{memoryLabel}\big(v(a) \big) \\
        \I(\textsc{Store}) &= (a, d) \mapsto l(d) \\
        \I(\textsc{Csrrs}) = \I(\textsc{Csrrc}) &= (r, w) \mapsto \text{csrLabel}\big(v(r) \big) \\
        \I(\textsc{Loadi}) &= c \mapsto \begin{cases}
            8 \times \CT & \; \text{if current mode is machine-mode} \\
            8 \times \PU & \; \text{if current mode is user-mode}
        \end{cases}
    \end{align*}
    \caption{Information flow semantics for instructions}
    \label{fig:ifc-semantics}
\end{figure}

% TODO:
\subsection{Implementation of Information Flow Tracking}
\label{sec:ifc-implementation}

In order to implement the information flow tracking semantics as described in section \ref{sec:ifc-model} we define a binary representation of the lattice of security labels given by $ \Sigma $ and $ \sqcup $.
We define $ \binSigma = \{ 00, 01, 10, 11 \}$ with a mapping $ \varphi : \Sigma \rightarrow \binSigma $:
\begin{align*}
    \varphi(\PT) &= 01 \\
    \varphi(\PU) &= 00 \\
    \varphi(\CT) &= 11 \\
    \varphi(\CU) &= 10
\end{align*}

\begin{figure}
    \centering
    \begin{tikzpicture}
        \begin{scope}
            \node (pt) {\PT};
            \node[above right=of pt] (ct) {\CT}
                edge (pt);
            \node[above left=of pt] (pu) {\PU}
                edge (pt);
            \node[above right=of pu] (cu) {\CU}
                edge (ct)
                edge (pu);
        \end{scope}

        \begin{scope}[xshift=0.7cm,draw=gray,text=gray]
            \node (01) {$ 01 $};
            \node[above right=of 01] (11) {$ 11 $}
                edge (01);
            \node[above left=of 01] (00) {$ 00 $}
                edge (01);
            \node[above right=of 00] (10) {$ 10 $}
                edge (11)
                edge (00);
        \end{scope}
    \end{tikzpicture}
    \caption{Security lattice for SecVerilogBL \cite{Ferraiuolo17} with binary equivalent}
    \label{fig:sec-lattice-bin}
\end{figure}

We define $ \sqcup $ on $ \binSigma $ such that $ \varphi $ is an isomorphism.
This mapping is depicted in figure \ref{fig:sec-lattice-bin}.
Note that public and untrusted correspond to a 0 whereas confidential and trusted correspond to a 1.
This abstraction can be formalized by examining two equivalence-relations or -classes on $ \Sigma $ and $ \binSigma $.
We define two partitionings $ \Sigma/_{\equiv_C} $ and $ \Sigma/_{\equiv_I} $ on $ \Sigma $ which correspond to equivalence classes modulo confidentiality $ \equiv_C $ or modulo integrity respectively $ \equiv_I $.
\begin{align*}
    \Sigma /_{\equiv_C} &= \big\{ \{ \PU, \PT \}, \{ \CU, \CT \} \big\} \\
    \Sigma /_{\equiv_I} &= \big\{ \{ \PU, \CU \}, \{ \PT, \CT \} \big\}
\end{align*}

We coin the names $ \P = [\PU]_{\equiv_C} $, $ \C = [\CU]_{\equiv_C} $, $ \U = [\PU]_{\equiv_I} $ and $ \T = [\PT]_{\equiv_I} $ and lift $ \sqcup $ to be defined on equivalence-classes in the usual fashion, i.e. $ [x] \sqcup [y] = [x \sqcup y] $.
Note, that $ \P \preceq \C $ and $ \T \preceq \U $ with $ \preceq $ again being the partial order inferred from $ \sqcup $ and that it is possible to define $ \sqcup $ solely by working with these equivalence classes:
\begin{equation*}
    \{ x \sqcup y \} = \big(([x]_{\equiv_C} \sqcup [y]_{\equiv_C}) \cap ([x]_{\equiv_I} \sqcup [y]_{\equiv_I}) \big)
\end{equation*}

\begin{example}
    \begin{align*}
        \{ \PU \sqcup \CT \} &= \big(([\PU]_{\equiv_C} \sqcup [\CT]_{\equiv_C}) \cap ([\PU]_{\equiv_I} \sqcup [\CT]_{\equiv_I}) \big) \\
        &= \big((\P \sqcup \C) \cap (\U \sqcup \T) \big) \\
        &= (\C \cap \U) \\
        &= \{ \CU \}
    \end{align*}
\end{example}

This means that labels of the lattice of security labels $ (\Sigma, \sqcup, \sqcap) $ can be tracked by tracking the confidentiality and integrity labels individually.
Dealing with information flow labels in this way also is much more intuitive:
\begin{itemize}
    % TODO: rewrite this
    \item Two sources of information combined are considered to be confidential if \textit{any} of the sources is confidential itself.
    This is sensible as with some result of an operation at least partial information about its confidential source can be inferred if the other public source and the operation are known.
    \item Two sources of information combined are considered to be trustworthy if \textit{both} of the sources are trustworthy themselves.
    This is intuitive as well.
    Non-trustworthy sources of information are assumed to be controlled by an attacker.
    Some piece of information can only be trustworthy if it can be ensured that the attacker does not control it in any way, shape or form.
    This is only given if both of the sources of an operation are not controlled by an attacker, i.e. are trustworthy.
\end{itemize}

The intuition behind $ \sqcup $ as described above perfectly matches $ \binSigma $ as well.
Recall, that \C{} is represented by a 1 and \P{} by a 0 in the binary representation.
That means that two labels $ a = a_Ca_I \in \binSigma $ and $ b = b_Cb_I \in \binSigma $ are in \C{}, i.e. confidential, if $ a $ or $ b $ is confidential, i.e. if \textit{one} of the bits representing the confidentiality of the labels is high, i.e. if $ a_C \lor b_C $.
In turn, these two labels are in $ \T $, i.e. trusted, if $ a $ and $ b $ are trusted, i.e. if \textit{both} of the bits representing the integrity of the labels are high, i.e. if $ a_I \land b_I $.
This allows us to define $ \sqcup $ on $ \binSigma $ again - this time not just semantically:
\begin{equation*}
    a_C a_I \sqcup b_C b_I = (a_C \lor b_C) \cdot (a_I \land b_I)
\end{equation*}

In summary, these paragraphs showed to things:
\begin{enumerate}
    \item Security labels of information can be tracked by using separate labels for the domain of confidentiality and the domain of integrity which in turn can be stored independently of each other.
    This means that the implementation of the MINRV8 architecture does not need to work with the full lattice of information flow labels itself.
    It is sufficient to deal with equivalence classes which can be inferred from individual bits.
    \item The $ \sqcup $ operation on the binary representation of the security labels $ \binSigma $ can be implemented by deriving the confidentiality label by taking the logical disjunction ($ \lor $) of the olds labels and the integrity label by taking the logical conjunction ($ \land $) of the old labels.
\end{enumerate}

This now allows for adding security label tracking to the model whereby the confidentiality and the integrity of values will be tracked.
Labels are assigned on a per bit basis to all values in registers, memory, \glspl{csr} and the cache.
For each variable in the model, an confidentiality or integrity tracking counterpart as (arrays of) unsigned word is added; find an overview of all such variables in table \ref{tbl:ifc-vars}.

\begin{table}
    \centering
    \begin{tabular}{| c | c | c |}
        \hline
        \textbf{Variable} & \textbf{Confidentiality Tracking} & \textbf{Integrity Tracking} \\
        \hline
        {\smv{regs}} & {\smv{regs_conf}} & {\smv{regs_integrity}} \\
        {\smv{memory}} & {\smv{memory_conf}} & {\smv{memory_integrity}} \\
        {\smv{csrs}} & {\smv{\_\_csrs_conf}} & {\smv{\_\_csrs_integrity}} \\
        {\smv{cache.line}} & {\smv{cache.conf}} & {\smv{cache.integrity}} \\
        \hline
    \end{tabular}
    \caption{Information Flow Control Variables}
    \label{tbl:ifc-vars}
\end{table}

These variables transition under the same conditions as their base variable does, e.g. \smv{regs_conf} does a transition if and only if \smv{regs} transitions and \smv{regs_conf} will deduct its content from sources parallel the those of \smv{regs}.
The values themselves change based on the current instruction and its information flow tracking semantics as described in section \ref{sec:ifc-model}.
% TODO: explain why this is the case
The only exception to this is the information flow tracking of the variable \smv{csrs} the labels of which do not change at all.

In other words, the \lstinline[language=SMV,mathescape]{$\dots$_conf} and \lstinline[language=SMV,mathescape]{$\dots$_integrity} variables perfectly mirror the architecture implementation as described in section \ref{sec:model-implementation}.
Rather than simply simulating the MINRV8 architecture in nuXmv, the domain of confidentiality and the domain of integrity of the MINRV8 architecture are tracked in addition to simulating the pure computational-world.
