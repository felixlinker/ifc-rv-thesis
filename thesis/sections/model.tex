%!TEX root = ../thesis.tex

\section{Model}
\label{sec:model}

% TODO: Introduction
% TODO: Add goal of the architecture and in particular, checking it

\subsection{The MINRV8 Architecture}
\label{sec:minrv8}

The architecture that will be model checked in this thesis is a minimal, \gls{riscv}-inspired 8-bit architecture and shall be named MINRV8 from now on.
A secure embedded system that implements the RV32E, i.e. base integer instruction set for embedded computing, was taken as a role model for this minimal architecture.

MINRV8 supports 4 general purpose registers and has two privilege modes: machine- and user-mode.
Besides this, it has 4-bytes of read- and write-memory which is divided into two regions the first of which ranges from addresses 0 to 1 whereas the other occupies all remaining addresses, i.e. 2 to 3.
MINRV8 supports basic instructions for memory reads and writes, integer arithmetic with $ + $ and $ - $, bit-shifts, bitwise-logical operations with AND and OR, a MOV instruction to move a word from one register to another, a conditional instruction, two instructions to switch privilege mode and instructions to read and write \glspl{csr}.
A full list of all instructions can be found in table \ref{tbl:min-arch-instrs}.
Machine words are generally interpreted as signed-words thus there won't be unsigned counterparts to integer arithmetic or comparison instruction.

\begin{table}
    \centering
    \begin{tabular}{|l p{10cm}|}
        \hline
        LOAD $ rd $, $ rs1 $ & Load the word stored in memory at the address stored in registers $ rs1 $ modulo 4 into register $ rd $ \\
        STORE $ rs1 $, $ rs2 $ & Store the word located in register $ rs2 $ into memory at address stored in register $ rs1 $ modulo 4 \\
        LOADI $ rd $, $ imm $ & Load the 8-bit immediate value $ imm $ into register $ rd $ \\
        ADD $ rd $, $ rs1 $, $ rs2 $ & Set register $ rd $ to the sum of the values in registers $ rs1 $ and $ rs2 $ \\
        SUB $ rd $, $ rs1 $, $ rs2 $ & Set register $ rd $ to the value of register $ rs1 $ minus the value of register $ rs2 $ \\
        AND $ rd $, $ rs1 $, $ rs2 $ & Set register $ rd $ to the result of a bitwise-AND of the values of registers $ rs1 $ and $ rs2 $ \\
        OR $ rd $, $ rs1 $, $ rs2 $ & Same as AND but with the bitwise-OR operation \\
        MOV $ rd $, $ rs1 $ & Set register $ rd $ to the content of register $ rs1 $ \\
        SLL $ rd $, $ rs1 $, $ rs2 $ & Set register $ rd $ to content of register $ rs1 $ shifted left logically (i.e. without sign-extension) by the value in register $ rs2 $ \\
        SRA $ rd $, $ rs1 $, $ rs2 $ & Set register $ rd $ to the content of register $ rs1 $ shifted right arithmetically (i.e. with sign-extension) by the value in register $ rs2 $ \\
        SLT $ rd $, $ rs1 $, $ rs2 $ & Set register $ rd $ to 0x01 if the value in register $ rs1 $ is smaller than the value in register $ rs2 $ \\
        ECALL & Environment call to machine-mode \\
        MRET & Machine-mode return from trap handler \\
        CSRRS $ rd $, $ rs1 $, $ rs2 $ & Read the value of the \gls{csr} with index $ rs1 $ modulo the number of all CSRs and store it in register $ rd $; additionally, set all bits of the \gls{csr} high that are high in register $ rs2 $ \\
        CSRRC $ rd $, $ rs1 $, $ rs2 $ & Same as CSRRS but set all bits low that are low in register $ rs2 $ \\
        \hline
    \end{tabular}
    \caption{Instructions of the MINRV8 architecture}
    \label{tbl:min-arch-instrs}
\end{table}

Besides the general purpose storage options, MINRV8 also includes three \glspl{csr}: a \gls{mstatus} equivalent, a \gls{pmpcfg} equivalent and a \gls{pmacfg} register that implements the configuration of some \glspl{pma} as described in section \ref{sec:memory-attrs}.
MINRV8 supports external interrupts as the only source of interrupts and an environment call to machine-mode as the only source of exceptions.
Therefore, in the context of MINRV8, \gls{mstatus} has 4 bits that include two stacking bits for taking traps, a MEIP bit to signal pending external interrupts and a MIE bit to en- or disable interrupts and excludes other bits that are present in the RV32E architecture such as other interrupt pending bits.

The \gls{pmacfg} register defines cacheability of the two memory regions.
Each memory region can either be set as uncacheable, write-back-cacheable, write-through-cacheable or write-protected-cacheable.
% TODO: Introduce intel architecture
% TODO: Is it really the x86 architecture?
% TODO: Introduce caching in detail
These caching mechanisms are inspired by the caching mechanisms that are available in the x86 architecture from intel as described in section 11.3 \textit{Methods of Caching Available} of the System Programming Guide in the Software Developer's Manual \cite{IntelSystemProgramming}.
% TODO: Explain how each of these mechanisms work

The \gls{pmpcfg} register allows to set read and write privileges per memory region and also allows to lock the settings of individual regions.

Someone experienced in the field of microcontrollers and processors might find MINRV8 to lack some crucial features, such as jump and branch instructions and the specification of executable memory or an instruction fetch unit.
These points were left out or left unspecified deliberately.
However, a good reasoning for this can not be given at this point.
The development of the MINRV8 architecture was tightly coupled to its implementation in nuXmv which will presented in section \ref{sec:model-implementation}.
In section \ref{sec:model-scope}, the scope of the MINRV8 architecture will be analyzed - both in terms of what it tries to achieve and what it actually is capable of representing, i.e. how close it is to real-life architectures.
In this section, the aforementioned problems will also be reflected.

\subsection{Information Flow Control}
\label{sec:ifc-model}

% TODO: reference to introduction of Ferraiuolo17 paper

% 1. Introduce Ferraiuolo17 type system rules (only relevant ones)
% 2. Transform lattice transitions to two independent labelings with sup and inf operation
% 3. Introduce defaults
% 4. Translate transitions

% TODO: ensure that this introduction is free of redundancies
In \cite{Ferraiuolo17} the authors introduce an extension to the \gls{hdl} SecVerilog in form of a type system that implements static information flow control forming the new language SecVerilogBL.
They evaluated their approach by successfully finding some known bugs in the Arm architecture.
% TODO: evaluate their results more strongly and compare them to mine
Their approach includes two key ideas:
\begin{enumerate}
    % TODO: "that annotate information" is too broad
    \item A lattice of security labels that annotate information
    \item A type system that allows them to statically track information through Verilog code
\end{enumerate}
In short, the security labels represent the semantics of pieces of information while the type system rules define how information moves through the \gls{hdl} code.
In this section, we will apply these two ideas to an \gls{isa}.
We will apply the ideas of the type system developed in \cite{Ferraiuolo17} to the semantics of the instructions specified by the \gls{isa} of MINRV8 by giving information flow semantics on a per-instruction basis.
This transformation is necessary because in our practical scenario, we cannot rely on the same computational power as a static type checker can.
In our implementation, we will need to realize the information flow control via state-system-transition rules expressed in propositional logic.

\cite{Ferraiuolo17} introduces four labels for information $ \Sigma = \{ \PT, \PU, \CT, \CU \} $ which stand for public/trusted, public/untrusted, confidential/trusted and confidential/untrusted.
As you can see, each of these four labels comprises two tokens from two domains of information flow control.
The first of these domains is the one of \textit{confidentiality} - each of the labels states that a piece of information is either public (\P{}) or confidential (\C{}).
The second of these domains is the one of \textit{integrity}, i.e. are the values we deal with integrous or in other words not malicious?
Each of the labels states that a piece of information is either trusted (\T{}) or untrusted (\U{}).

These labels come with a supremum operation $ \sqcup $ which induces an implicit partial order $ \preceq $ on them.
This partial order is depicted in figure \ref{fig:sec-lattice} as a hasse diagram.
The intuition behind the ordering is that information is always allowed to flow up in the hasse diagram while it is not allowed to flown down.

\begin{example}
    Remember, that this lattice was defined with a type system in mind.
    For information to flow up in this context is best illustrated with the following code snippet\footnote{%
        The syntax of this snippet is \textit{not} SecVerilogBL.%
    }:
    \begin{lstlisting}
int a : PT = 0;
int b : PU = a;
    \end{lstlisting}

    In this example, first a variable called \asl{a} is initialized and labelled with \PT{}.
    Then, the value of \asl{a} is assigned to another newly initialized variable labelled with \PU{}.
    This flow of information would be permitted by the lattice of $ \Sigma $ as information that is labelled with \PT{} flows to a destination that is labelled with \PU{} which is $ \preceq $-greater than \PT{}.

    However, if this flow of information was to occur the other way round, it would have been prohibited.
\end{example}

\begin{figure}
    \centering
    \begin{tikzpicture}
        \begin{scope}
            \node (pt) {\PT};
            \node[above right=of pt] (ct) {\CT}
                edge (pt);
            \node[above left=of pt] (pu) {\PU}
                edge (pt);
            \node[above right=of pu] (cu) {\CU}
                edge (ct)
                edge (pu);
        \end{scope}
    \end{tikzpicture}
    \caption{Security lattice for SecVerilogBL \cite{Ferraiuolo17}}
    \label{fig:sec-lattice}
\end{figure}

% TODO: Do I need a reference for the sequent calculus?
Of course, there are more complex operations in SecVerilogBL than simply assigning values to variables.
In reaction to that, the authors of \cite{Ferraiuolo17} introduce type system rules to define how information flows throughout the system, i.e. how operations generate new security labelings in the form of types.
Type system rules are written like proofs of sequent calculus.
Consider this example of a proof written in sequent calculus:
\begin{prooftree}
    \AxiomC{$ A $}
    \AxiomC{$ B $}
    \BinaryInfC{$ C $}
\end{prooftree}

This proof states that $ C $ can be derived from $ A $ and $ B $ or more formally that: $ A, B \vdash C $.
In the context of type systems $ A $, $ B $ and $ C $ often are so called \textcquote{Ferraiuolo17}{typing judgements} where some \textit{environment} types some \textit{expression}, e.g. if $ X $ is a type environment, $ x $ an expression and $ \tau $ a type one possible typing judgement would be $ X \vdash x : \tau $ which means that $ x $ is of type $ \tau $ under the environment $ X $.
The authors of \cite{Ferraiuolo17} introduce three environments:

\begin{description}
    \item[Standard environment] $ \Gamma $ maps variables to their respective security labeling type, i.e. a function mapping \texttt{int}s as bit indices to security labels (more on this later).
    % TODO: Why must there be a width environment? Introduce how HDLs look like at the beginning of this passage
    \item[Width environment] $ \W $ maps variables to their respective bit vector length.
    \item[Kind environment] $ \Theta $ allows the lifting of security labels to functions mapping bit indices to security labels and can make type judgements of the form $ \Theta \vdash \tau : \texttt{int} \rightarrow l $ where $ l $ is the type of the security labels and $ \tau $ is a type mapped to by $ \Gamma $.
\end{description}

You can find an overview of those type system rules of \cite{Ferraiuolo17} which are relevant to us in figure \ref{fig:type-rules}.
The most simple type system rule probably is T-Const which types constant expressions $ n $.
% TODO: reflect on why it is sensible to assume that constants are trusted in their scenario but not in ours
These are always of type $ \bot $, i.e. \PT, and of the corresponding width $ w $.
The other type system rules share a pattern.
They assume one or two expressions ($ e $, $ e_1 $ or $ e_2 $) to be typed in $ \Gamma; \W; \Theta $ and ensure that their corresponding types ($ \tau $, $ \tau_1 $ or $ \tau_2 $) are of the right kind in $ \Theta $.
Then, they create a new type ($ \tau $ or $ \tau' $) and infer a type judgement for a new expression involving $ e $, $ e_1 $ or $ e_2 $ and maybe some constant $ n $.
This structure of type system rules follows the pattern of an inductive proof or definition of a set where T-Const is the start of induction.

\begin{figure}
    \centering
    \begin{subfigure}[t]{.5\linewidth}
        \begin{prooftree}
            \AxiomC{}
            \UnaryInfC{$ \Gamma; \W; \Theta \vdash n: \bot, w $}
        \end{prooftree}
        \caption{T-Const}
    \end{subfigure}

    \begin{subfigure}[t]{.5\linewidth}
        \begin{prooftree}
            \alwaysNoLine
            \AxiomC{$ \Gamma; \W; \Theta \vdash e_1 : \tau_1, w $}
            \UnaryInfC{$ \Theta \vdash \tau_1 : \texttt{int} \rightarrow l $}

            \AxiomC{$ \Gamma; \W; \Theta \vdash e_2 : \tau_2, w $}
            \UnaryInfC{$ \Theta \vdash \tau_2 : \texttt{int} \rightarrow l $}

            \BinaryInfC{$ \tau = i \mapsto \tau_1( i) \sqcup \tau_2(i) $}

            \singleLine
            \UnaryInfC{$ \Gamma; \W; \Theta \vdash e_1 \circ e_2 : \tau, w $}
        \end{prooftree}
        \caption{T-Logical for $ \circ \in \{ \land, \lor \} $}
    \end{subfigure}

    \begin{subfigure}[t]{.5\linewidth}
        \begin{prooftree}
            \alwaysNoLine
            \AxiomC{$ \Gamma; \W; \Theta \vdash e_1 : \tau_1, w $}
            \UnaryInfC{$ \Theta \vdash \tau_1 : \texttt{int} \rightarrow l $}

            \AxiomC{$ \Gamma; \W; \Theta \vdash e_1 : \tau_2, w $}
            \UnaryInfC{$ \Theta \vdash \tau_2 : \texttt{int} \rightarrow l $}

            \BinaryInfC{$ \tau = i \mapsto \bigsqcup_{j \in [1, i]} (\tau_1(j) \sqcup \tau_2(j)) $}

            \singleLine
            \UnaryInfC{$ \Gamma; \W; \Theta \vdash e_1 \circ e_2 : \tau, w $}
        \end{prooftree}
        \caption{T-Arith for $ \circ \in \{ +, - \} $}
    \end{subfigure}

    \begin{subfigure}[t]{.5\linewidth}
        \begin{prooftree}
            \alwaysNoLine
            \AxiomC{$ \Gamma; \W; \Theta \vdash e : \tau, w $}
            \AxiomC{$ \Theta \vdash \tau : \texttt{int} \rightarrow l $}
            \BinaryInfC{$ \tau' = i \mapsto \ite{(i < n)}{\tau(i - n + 1)}{\bot} $}

            \singleLine
            \UnaryInfC{$ \Gamma; \W; \Theta \vdash e \ll n : \tau', w $}
        \end{prooftree}
        \caption{T-LShift}
    \end{subfigure}

    \begin{subfigure}[t]{.5\linewidth}
        \begin{prooftree}
            \alwaysNoLine
            \AxiomC{$ \Gamma; \W; \Theta \vdash e : \tau, w $}
            \AxiomC{$ \Theta \vdash \tau : \texttt{int} \rightarrow l $}
            \BinaryInfC{$ \tau' = i \mapsto \ite{(i > w - n)}{\bot}{\tau(i + n)} $}

            \singleLine
            \UnaryInfC{$ \Gamma; \W; \Theta \vdash e \gg n : \tau', w $}
        \end{prooftree}
        \caption{T-RShift}
    \end{subfigure}
    \caption{A selection of typing rules for SecVerilogBL expressions \cite{Ferraiuolo17}}
    \label{fig:type-rules}
\end{figure}

In order to apply these type system rules to instructions, we will investigate the idea behind each rule and generate information flow semantics for instructions from those.
We introduce a interpretation function $ \I $ that maps each instruction to its information flow semantics.
We will give the semantics for instruction in a formal way as functions.
These functions receive the input values to the instruction as arguments and map these to the new security labels generated by the instruction.
Such input values are abstract entities.
We denote the integer value of some input $ x $ by $ v(x) \in \mathbb{Z} $ and its security labeling by $ l(x) $.
We track the security labelings in the architecture bitwise as words of length 8 over the alphabet $ \Sigma = \{ \PT, \PU, \CT, \CU \} $, i.e. $ l(x) \in \Sigma^* $.

\begin{example}
    The SLL instruction receives two arguments: the word to shift and the word indicating the amount to shift the former by.
    It assigns the result of this operation to some register.
    The security labeling assigned to the result of SLL is denoted by:
    \begin{equation*}
        \I(\text{SLL})(\texttt{rs1}, \texttt{rs2})
    \end{equation*}

    Note, that $ \I $ does not hold semantics for \textit{where} information will flow; $ \I $ solely determines \textit{how} information flows.
\end{example}

As we will be working with formal words, we will introduce some definitions to work with these first.
For $ w  \in \Sigma^* $, $ |w| $ denotes its length,
$ \cdot $ is used as word concatenation with its generalization over indices $ \prod $, $ \times $ is the repeated concatenation of a word and as we try to stay close to bit vectors with these security label words, we zero index and slice them from right to left, i.e. $ abcd[0] = d $ and $ abcd[1:0] = cd $.

\begin{example}
    Let $ w = abcd \in \Sigma^* $.
    \begin{itemize}
        \item $ ab \cdot cd = abcd $
        \item $ \prod_{i \in (|w|, 0]} w[i:0] = abcd \cdot abc \cdot ab \cdot a $
        \item $ 3 \times abc = abc \cdot abc \cdot abc $
    \end{itemize}
\end{example}

Furthermore, we introduce $ \ll : \Sigma^8 \times \mathbb{Z} \rightarrow \Sigma^8 $ as well as $ \gg : \Sigma^8 \times \mathbb{Z} \rightarrow \Sigma^8 $ as bit shift counterpart for words; these word shift operators are recursively defined on $ \Sigma $ as follows:

Let $ w \in \Sigma^8 $ and $ w', w'' \in \Sigma^* $ such that $ a \cdot w' = a \cdot w'' \cdot a' = w $ and $ 1 < n $.
\begin{align*}
    (a \cdot w') \ll 1 &= w' \cdot \bot \\
    w \ll n &= (w \ll 1) \ll (n - 1)
\end{align*}
\begin{align*}
    (a \cdot w'' \cdot a') \gg 1 &= a \cdot a \cdot w'' \\
    w \gg n &= (w \gg 1) \gg (n - 1)
\end{align*}

To extend this definition for shifts by amounts in $ \mathbb{Z} $ we say that $ w \ll 0 = w \gg 0 = w $ and:

Let $ n < 0 $.
\begin{align*}
    w \ll n &= w \gg |n| \\
    w \gg n &= w \ll |n|
\end{align*}

As you can see, the left shift behaves as to be expected and shifts in the least element of $ \Sigma $.
For actual bit vectors this would be the 0.
The right shift operation on the other hand does a sign extension because MINRV8 knows signed words only.

\begin{example}
    Let $ w \in \Sigma^5 $.

    \begin{align*}
        \PT \cdot \PU \cdot w \cdot \CT \ll 2 &= \PU \cdot w \cdot \CT \cdot \bot \ll 1 \\
        &= w \cdot \CT \cdot \bot \cdot \bot \\
        &= w \cdot \CT \cdot \PT \cdot \PT
    \end{align*}
    \begin{align*}
        \CU \cdot w \cdot \PU \cdot \CT \gg 2 &= \CU \cdot \CU \cdot w \cdot \PU \gg 1 \\
        &= \CU \cdot \CU \cdot \CU \cdot w
    \end{align*}
\end{example}

At last, we extend the $ \sqcup $-supremum operator on $ \Sigma $ to $ \Sigma^* $ by applying it literal-wise to a word, e.g. $ ab \sqcup cd = (a \sqcup c) \cdot (b \sqcup d) $.

With these tools at hand we can start to translate type system rules to semantic functions.
We start with the logical operations and the type system rule T-Logical.
This rule infers the type $ \tau $ of the expressions $ e_1 \land e_2 $ and $ e_1 \lor e_2 $ when $ e_1 $ and $ e_2 $ are of type $ \tau_1 $ and $ \tau_2 $ respectively by mapping each bit of the produced word to the supremum of the labels of the argument words.
This is intuitive as for $ \land $ and $ \lor $ each bit can only be influenced by the two bits of the same index in the argument words.
This leads us to the following semantical function of AND and OR:
\begin{equation*}
    \I(\text{AND}) = \I(\text{OR}) = (w, w') \mapsto l(w) \sqcup l(w')
\end{equation*}

The translation of the T-Arith rule which will apply to the interpretation of the instructions ADD and SUB is analogously straight-forward.
In this case, the inferred type $ \tau $ of $ e_1 + e_2 $ and $ e_1 - e_2 $ is defined as:
\begin{equation*}
    \tau = i \mapsto \bigsqcup_{j \in [1, i]} (\tau_1(j) \sqcup \tau_2(j))
\end{equation*}

Although we didn't we find mentions whether bit vectors in \cite{Ferraiuolo17} are one- or zero-indexed, we assume them to be one-indexed as the authors write: \textcquote{Ferraiuolo17}{%
    The rule T-Arith must track the bits that are propagated by carry bits.
    The $ i^\textit{th} $ bit of the result is affected by all bits below $ i $ from both inputs.%
}
As the definition of $ \tau $ uses indexing over the set $ [ 1, i ] $ we can assume bit vectors to be one indexed as the alternative would contradict each bit being affected by \enquote{all bits below}.

The label of each bit of the result is inferred by taking the supremum of all bits that come below.
This leads to a partially ordered sequence of security labels, i.e. we have $ \forall i' > i. \tau(i) \preceq \tau(i') $ where $ \preceq $ denotes the partial order on $ \Sigma $ induced by $ \sqcup $.
We express this notion with helper function extendSup which is defined as follows:
\begin{equation*}
    \text{extendSup} = x \mapsto \prod_{i \in (|x|, 0]} \Big( \bigsqcup_{j \in [0, i]} x[j] \Big)
\end{equation*}

extendSup implements the idea of $ \tau $ and subsequently \textit{extends} the label of each index $ i $ to all indices greater than $ i $ which map to a $ \preceq $-smaller label.

\begin{example}
    \begin{equation*}
        \text{extendSup}(\CU \cdot
        \PU \cdot \PT) = \CU \cdot \PU \cdot \PT
    \end{equation*}

    \begin{equation*}
        \text{extendSup}(\PU \cdot \CU \cdot \PU \cdot \PT \cdot \PU) = \CU \cdot \CU \cdot \PU \cdot \PU \cdot \PU
    \end{equation*}
\end{example}

With extendSup we can define the semantics of the ADD and SUB instructions.
\begin{equation*}
    \I(\text{ADD}) = \I(\text{SUB}) = (w, w') \mapsto \text{extendSup}\big(l(w) \sqcup l(w') \big)
\end{equation*}

\begin{example}
    Consider the addition of two bit vectors which generally are considered to be public and untrusted with one bit being confidential and trusted.
    \begin{align*}
        \I(\text{ADD})(\PU \cdot \CT \cdot \PU, \PU \cdot \PU \cdot \PU) &= \text{extendSup}((\PU \cdot \CT \cdot \PU) \sqcup (\PU \cdot \PU \cdot \PU)) \\
        &= \text{extendSup}(\PU \cdot \CU \cdot \PU) \\
        &= \CU \cdot \CU \cdot \PU
    \end{align*}
\end{example}

T-LShift and T-RShift infer the type of $ e \ll n $ and $ e \gg n $ by simply shifting the labels.
Most of the work to translate these type system rules has already been done by our definition of $ \ll $ and $ \gg $ on security label words with the only difference being that shifts in SecVerilogBL are unsigned.
Therefore in the type system rules $ \bot $ is shifted in not only for left shifts but also for right shifts; we already coped with this exception in our definition of $ \gg $.

However, in \cite{Ferraiuolo17} the authors also only know one source of labels, i.e. the word that is shifted, because shifts can only occur by constant amounts\footnote{%
    Recall that constants in SecVerilogBL are of type $ \bot $, i.e. do not need to be considered further as $ x \sqcup \bot = x $.
}.
In the context of this thesis, the amount a word will be shifted by can be taken from a register, i.e. is dynamic and has its own security labels.
We therefore extend the interpretation of the SLL and SRA instructions by taking the maximum label of the amount the word will be shifted by and applying this label to all labels of the shifted word.
The reasoning behind this is that each bit of shifted word is influenced by the amount it will be shifted by.
\begin{align*}
    \I(\text{SLL}) &= (w, s) \mapsto \big(l(w) \ll v(s) \big) \sqcup \Big(|l(s)| \times \bigsqcup l(s) \Big) \\
    \I(\text{SRA}) &= (w, s) \mapsto \big(l(w) \gg v(s) \big) \sqcup \Big(|l(s)| \times \bigsqcup l(s) \Big)
\end{align*}

This leaves us with the need to give semantics for all the instruction that do not have an analogous type system rule, i.e. LOAD, STORE, LOADI, MOV, SLT, CSRRS and CSRRC.
SLT sets only one bit of the targeted register thus its semantics also should set only one literal of the resulting security labeling.
As on a bit comparison of bit vectors all bits are taken into account to produce the comparison result, we set the resulting comparison bit to the maximum of all bits of both arguments.
\begin{equation*}
    \I(\text{SLT}) = (w, w') \mapsto \bot\bot\bot\bot\bot\bot\bot \cdot \Big(\bigsqcup l(w) \sqcup \bigsqcup l(w') \Big)
\end{equation*}

The semantics of MOV are rather simple.
Since MOV only \textit{moves} information, the labels of a moved word must not change:
\begin{equation*}
    \I(\text{MOV}) = w \mapsto l(w)
\end{equation*}

Similar is true for LOAD and STORE.
These instructions also simply move values through the architecture and therefore also simply cascade security labels.
However, as memory addressing is dynamic via indices stored in registers, we introduce the magic function memoryLabel that maps memory addresses to the corresponding labelings.
This lets us define the semantics of LOAD and STORE as follows:
\begin{align*}
    \I(\text{LOAD}) &= a \mapsto \text{memoryLabel}\big(v(a) \big) \\
    \I(\text{STORE}) &= (a, d) \mapsto l(d)
\end{align*}

A similar magic function is needed for the semantics of CSRRS and CSRRC.
As \gls{csr} reads happen via index as well, we introduce the magic function csrLabel that maps \gls{csr}-indices to the corresponding security labelings.
\begin{align*}
    \I(\text{CSRRS}) = \I(\text{CSRRC}) &= (r, w) \mapsto \text{csrLabel}\big(v(r) \big)
\end{align*}

Finally, we couple the semantics of LOADI to the current execution context.
% TODO: Did we explain the threat model?
We think that under our given threat-scenario it is sensible to assume that constants loaded by machine-mode are always labelled with \CT{} and constants loaded by user-mode are always labeled with \PU{}.
\begin{equation*}
    \I(\text{LOADI}) = c \mapsto \begin{cases}
        8 \times \CT & \; \text{if current mode is machine-mode} \\
        8 \times \PU & \; \text{if current mode is user-mode}
    \end{cases}
\end{equation*}

% TODO: enhance summary

\paragraph{Summary}
You can find a final overview of all information flow semantics for instructions that have been introduced in this section in figure \ref{fig:ifc-semantics}.
Note that not all labels of all inputs are used when generating new labelings; these include\footnote{%
    The label of $ c $ for LOADI is also not being used but in this case, the constant $ c $ does not have a label assigned as it is not a proper value of the architecture.
    This is not made explicit by our formalisms as they don't differentiate between such \textit{proper values} and hard-coded constants but is inline with the type system rules in \cite{Ferraiuolo17}.
}:
\begin{itemize}
    \item The label of the address register $ a $ for the LOAD and STORE instructions
    \item The label of the \gls{csr}-write register $ w $ for the CSRRS and CSRRC instructions
\end{itemize}

The labels of these values have been left untouched purposefully.
We do not make the claim that these labels don't matter to the system as a whole but they don't constitute the new labels of the actual \textit{values} moved through the architecture.
We will use the labels of these values in the properties the architecture will be verified against.
More on this in section \ref{sec:checking}.

\begin{figure}
    \begin{align*}
        \text{extendSup} &= x \mapsto \prod_{i \in (|x|, 0]} \Big( \bigsqcup_{j \in [0, i]} x[j] \Big) \\
        \I(\text{AND}) &= \I(\text{OR}) = (w, w') \mapsto l(w) \sqcup l(w') \\
        \I(\text{ADD}) = \I(\text{SUB}) &= (w, w') \mapsto \text{extendSup}\big(l(w) \sqcup l(w') \big) \\
        \I(\text{SLL}) &= (w, s) \mapsto \big(l(w) \ll v(s) \big) \sqcup \Big(|l(s)| \times \bigsqcup l(s) \Big) \\
        \I(\text{SRA}) &= (w, s) \mapsto \big(l(w) \gg v(s) \big) \sqcup \Big(|l(s)| \times \bigsqcup l(s) \Big) \\
        \I(\text{SLT}) &= (w, w') \mapsto \bot\bot\bot\bot\bot\bot\bot \cdot \Big(\bigsqcup l(w) \sqcup \bigsqcup l(w') \Big) \\
        \I(\text{MOV}) &= w \mapsto l(w) \\
        \I(\text{LOAD}) &= a \mapsto \text{memoryLabel}\big(v(a) \big) \\
        \I(\text{STORE}) &= (a, d) \mapsto l(d) \\
        \I(\text{CSRRS}) = \I(\text{CSRRC}) &= (r, w) \mapsto \text{csrLabel}\big(v(r) \big) \\
        \I(\text{LOADI}) &= c \mapsto \begin{cases}
            8 \times \CT & \; \text{if current mode is machine-mode} \\
            8 \times \PU & \; \text{if current mode is user-mode}
        \end{cases}
    \end{align*}
    \caption{Information flow semantics for instructions}
    \label{fig:ifc-semantics}
\end{figure}

\subsection{Implementation of MINRV8 in nuXmv}
\label{sec:model-implementation}

% TODO: better introduction, i.e. introduce the parts we will talk about and nuXmv in general (this might have already been done in the introduction then)

\subsubsection{Core Functionality}

\paragraph{Variables}
In nuXmv, models of a piece of software, hardware or in this case a specification are described using variables with a transition relation.
We implement the core of our model with four variables:
\begin{itemize}
    \item \smv{priv : boolean}
    \item \smv{csrs : array 0..1 of unsigned word[8]}
    \item \smv{regs : array 0..3 of signed word[8]}
    \item \smv{memory : array 0..3 of signed word[8]}
\end{itemize}

As the names suggest: \smv{priv} indicates the current privilege mode where \smv{TRUE} signals that the \gls{hart} is in machine-mode and \smv{FALSE} signals that the \gls{hart} is in user-mode and \smv{csrs} hold the three \glspl{csr} of the MINRV8 architecture.
Technically, only 16 bits are needed to implement all \glspl{csr} of the MINRV8 architecture which is why we decided to only model two physical \glspl{csr}.
This allows implement a homogeneous interface for memory/register reads and writes and does not introduce unused bits to the implementation, i.e. dead state space that still requires traversal from nuXmv.
\gls{mstatus} is located in the lower half (bits 0 to 3) of \smv{csrs[0]}, \gls{pmacfg} in the upper half (bits 4 to 7) of \smv{csrs[0]} and \gls{pmpcfg} in \smv{csrs[1]}.
The variables \smv{regs} and \smv{memory} implement the registers and memory in a straight-forward fashion.

Furthermore, the model knows five input variables:
\begin{itemize}
    \item \smv{op}
    \item \smv{rd : 0..3}
    \item \smv{rs1 : 0..3}
    \item \smv{rs2 : 0..3}
    \item \smv{m_external_interrupt : unsigned word[1]}
\end{itemize}

\smv{op}, \smv{rd}, \smv{rs1} and \smv{rs2} represent a fully decoded instruction where \smv{op} is the opcode as a symbolic constant and the other arguments point to registers with per-instruction determined semantics.
When an instruction does not support some or all of the arguments to the instruction, the values of these input variables are simply ignored.
The variable \smv{m_external_interrupt} signals the event of a pending external interrupt from some source outside of the \gls{hart}.

There is no input variable for an immediate value which might be needed by the LOADI instruction because we didn't want to waste extra state.
% TODO: is this understandable?
Instead, we decided to not constrain the content of the destination register in the case of a LOADI instruction being executed.
By doing so, we implicitly encoded the value written to the destination register by the LOADI instruction in the transition relation rather than in the state space.

\paragraph{Transitions}
nuXmv allows to constrain the transition of variables by arbitrary formulas expressed in propositional logic.
The system can make a transition if it satisfies all formulas given as constraints.
Therefore - if full control over the transition relation is desired - it often is not sufficient to simply constrain transitions by a group of implications\footnote{%
    The exception to this are groups of implications where the antecedents form a total case differentiation, i.e. where one antecedent is always true.
}.

\begin{example}
    Consider this nuXmv model that implements an adder that can store its result in two registers:
    \begin{lstlisting}[language=smv]
MODULE main
    VAR
        r1 : integer;
        r2 :integer;
    IVAR
        ri : 1..2;
        summand1 : integer;
        summand2 : integer;

    DEFINE sum := summand1 + summand2;

    TRANS ri = 1 -> next(r1) = sum;
    TRANS ri = 2 -> next(r2) = sum;

    LTLSPEC G (ri = 1 -> r2 = next(r2));
    LTLSPEC G (ri = 2 -> r1 = next(r1));
    \end{lstlisting}

    Intuitively, this seems right as we imperatively declare that when the selector input variable \smv{ri} equals 1, \smv{r1} should be updated and when it equals 2, \smv{r2} should be updated.
    However, if we attempt to prove one of the two properties in the model which states that a register doesn't change if it isn't selected, nuXmv quickly gives us a counter-example where this is the case.
    This is because the implications do not fully cover all possible transitions of the system.
    On a transition where \smv{ri} does not equal 1 (or 2), the next value of \smv{r1} (or \smv{r2}) is not constrained, i.e. can change to any value.
    Swapping out the implication \smv{->} with a iff \smv{<->} does not solve this as now only that whenever the next value chosen randomly for \smv{r1} or \smv{r2} happens to coincide with the sum of the input variables, \smv{ri} must be equal to the appropriate index.
    In all other cases, nuXmv still can choose whatever next value it wants.

    The only solution to this is covering all other cases and explicitly stating what should happen then as for example can be done by using an inline-if expression:
    \begin{lstlisting}[language=smv]
TRANS next(r1) = (ri = 1 ? sum : r1);
TRANS next(r2) = (ri = 2 ? sum : r2);
    \end{lstlisting}

    Now, whenever \smv{ri} is not equal to the respective index, \smv{r1} (or \smv{r2}) will be stable.
    With this implementation, nuXmv fails to find a counter-example for the two LTL properties.
\end{example}

In our implementation for nuXmv of the MINRV8 architecture, we used \smv{case}-expressions that always close with a default statement to ensure that transitions of variables are always fully constrained.

In the following, we will introduce the \enquote{formal idea} of the variable transitions of our model and assume that variables are stable unless otherwise mentioned, i.e. we won't list all default statements of our model explicitly.

The transitions of the \smv{priv} variable are simple.
There are two conditions by which \smv{priv} can change.
Firstly, whenever there is an exception - be it an exception triggered by a pending external interrupt or a environment call to machine-mode exception - the \gls{hart} switches to machine-mode and does not execute the current instruction, i.e. the value of \smv{op}, \smv{rd}, \smv{rs1} and \smv{rs2} are ignored.
Secondly, when the MRET instruction is executed, the \gls{hart} sets \smv{priv} to the value stored in \gls{mstatus}.MPP (cf. section \ref{sec:rv-exn}).

\gls{mstatus} changes under the same conditions which brings us to the transitions of \smv{csrs}.
On a trap, MPP and MPIE are written accordingly while MEIP and MIE are set to zero.
MEIP can be set to zero although the trap might have been triggered by an ECALL instruction because interrupts have higher priority in \gls{riscv} than synchronous exceptions - either an external interrupt was set pending: then it must be serviced immediately and MEIP must be cleared; or it wasn't set pending: then writing MEIP with 0 does not change the state of the \gls{hart}.
On return from machine-mode, i.e. execution of MRET, MIE is written with MPIE, MPIE is set to 1 and MPP is set to 0; all other bits are left unchanged.
An exception to all rules mentioned above is the field MEIP which can be set high on every transition based on the value of \smv{m_externel_interrupt}.

The \glspl{csr} can also be written by the CSRRC or CSRRS instructions.
In order to control read- and write-access to the \glspl{csr}, the model knows to constant arrays:
\begin{lstlisting}[language=smv]
__csrs_read_privs := [ 0h_0F, 0h_00 ];
__csrs_write_privs := [ 0h_FF, 0h_FF ];
\end{lstlisting}

These arrays store bitmasks that indicate the least privilege level necessary to read or write the \gls{csr} of the corresponding index at the corresponding bit-position.
For example, all \glspl{csr} besides \gls{mstatus} can be read but but no \gls{csr} can be written by user-mode.
These constants are transformed to the bitmasks \smv{csr_read_mask} or \smv{csr_write_mask} respectively by the per-bit $ b $ implication of $ b \rightarrow \texttt{priv} $ based on the index of the currently targeted \gls{csr}.
Bits of \glspl{csr} are changed by the CSRRS or CSRRC instruction only if \smv{csr_write_mask} is high at the corresponding index with two exceptions:
\begin{itemize}
    \item \gls{mstatus}.MEIP cannot be written by software
    \item Once a \gls{pmpcfg} register has been locked, it cannot be changed anymore
\end{itemize}

The transition relation of the registers and memory is easier to understand.
\smv{regs} changes at index \smv{i} if it is targeted by some instruction and no trap is taken.
Then, \smv{regs[i]} is written with a value determined by the instruction semantics\footnote{%
    This only applies to instructions that \textit{have} semantics targeting registers, i.e. ECALL will not change values of any register.
}.
These per-instruction semantics include considering the \smv{csr_read_mask} bitmask on CSRRS and CSRRC.

\smv{memory} is written at index \smv{i} if it is targeted by the STORE instruction, no trap occurs and the write privilege settings in \gls{pmpcfg} allow the current privilege mode to write the register.
Otherwise \smv{memory} does not change.
It does not mark an error, should the current privilege level not suffice to write the targeted memory address.
No exception will be generated - the memory simply will not be written.
The same is true for read privileges and \smv{regs} on a LOAD.

\subsubsection{Caching}

% TODO: mention that the cache is its own module accessible via \texttt{cache}
The cache spices up transitions of memory and registers and comprises three variables:
\begin{itemize}
    \item \smv{addr : 0..3}
    \item \smv{valid : boolean}
    \item \smv{line : signed word[8]}
\end{itemize}

These variables transition dependent on the cache-configuration of the respective memory region in \gls{pmacfg}.
As already introduced in section \ref{sec:minrv8}, a memory region can be either set as uncacheable, write-back-cacheable or write-through-cacheable.
If a memory region is set as uncacheable, the cache will ignore reads and writes to this region and not make any transition.

\paragraph{Reads}
If a memory region is not set as uncacheable, reads will trigger a cache-fill.
On a LOAD if the cache is invalid or currently holds the contents of a different memory address than targeted, \smv{addr} gets written with \smv{regs[rs1] mod 4}, \smv{valid} becomes \smv{TRUE} and \smv{line} is written with \smv{memory[addr]}.
This process is independent of the current privilege level, e.g. user-mode can cause a cache-fill with memory content in regions that are unreadable to it.
Though, user-mode still won't be able to read the respective word as reads are privileged controlled.

If on a LOAD, however, the cache already held the targeted word an was valid and the current mode suffices to read the respective memory address, \smv{line} instead of \smv{memory[regs[rs1] mod 4]} will be written into register \smv{rd}.

\paragraph{Writes}
From the cache's perspective, writes to regions which are not set uncacheable work the same way, regardless of whether the respective region is set to be write-back-cacheable or write-though-cacheable.
For such a region, on a STORE \smv{line} will be written with \smv{regs[rs2]}, \smv{address} with \smv{regs[rs1] mod 4} and \smv{valid} will become \smv{TRUE}.
However, if the region is set to be write-through-cacheable the write will also be reflected in memory whereas for a write-back-cacheable region the write will be reflected in cache only.

This brings the need to persist writes to the cache in memory when cache lines are evicted.
For example, consider the following program where we assume that \minrv{regs[1] != regs[2]}:
\begin{lstlisting}[language=minrv8]
Store 1, 0  # store regs[0] at memory[regs[1] mod 4]
Load 0, 2   # read memory[regs[2] mod 4] to regs[0]
\end{lstlisting}

If memory region 0 (spanning addresses 0-1) was set to be write-back-cacheable the write in the first line would not be persisted in memory but would happen on cache level only.
If furthermore memory region 1 (spanning addresses 2-3) was not set to be uncacheable, the read in the second line would overwrite changes of the first instruction which is why the cache content must first be written to memory.
Therefore, if the cache holds some non persisted values of write-back-cacheable memory regions and either the cache's target changes or the \gls{pmacfg} attributes change such that the cache is not write-back-cacheable anymore, the content of the cache will be written to memory as well.

\subsubsection{Information Flow Tracking}
\label{sec:ifc-implementation}

In order to implement the information flow tracking semantics as described in section \ref{sec:ifc-model} we define a binary representation of the lattice of security labels given by $ \Sigma $ and $ \sqcup $.
We define $ \binSigma = \{ 00, 01, 10, 11 \}$ with a mapping $ \varphi : \Sigma \rightarrow \binSigma $:
\begin{align*}
    \varphi(\PT) &= 01 \\
    \varphi(\PU) &= 00 \\
    \varphi(\CT) &= 11 \\
    \varphi(\CU) &= 10
\end{align*}

\begin{figure}
    \centering
    \begin{tikzpicture}
        \begin{scope}
            \node (pt) {\PT};
            \node[above right=of pt] (ct) {\CT}
                edge (pt);
            \node[above left=of pt] (pu) {\PU}
                edge (pt);
            \node[above right=of pu] (cu) {\CU}
                edge (ct)
                edge (pu);
        \end{scope}

        \begin{scope}[xshift=0.7cm,draw=gray,text=gray]
            \node (01) {$ 01 $};
            \node[above right=of 01] (11) {$ 11 $}
                edge (01);
            \node[above left=of 01] (00) {$ 00 $}
                edge (01);
            \node[above right=of 00] (10) {$ 10 $}
                edge (11)
                edge (00);
        \end{scope}
    \end{tikzpicture}
    \caption{Security lattice for SecVerilogBL \cite{Ferraiuolo17} with binary equivalent}
    \label{fig:sec-lattice-bin}
\end{figure}

We define $ \sqcup $ on $ \binSigma $ such that $ \varphi $ is an isomorphism.
This mapping is depicted in figure \ref{fig:sec-lattice-bin}.
As you can see, public and untrusted correspond to a 0 whereas confidential and trusted correspond to a 1.
We can formalize this abstraction by examining two equivalence-relations or -classes on $ \Sigma $ and $ \binSigma $.
We define two partitionings $ \Sigma/_{\equiv_C} $ and $ \Sigma/_{\equiv_I} $ on $ \Sigma $ which correspond to equivalence classes modulo confidentiality $ \equiv_C $ or modulo integrity respectively $ \equiv_I $.
\begin{align*}
    \Sigma /_{\equiv_C} &= \big\{ \{ \PU, \PT \}, \{ \CU, \CT \} \big\} \\
    \Sigma /_{\equiv_I} &= \big\{ \{ \PU, \CU \}, \{ \PT, \CT \} \big\}
\end{align*}

We coin the names $ \P = [\PU]_{\equiv_C} $, $ \C = [\CU]_{\equiv_C} $, $ \U = [\PU]_{\equiv_I} $ and $ \T = [\PT]_{\equiv_I} $ and lift $ \sqcup $ to be defined on equivalence-classes in the usual fashion, i.e. $ [x] \sqcup [y] = [x \sqcup y] $.
Note, that $ \P \preceq \C $ and $ \T \preceq \U $ with $ \preceq $ again being the partial order inferred from $ \sqcup $ and that it is possible to define $ \sqcup $ by solely working with these equivalence classes:
\begin{equation*}
    \{ x \sqcup y \} = \big(([x]_{\equiv_C} \sqcup [y]_{\equiv_C}) \cap ([x]_{\equiv_I} \sqcup [y]_{\equiv_I}) \big)
\end{equation*}

\begin{example}
    \begin{align*}
        \{ \PU \sqcup \CT \} &= \big(([\PU]_{\equiv_C} \sqcup [\CT]_{\equiv_C}) \cap ([\PU]_{\equiv_I} \sqcup [\CT]_{\equiv_I}) \big) \\
        &= \big((\P \sqcup \C) \cap (\U \sqcup \T) \big) \\
        &= (\C \cap \U) \\
        &= \{ \CU \}
    \end{align*}
\end{example}

This means that we can track the labels of the lattice of security labels $ \Sigma $ by tracking the confidentiality and integrity labels individually.
We also find this dealing with labels much more intuitive:
\begin{itemize}
    % TODO: rewrite this
    \item Two sources of information combined are considered to be confidential if \textit{any} of the sources is confidential itself.
    This is sensible as with some result of an operation at least partial information about its confidential source can be inferred if the other public source and the operation are known.
    \item Two sources of information combined are considered to be trustworthy if \textit{both} of the sources are trustworthy themselves.
    This is intuitive as well.
    We assume that non-trustworthy sources of information are controlled by an attacker.
    We can only say about some piece of information to be trustworthy if we can ensure that the attacker can't control it in any way, shape or form.
    This is only given if both of the sources of an operation are not controlled by an attacker, i.e. is trustworthy.
\end{itemize}

The intuition behind $ \sqcup $ as described above perfectly matches $ \binSigma $ as well.
Recall, that \C{} is represented by a 1 and \P{} by a 0 in the binary representation.
That means that two labels $ a = a_Ca_I \in \binSigma $ and $ b = b_Cb_I \in \binSigma $ are in \C{}, i.e. confidential, if $ a $ or $ b $ is confidential, i.e. if \textit{one} of the bits representing the confidentiality of the labels is high, i.e. if $ a_C \lor b_C $.
In turn, these two labels are in $ \T $, i.e. trusted, if $ a $ and $ b $ are trusted, i.e. if \textit{both} of the bits representing the integrity of the labels are high, i.e. if $ a_I \land b_I $.
This allows us to define $ \sqcup $ on $ \binSigma $ again - this time not just semantically:
\begin{equation*}
    a_C a_I \sqcup b_C b_I = (a_C \lor b_C) \cdot (a_I \land b_I)
\end{equation*}

In summary, these paragraphs showed to things:
\begin{enumerate}
    \item We are able to store the security labels of information independently of each other and do not need to work with the full lattice itself.
    It is sufficient to deal with equivalence classes which can be inferred from individual bits.
    \item The $ \sqcup $ operation on the binary representation of the security labels $ \binSigma $ can be implemented by deriving the the confidentiality label by or-ing and the integrity label by and-ing the old labels.
\end{enumerate}

This allows us now to add security label tracking to our model whereby we will track the confidentiality and the integrity of values.
We assign labels on a per bit basis to all values in registers, memory, \glspl{csr} and the cache.
For each variable in the model we add an confidentiality or integrity tracking counterpart as (arrays of) unsigned word; find an overview of all such variables in table \ref{tbl:ifc-vars}.

\begin{table}
    \centering
    \begin{tabular}{| c | c | c |}
        \hline
        \textbf{Variable} & \textbf{Confidentiality Tracking} & \textbf{Integrity Tracking} \\
        \hline
        {\smv{regs}} & {\smv{regs_conf}} & {\smv{regs_integrity}} \\
        {\smv{memory}} & {\smv{memory_conf}} & {\smv{memory_integrity}} \\
        {\smv{csrs}} & {\smv{\_\_csrs_conf}} & {\smv{\_\_csrs_integrity}} \\
        {\smv{cache.line}} & {\smv{cache.conf}} & {\smv{cache.integrity}} \\
        \hline
    \end{tabular}
    \caption{Information Flow Control Variables}
    \label{tbl:ifc-vars}
\end{table}

These variables transition under the same circumstances as their base variable does, e.g. \smv{regs_conf} does a transition if and only if \smv{regs} transitions and \smv{regs_conf} will deduct its content from sources parallel the those of \smv{regs}.
The values themselves change based on the current instruction and its information flow tracking semantics as described in \ref{sec:ifc-model}.
% TODO: explain why this is the case
The only exception to this is the information flow tracking of the variable \smv{csrs} the labels of which do not change at all.

In other words, the \smv{*_conf} and \smv{*_integrity} variables perfectly mirror the architecture implementation as described in \ref{sec:model-implementation}.
Rather than simply simulating the MINRV8 architecture in nuXmv we also track the confidentiality-world and integrity-world of this architecture in parallel to simulating the pure computational-world.

\subsection{Scope of the Model}
\label{sec:model-scope}

In summary, the MINRV8 architecture knows three groups of instructions (cf. table \ref{tbl:min-arch-instrs}):
\begin{itemize}
    \item Computational instructions such as MOV, AND, ADD, etc.
    \item Memory instructions LOAD and STORE
    \item System instructions ECALL, MRET, CSRRS, CSRRC
\end{itemize}

MINRV8 is meant to be a reasonable abstraction of a real-world \gls{riscv} architecture from a security standpoint.
However, up to this point nothing has been said about the limits of this abstraction.
With every abstraction, there is a small chance that it perfectly matches the concept that has been abstracted but in most cases, some corners are cut.
In this section, we will reflect on the limits of the MINRV8 architecture and its implementation.

% TODO: mention that other fields are well modelled
% TODO: mention that we actually don't need all computational instructions
% TODO: mention performance hit of dynamic memory regions

A reader, experienced in the field of microcontrollers or computer-architecture in general might wonder why our model does not include:
\begin{enumerate}
    \item Executable memory and a \gls{pc}
    \item Jump or branch instructions
    \item A model of a stack pointer
\end{enumerate}

In the introduction of the MINRV8 architecture in section \ref{sec:minrv8} we mentioned that the idea of the architecture was tightly coupled to its implementation.
The design of the model had to answer the question: How can a stream of instructions be implemented?
nuXmv allows to think of the following options:
\begin{enumerate}
    \item \label{itm:exmem-frozen}
    Use \smv{FROZENVAR}s to model executable memory - a \smv{FROZENVAR} is something like a constant in other programming languages but without a fixed value.
    nuXmv chooses the value on the first simulation step but does not change it afterwards.
    This is more efficient than using plain \smv{VAR}s with no transitions.
    \item \label{itm:exmem-var}
    Use \smv{VAR}s to model executable memory.
    In practice, this would mean that the memory of the implementation as described in section \ref{sec:model-implementation} would be much larger than the current 4 bytes.
    \item \label{itm:exmem-ivar}
    Finally, use \smv{IVAR}s to model the stream of instruction.
    This is the option we decided to go for as described in section \ref{sec:model-implementation}.
    Using \smv{IVAR}s means that there is no model of executable memory.
    % TODO: is the part about the ALU actually true?
    Instead, the input variables provided to the implementation model the result of an instruction decoder that hands the \gls{alu} the ready-to-use decoded instructions on each transition of the simulated model.
    As such, the architecture does not need to worry \textit{where} these instructions come from.
\end{enumerate}

\subsection{Trustworthiness of the Model}
