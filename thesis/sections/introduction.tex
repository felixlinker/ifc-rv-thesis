%!TEX root = ../thesis.tex

\section{Introduction}
\label{sec:introduction}

This thesis is in the realm of formal verification, i.e. the attempt to verify a system by the use of formal methods such as SAT solvers, interactive theorem provers and model checkers.
With these tools, formal verification engineers strive to prove the correctness of systems such as general computer programs, \glspl{os}, compilers or hardware designs.
Often times, for a system to be correct means that it complies with a specification.
Formal verification of a system then is the attempt to prove that some system is free of errors, i.e. meets all properties imposed by some specification.
\enquote{Specification} here might reference to large documents specifying standards of the industry, but it might also refer to more abstract properties like the absence of memory leaks or race conditions in parallel programming.
Thus, formal verification complements testing.
The relation between these two approaches often is illustrated by a famous quote of Edsger Dijkstra:
\begin{displaycquote}[p.6]{Dijkstra72}
    Program testing can be used to show the presence of bugs, but never to show their absence!
\end{displaycquote}

Whereas testing is a quick and efficient way of finding bugs in the development process of a system, formal verification is a more complex but complete (in regard to the properties verified) process of proving the absence of bugs.

In \citetitle{Reid17} \cite{Reid17}, \citeauthor{Reid17} stressed the need of verifying specifications themselves as opposed to simply verifying implementations against specifications.
To tackle this, he proposed to verify specifications against higher level properties and used this methodology to verify the specification of the ARM M-Class specification.
In this thesis, two lines of his research will be continued: \begin{enumerate*}[label=\alph*)]
    \item the main contribution of this thesis also is to propose an approach for verifying specifications against higher level properties and
    \item this methodology will be applied to an \gls{isa} specification as well.
\end{enumerate*}

The higher level properties an \gls{isa} will be verified against, mainly stem from the work of \citeauthor{Ferraiuolo17} in \citetitle{Ferraiuolo17} \cite{Ferraiuolo17}.
As the title indicates, their work also falls into the domain of verification; the authors propose a new way of verifying \gls{hdl} implementations.
The core idea here is to use a a type system in which types serve as security annotation of information.
By applying typing rules to expressions in the \gls{hdl} code, these annotations are forwarded and thus information is tracked through the code.
Certain type conversions are, however, prohibited and mark a security vulnerability.
Thus, their approach can be summarized as tracking and controlling information flow in \gls{hdl} code.
The authors evaluate their approach by applying it to the implementation of the ARM TrustZone extension.
In this thesis, the idea of tracking and controlling information flow as proposed in \cite{Ferraiuolo17} will be lifted to the level of the \gls{isa} specification thus following the line of research as proposed in \cite{Reid17}.

We claim that this approach is
\begin{itemize}
    \item viable, i.e. the hardware requirements are low and the work can be reproduced with limited time investment,
    \item relevant, i.e. the approach successfully uncovers issues in architectures, and
    \item supplemental, i.e. it enhances on related work such as \cite{Reid17}.
\end{itemize}

This new approach will be applied to the RISC-V architecture using the model checker nuXmv.
RISC-V is a modern and open-source \gls{isa} that has first been published in 2011 \cite{RiscVISA-org}.
A basic architecture that orientates itself by the RISC-V architecture will be modelled in nuXmv.
nuXmv is a general purpose model checker that supports different specification languages and verification algorithms.
Using nuXmv allows for enhancing on the approach proposed by \citeauthor{Reid17} in a key aspect:
In his work, \citeauthor{Reid17} focused on higher lever properties to verify the ARM \gls{isa} against that were limited to making specifications about a single transition of the processor only, i.e. that only take the pre- and post-state of a single cycle of the processor into account.
nuXmv on the other hand allows to consider infinite sequences of instructions, i.e. sequences of processor-transitions, of unbounded length.

This thesis is structured as follows:
In section \ref{sec:background}, the background of this thesis will be introduced.
This includes both key papers of \citeauthor{Reid17} and \citeauthor{Ferraiuolo17} as well as \glspl{isa} and model checkers.
An introduction to \gls{risc} architectures and their ecosystem will be discussed concluding with a threat model for this thesis.
After this, model checkers will be explained.
At the end of this section, the methodology of this thesis will be discussed in more detail.

In section \ref{sec:arch}, the RISC-V architecture and a new, minimal, RISC-V-inspired architecture called MINRV8 will be introduced.
Following up on this, it will be described how the MINRV8 architecture was implemented in nuXmv.

Section \ref{sec:ifc} details what an information flow tracking means for an \gls{isa}, how specifically it can be applied to MINRV8, and how it was implemented in nuXmv, i.e. it will be discussed how we applied the work of \citeauthor{Ferraiuolo17} \cite{Ferraiuolo17} to \glspl{isa}.

Section \ref{sec:checking} then defines the higher level properties that implement information flow control for the MINRV8 architecture.
Furthermore it will be discussed, how nuXmv was used to verify these properties.

The evaluation of our approach is given in section \ref{sec:results}-\ref{sec:conclusion}.
First, the results of the verification process will be presented in section \ref{sec:results}.
These results will then be discussed in section \ref{sec:discussion}.
In section \ref{sec:related-work} the results and the approach in general will be compared to related work and in section \ref{sec:conclusion}, a final conclusion will be given.

