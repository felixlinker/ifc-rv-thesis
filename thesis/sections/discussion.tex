%!TEX root = ../thesis.tex

\section{Discussion}
\label{sec:discussion}

% TODO: Say that our properties only restrict machine-mode
% TODO: Say that we meet Alastair's requirements
% TODO: \glspl{ifc}
In section \ref{sec:checking}, a set of IFC properties based on the work in \cite{Ferraiuolo17} has been introduced; we will refer to these properties as the set $ P $.
These properties were model checked in the previous section \ref{sec:results}, the result of which was a set of rules $ R $.
What is the consequence of this?
The formal achievement of this thesis can be summarized as follows:
\begin{quote}
    It can be guaranteed that programs running on the MINRV8 architecture, e.g. \glspl{os}, are \textit{secure} (in the sense of not violating the IFC properties $ P $) if they obey to the rules $ R $.
\end{quote}
But what does \enquote{secure} mean here besides not violating $ P $?
What is the \textit{actual} sense of security that can be guaranteed?

Nothing definite can be said in answer to this question.
However, the canaries these properties have been tested against in section \ref{sec:canaries}, exemplify the class of vulnerabilities that are covered by these properties.

Assessing the results of the approach to formally verify higher level properties of the MINRV8 architecture shall be subject of this section.
We will cover three aspects of our work:
\begin{itemize}
    \item Scope, i.e. what are the limits of our results,
    \item Trustworthiness, i.e. whether our results are sound, and
    \item General observations.
\end{itemize}

\subsection{Scope}
\label{sec:scope}

\subsubsection{Architecture}

MINRV8 is meant to be a reasonable abstraction of a real-world \gls{riscv} architecture from a security standpoint.
However, up to this point nothing has been said about the limits of this abstraction.
With every abstraction, there is a small chance that it perfectly matches the concept that has been abstracted in regard to the purpose of the abstraction but in most cases, some corners are cut.
In this section, we will reflect on the limits of the MINRV8 architecture and its implementation.

% TODO: mention that other fields are well modelled
% TODO: mention that we actually don't need all computational instructions
% TODO: mention performance hit of dynamic memory regions

In summary, the MINRV8 architecture knows three groups of instructions (cf. table \ref{tbl:min-arch-instrs}):
\begin{itemize}
    \item Computational instructions such as \minrv{Mov}, \minrv{And}, \minrv{Add}, etc.
    \item Memory instructions \minrv{Load} and \minrv{Store}
    \item System instructions \minrv{Ecall}, \minrv{Mret}, \minrv{Csrrs}, \minrv{Csrrc}
\end{itemize}

A reader, experienced in the field of microcontrollers or computer-architecture in general might wonder why our model does not include:
\begin{enumerate}
    \item Executable memory and a \gls{pc}
    \item Jump or branch instructions
\end{enumerate}

The reason for both of these points lies in the implementation of the model.
In the introduction of the MINRV8 architecture in section \ref{sec:minrv8} we mentioned that the idea of the architecture was tightly coupled to its implementation in \gls{nuxmv}.
The design of the model had to answer the question: How can a stream of instructions be implemented?
nuXmv allows to think of the following options:
\begin{enumerate}
    \item \label{itm:exmem-frozen}
    Use \smv{FROZENVAR}s to model executable memory - a \smv{FROZENVAR} (frozen variable) is something like a constant in other programming languages but without a fixed value.
    nuXmv chooses the value on the first simulation step but does not change it afterwards.
    This is more efficient than using a plain \smv{VAR} and constraining it to not change, e.g. \smv{TRANS x = next(x);}.
    \item \label{itm:exmem-var}
    Use \smv{VAR}s to model executable memory.
    In practice, this would mean that the memory of the implementation as described in section \ref{sec:model-implementation} would be much larger than the current 4 bytes.
    \item \label{itm:exmem-ivar}
    Finally, use \smv{IVAR}s to model the stream of instruction.
    This is the option we decided to go for as described in section \ref{sec:model-implementation}.
    Using input variables means that there is no model of executable memory.
    Instead, the input variables provided to the implementation model a stream of a fully decoded instruction on each transition of the simulated model.
    As such, the architecture does not need to worry \textit{where} these instructions come from.
\end{enumerate}

The decision towards using input variables as a model of the stream of instructions was made because of two reasons:
\begin{enumerate*}[label=\alph*)]
    \item in the prototyping phase of the model, it was quickly found out that using input variables led to significant boosts in performance, and
    \item using input variable simplified the implementation significantly.
\end{enumerate*}
Having used purely either frozen variables or variables would have increased the size of the state space to be traversed by \gls{nuxmv} and would have introduced the necessity to implement instruction decoding increasing the complexity of the transition relation.
Furthermore, it would not have allowed for unbounded model checking of the architecture since the size of programs to be taken into consideration would have been bounded by the size of executable memory.

Yet, using input variables also has some downsides.
First and foremost, using input variables means that it is pointless to model a \gls{pc} or anything address related like return addresses, a dedicated \gls{lr} or \glspl{csr} such as \gls{mtvec} as without a model of executable memory there is nothing addresses could point to.
Instead, instructions will simply magically appear on each cycle of the processor model.
This means that the simulation is inaccurate in this regard which in itself is not a problem.
The model is supposed to be an abstraction.
Since it was decided to use input variables over a model of the \gls{mtvec} register and a \gls{pc}, the question now arises how accurately the implementation of the MINRV8 architecture is capable to simulate real architectures.
In a nutshell, the use of input variables over (frozen) variables introduces a certain sense of non-determinism to the model of the MINRV8 architecture when it comes to handling interrupts and exceptions.

\begin{figure}
    \centering
    \includegraphics[width=0.7\textwidth]{figures/interrupt-flow.png}
    \caption{Program flow involving interrupts}
    \label{fig:interrupt-flow}
\end{figure}

Consider an example memory layout for the \gls{riscv} architecture as depicted in figure \ref{fig:interrupt-flow} where code is executed from left to right starting with an \minrv{Ecall} instruction.
Executing this instruction triggers a shift in control to machine-mode which jumps to address \minrv{X} pointed to by the \gls{mtvec} register.
Then, the instructions at addresses \minrv{X} to \minrv{Z} and subsequent ones are executed until finally, a \minrv{Mret} instruction is read an executed which triggers a jump to address \minrv{A}.
Two instructions later, another \minrv{Ecall} instruction is executed, etc.
We would expect the order of instructions to be executed to look like:

\begin{enumerate}
    \item First environment call: \lstinline[language=minrv8,mathescape=true]{Ecall, Load, Add, Store, $\dots$, Mret}
    \item Return: \lstinline[language=minrv8,mathescape=true]{Load, Mov}
    \item Second environment call: \lstinline[language=minrv8,mathescape=true]{Ecall, Load, Add, Store, $\dots$, Mret}
    \item Second return: \lstinline[language=minrv8,mathescape=true]{Slt, $\dots$}
\end{enumerate}
Where \minrv{Load, Add, Store} are the instructions located at addresses \minrv{X} to \minrv{Z} and \minrv{Load, Mov, Slt} the instructions located at addresses \minrv{A}, \minrv{B} and \minrv{C} respectively.

As input variables can not be constrained in \gls{nuxmv}, there is no way to model that the instructions being executed on a trap always are equal, i.e. a valid stream of instructions as a sequence of input variable valuations to the model might be:
\begin{enumerate}
    \item First environment call: \lstinline[language=minrv8,mathescape=true]{Ecall, Load, Add, Store, $\dots$, Mret}
    \item Return: \lstinline[language=minrv8,mathescape=true]{Load, Mov}
    \item Second environment call: \lstinline[language=minrv8,mathescape=true]{Ecall, And, Sra, $\dots$, Mret}
    \item Second return: \lstinline[language=minrv8,mathescape=true]{Slt, $\dots$}
\end{enumerate}

Such a stream of instructions is not realistic without some program modifying the code located at \gls{mtvec} and as such \enquote{shouldn't} be considered when checking the IFC properties.
One would expect to find the same code after an \minrv{Ecall} instruction being executed since in both cases, an architecture would jump to the respective interrupt handler.
However, there of course also exists a sequence of input variable valuations that exactly match a \enquote{real} stream of instructions where the instructions executed after an environment call coincide.

This illustrates one example for why the implementation of the MINRV8 \textit{abstracts} from real architectures.
In regard to program flow on traps, it can be expected that the model accurately comprises all expected streams of instructions but also includes many more one would naturally consider to be unrealistic.

The second concept, the abstract implementation of the MINRV8 architecture is missing are jump an branch instructions.
They are missing for the exact same reasons as described in the previous paragraphs.
Since the implementation does not support executable memory and as such does not support addresses, jumps and branches are pointless instructions.
This, however, does not turn out to be a fundamental problem.
In principle, jump and branch instructions in real systems are security relevant since they are used to perform function calls and returns and implement loops or conditional statements.
% TODO: \gls{rop}
In practice though, jumps and branches usually are security relevant since they are targeted by adversarial programs trying to manipulate jump addresses to launch ROP attacks.
ROP attacks are only effective because they jump to locations where critical code is located.
It does not matter whether the critical code is executed without the intervention of some malicious program or whether some malicious program tricks privileged code into executing said critical code - in practice, the former case simply occurs rarely.
The concept of jumps being influenced by some malicious program is, however, captured in approach: both properties \ref{itm:prop-mem-i} and \ref{itm:prop-csr-i}, i.e. the integrity of memory- and \gls{csr}- related instruction, ensure that certain instructions may not be influenced by user-mode.
There is no reason to assume that user-mode would control jumps and branches by fundamentally different flows of information than memory- and \gls{csr}-related instructions, i.e. jump related vulnerabilities are covered in principle.

Additionally, our implementation might not be able to model programs including jumps and branches but the set of programs considered by \gls{nuxmv} does include those where jumps have been linearized\footnote{%
    This is similar to function inlining supported by many compilers.
}.
Consider figure \ref{fig:jump-inlining} where in the upper half depicts an ordinary program, being executed from left to right and including jump instructions.
Jump linearization here means that for any such program there also exists another (potentially infinite) program where no jumps occur but the same instructions besides jumps are being executed.
The respective counterpart to the program in the upper half is depicted in the lower half of figure \ref{fig:jump-inlining}.
The sequence of states generated by the linearized programs is equal to the sequence of states of the non-linearized program modulo \gls{pc} values - which is not modelled in \gls{nuxmv} anyways.

\begin{figure}
    \centering
    \includegraphics[width=0.7\textwidth]{figures/jump-free-programs.png}
    \caption{Jump linearization}
    \label{fig:jump-inlining}
\end{figure}

\paragraph{Summary}

Starting with the premise of this thesis, it was always clear that the MINRV8 architecture is a simplification.
This, though, is not a problem since by focusing on the very core, security related instructions allowed us to implement a tractable and small model in \gls{nuxmv}.
If one would add jump and branch instructions to the MINRV8 architecture, it'd be comparable to actual \gls{riscv} architectures.
From this point of view, it is not a problem to apply the results of the verification process, i.e. the set of assumptions, to the \gls{riscv} architecture.

The implementation of the MINRV8 architecture abstracted from real-world architectures in two main points:
\begin{enumerate}
    \item \gls{nuxmv} does not guarantee stable behavior on \minrv{Ecall} instructions; this introduces a sense of non-determinism for which there are more programs considered by \gls{nuxmv} than could actually be run on the MINRV8 architecture.
    This is not problematic because overabstracting the space of all programs $ P $ still leaves \gls{nuxmv} considering all programs in $ P $.
    \item The implementation does not support jump or branch instructions.
    This is not problematic because
    \begin{enumerate*}[label=\alph*)]
        \item flows of information relevant to jump and branch instructions are still covered by the integrity properties \ref{itm:prop-mem-i} and \ref{itm:prop-csr-i} and
        \item programs including jumps can be linearized; such programs \textit{are} considered by \gls{nuxmv}.
    \end{enumerate*}
\end{enumerate}

This leaves us with good reasons to assume that programs considered by \gls{nuxmv}, i.e. the set of programs quantified over when running proofs, is sufficiently close to the set of \enquote{real} programs of the MINRV8 architecture including jumps and branches.
% TODO: Future work?

\subsubsection{Assumptions}

% TODO: Mention these goals in introduction/background

The goal we had in mind when phrasing the assumptions which ultimately established the correctness of the information flow properties was for them to be realistic.
This goal includes:
\begin{enumerate}
    \item \label{itm:assumptions-non-trivial}
    The assumptions must be non-trivial, i.e. they must not be contradictory and must not trivially entail the information flow properties to be verified,
    \item \label{itm:assumptions-machine-mode}
    the assumptions must only constrain machine-mode,
    \item \label{itm:assumptions-verifiable}
    the assumptions must be decidable and verifiable.
\end{enumerate}

The reasoning behind point \ref{itm:assumptions-non-trivial} is straight-forward:
Trying to prove \enquote{$ \text{false} \Rightarrow \text{properties} $} or \enquote{$ \text{properties} \Rightarrow \text{properties} $} is pointless.
Although we can't give formal proofs that neither is the case, we have good reasons to believe it.
Recall that we were able to prove that \enquote{$ \text{assumptions} \Leftrightarrow \text{properties} $}.
In this case, the assumptions can only be contradictory if the properties are as well which we think, they are obviously not.
On the other hand, recall that in section \ref{sec:canaries} we were able to make changes to the architecture such that \enquote{$ \neg(\text{assumptions} \Rightarrow \text{properties}) $} held.
This indicates clearly that the assumption actually express something meaningful and do not trivially entail the information flow properties.

Point \ref{itm:assumptions-machine-mode} also is met by the assumptions introduced in section \ref{sec:assumptions}.
Whenever it is said that certain instructions must not be executed under certain circumstances, these formulas are guarded by the antecedent \smv{priv ->}.
Additionally, all other assumptions only constrain state transitions that are under control of machine-mode only, such as changes to \glspl{csr} or state before machine-mode hands back control to user-mode.
All in all, this point does not need to be discussed extensively.
However, it was raised nonetheless because it is important to note that the assumptions introduced as a result of this thesis fit in the threat model as discussed in section \ref{sec:threat-model}.
Recall, that in context of this thesis it is assumed that user-mode is adversarial to machine-mode and compromised completely.
Constraining user-mode in the assumptions therefore would have contradicted this threat model.

Lastly, the most critical point is point \ref{itm:assumptions-verifiable}.
Ideally, the assumptions established in context of this thesis would serve as a verification target for \glspl{os} or compilers.
If one was to write a collection of interrupt handlers for an \gls{os}, one might want to check that all 8 assumptions are implemented by these.
This would grant the absence of information flow related bugs in context of the information flow properties as proposed in section \ref{sec:checking}.
This, however, presupposes that it is actually possible to verify programs against these properties.
As part of this thesis, we cannot give guarantees on the feasibility of this undertaking.
Yet, we tried to allow for it.
Meeting point \ref{itm:assumptions-machine-mode} is one step in the right direction.
However, how these simplified properties might be transferred to real-world system is an open question.
The problems behind this are illustrated by the \smv{SP_BANK} assumption introduced parallel to the SYSRET vulnerability in section \ref{sec:sysret}.
There are two aspects of the first part of this assumption which are noteworthy.
The relevant part of the \smv{SP_BANK} assumption is given in snippet \ref{snpt:sp-bank-p1}.

\begin{figure}
    \begin{lstlisting}[
        language=smv,
        caption={First part of the assumption \lstinline{SP_BANK}},
        label={snpt:sp-bank-p1}
    ]
        G (!priv & X priv -> X ( (*\label{ln:sp-call-priv}*)
            (priv -> !(op in { PUSH, POP }))
            U ((op = MRET & MPP = 0b_0) | sp[sp_sel] < $REGION0_SIZE (*\label{ln:sp-call-mret}*)
                ? !pmpcfg0.write & !pmpcfg0.read
                : !pmpcfg1.write & !pmpcfg1.read)
        )) &
    \end{lstlisting}
\end{figure}

Whilst working on this assumption, we found that the specific implementation of two \textit{ideas} was critical to the presence of the SYSRET vulnerability, both:
\begin{enumerate}
    \item \label{itm:no-sysret-priv}
    replacing the expression \smv{!priv & X priv} in line \ref{ln:sp-call-priv} by \smv{(op = ECALL) | (bool(MIE) & bool(MEIP))} which is the actual condition under which a trap is taken and
    \item \label{itm:no-sysret-mret}
    omitting the expression \smv{(op = MRET & MPP = 0b_0)} in line \ref{ln:sp-call-mret}
\end{enumerate}
led to \gls{nuxmv} not finding the SYSRET vulnerability.
Why is that?

The first part of the \smv{SP_BANK} assumption states: \enquote{Whenever there is a switch from user- to machine-mode, latter can only use the \minrv{Push} or \minrv{Pop} instructions after having returned to user-mode or having ensured that the stack-pointer is safe}.
If the antecedent of this assumption would have been replaced by: \enquote{Whenever a trap is taken, \dots}, i.e. by \smv{(op = ECALL) | (bool(MIE) & bool(MEIP))}, the consequent would also have applied to cases where a trap was taken from machine-mode to machine-mode\footnote{
    Furthermore, it is noteworthy that the antecedent in the original assumption resembles a more result-driven approach to phrasing properties, i.e. talk about \textit{what} is happening, whereas the alternative disucssed here resembles a more architecture-driven approach, i.e. talk about \textit{when} things are happening.
    The discussion, which of these approaches should be preferred is a topic on its own.
    In this thesis, we used both approaches but tried to stick to the result-driven approach whenever possible to keep the assumptions concise.
    In certain situations, however, it was more practical to go for the architecture-driven approach.
}.
Such a trap is necessary to interrupt machine-mode from properly returning to user-mode while already having set the stack-pointer back to user-mode.
The consequent also applying to traps from machine- to machine-mode in context of the MINRV8 architecture boils down to machine-mode ensuring that the proper stack-pointer is setup correctly on \textit{all} traps rendering the SYSRET vulnerability impossible.
For example, the \glspl{os} being affected by the SYSRET vulnerability clearly did not set the stack-pointer on \textit{all} execution paths of the trap handler for the general protection fault.

The condition \smv{(op = MRET & MPP = 0b_0)} on the right-hand side of the \smv{U}-expression in line \ref{ln:sp-call-mret} equals telling machine-mode: \enquote{You can forget about not using the \minrv{Push} and \minrv{Pop} instructions after you have \textit{attempted} to return control to user-mode}.
For the same reasons as stated above, this part is critical.
Leaving this expression out would equal machine-mode having state persistent over user-mode-calls and -returns to and from machine-mode, by which machine-mode memorizes whether it has set the stack-pointer to user-mode or to machine-mode.
With such a mechanism in place, machine-mode could not be fooled into using the user-mode stack-pointer on any trap handler since it would first check this state.

These two examples stress that the precise phrasing of the assumptions is highly critical for both how realistic the assumptions are and how well they might be suited to serve as target for verification of actual code-bases.
While it would be sufficient to find a stronger precondition for these assumptions in existing code-bases, it is non-trivial whether such preconditions are easy to find or whether the assumptions might be rephrased such that they still grant the absence of information flow related bugs but are easier to verify in programs.
This topic, though, can't be handled as part of this thesis leading to future work.

\subsection{Trustworthiness}

\subsubsection{Model}

\subsubsection{Verification Process}
