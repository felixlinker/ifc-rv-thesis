
#define XLEN 8
#define REGION0_SIZE 2

#define least_one_extended(w) \
    (0h_00 < (w & 0h_FF) \
        ? (0h_00 < (w & 0h_0F) \
            ? (0h_00 < (w & 0h_03) \
                ? (0h_00 < (w & 0h_01) ? 0h_FF : 0h_FE) \
                : (0h_00 < (w & 0h_04) ? 0h_FC : 0h_F8) \
            ) \
            : (0h_00 < (w & 0h_30) \
                ? (0h_00 < (w & 0h_10) ? 0h_F0 : 0h_E0) \
                : (0h_00 < (w & 0h_40) ? 0h_C0 : 0h_80) \
            )) \
        : 0h_00)

#define clamp(v, l, h) (min(max((v), l), h))

MODULE cache_line(main_module)
    VAR
        addr : 0..3;
        valid : boolean;
        line : signed word[XLEN];
        conf : unsigned word[XLEN];
        integrity : unsigned word[XLEN];

    DEFINE
        __can_cache_read := (main_module.rs1 < REGION0_SIZE
            ? !main_module.pmacfg0.uncached
            : !main_module.pmacfg1.uncached);
        __can_cache_write := (main_module.rd < REGION0_SIZE
            ? main_module.pmacfg0.write_back | main_module.pmacfg0.write_through
            : main_module.pmacfg1.write_back | main_module.pmacfg1.write_through);
        __read_hit := main_module.rs1 = addr;
        __write_hit := main_module.rd = addr;
        __read := (__read_hit & valid ? line : main_module.memory[main_module.rs1]);
        __read_conf := (__read_hit & valid
            ? conf
            : main_module.memory_conf[main_module.rs1]);
        __read_integrity := (__read_hit & valid
            ? integrity
            : main_module.memory_integrity[main_module.rs1]);

        __op := main_module.op;
        __rd := main_module.rd;
        __rs1 := main_module.rs1;

    INIT valid = FALSE;

    TRANS next(valid) = case
        main_module.do_trap: valid;
        __op = LOAD & main_module.can_load: __can_cache_read;
        __op = STORE & __write_hit & main_module.can_write: __can_cache_write;
        TRUE: valid;
    esac;

    TRANS next(addr) = case
        main_module.do_trap: addr;
        __op = LOAD & __can_cache_read & main_module.can_load: __rs1;
        __op = STORE & __can_cache_write & __write_hit & main_module.can_write: __rd;
        TRUE: addr;
    esac;

    #define trans(read_source, write_source, default) \
        (case \
            main_module.do_trap: default; \
            __op = LOAD & __can_cache_read & main_module.can_load: read_source[__rs1]; \
            __op = STORE & __can_cache_write & __write_hit & main_module.can_write: \
                write_source[__rs1]; \
            TRUE: default; \
        esac)

    TRANS next(line) = trans(main_module.memory, main_module.regs, line);
    TRANS next(conf) = trans(
        main_module.memory_conf,
        main_module.regs_conf,
        conf
    );
    TRANS next(integrity) = trans(
        main_module.memory_integrity,
        main_module.regs_integrity,
        integrity
    );

MODULE pmpcfg_module(base_reg)
    DEFINE
        locked := bool(base_reg[3:3]);
        execute := bool(base_reg[2:2]);
        write := bool(base_reg[1:1]);
        read := bool(base_reg[0:0]);

MODULE pmacfg_module(base_reg)
    DEFINE
        uncached := base_reg[1:0] = 0b_00;
        write_through := base_reg[1:0] = 0b_01;
        write_back := base_reg[1:0] = 0b_10;
        write_protected := base_reg[1:0] = 0b_11;

MODULE main
    VAR
        priv : boolean;
        csrs : array 0..1 of unsigned word[XLEN];
        regs : array 0..3 of signed word[XLEN];
        regs_conf : array 0..3 of unsigned word[XLEN];
        regs_integrity : array 0..3 of unsigned word[XLEN];
        memory : array 0..3 of signed word[XLEN];
        memory_conf : array 0..3 of unsigned word[XLEN];
        memory_integrity : array 0..3 of unsigned word[XLEN];
        cache : cache_line(self);
        mesp : signed word[XLEN];
        mesp_conf : unsigned word[XLEN];
        mesp_integrity : unsigned word[XLEN];

    DEFINE
        __csrs_read_privs := [ 0h_0F, 0h_00 ];
        __csrs_write_privs := [ 0h_FF, 0h_FF ];
        __priv_vec := (priv ? 0h_FF : 0h_00);
        __csrs_conf := [ 0h_0F, 0h_00 ];
        __csrs_integrity := [ 0h_FF, 0h_FF ];
        mstatus := csrs[0];
        pmacfg := mstatus[7:4];
        pmpcfg := csrs[1];

    -- Initialize mstatus to have interrupts enable and nothing else
    INIT mstatus = 0b_00000110;
    --            0b_reg1_reg0

    DEFINE
        __mstatus_high_guard := 0b_00001000;
        __mstatus_low_guard := 0b_11110111;
        MPP := mstatus[0:0];
        MPIE := mstatus[1:1];
        MIE := mstatus[2:2] | word1(!priv);
        MEIP := mstatus[3:3];

        do_trap := (op = ECALL) | (bool(MIE) & bool(MEIP));

    VAR
        pmpcfg0 : pmpcfg_module(pmpcfg[3:0]);
        pmpcfg1 : pmpcfg_module(pmpcfg[7:4]);
        pmacfg0 : pmacfg_module(pmacfg[1:0]);
        pmacfg1 : pmacfg_module(pmacfg[3:2]);

    DEFINE
        __init_high := [ 0h_FF, 0h_FF, 0h_FF, 0h_FF ];
        __init_low := [ 0h_00, 0h_00, 0h_00, 0h_00 ];
    INIT priv <-> regs_integrity = __init_high;
    INIT !priv <-> regs_integrity = __init_low;
    INIT priv <-> regs_conf = __init_high;
    INIT !priv <-> regs_conf = __init_low;
    INIT !pmpcfg0.read <-> memory_conf[0] = 0h_FF & memory_conf[1] = 0h_FF;
    INIT pmpcfg0.read <-> memory_conf[0] = 0h_00 & memory_conf[1] = 0h_00;
    INIT !pmpcfg0.write <-> memory_integrity[0] = 0h_FF & memory_integrity[1] = 0h_FF;
    INIT pmpcfg0.write <-> memory_integrity[0] = 0h_00 & memory_integrity[1] = 0h_00;
    INIT !pmpcfg1.read <-> memory_conf[2] = 0h_FF & memory_conf[3] = 0h_FF;
    INIT pmpcfg1.read <-> memory_conf[2] = 0h_00 & memory_conf[3] = 0h_00;
    INIT !pmpcfg1.write <-> memory_integrity[2] = 0h_FF & memory_integrity[3] = 0h_FF;
    INIT pmpcfg1.write <-> memory_integrity[2] = 0h_00 & memory_integrity[3] = 0h_00;
    INIT priv <-> mesp_conf = 0h_00;
    INIT priv <-> mesp_integrity = 0h_00;
    INIT !priv <-> mesp_conf = 0h_FF;
    INIT !priv <-> mesp_integrity = 0h_FF;

    IVAR
        op : {
            LOAD, STORE, LOADI, ADD, SUB, AND, OR, MOV, SLT, SLL, SRA,
            ECALL, MRET, CSRRS, CSRRC, SAN, CLR, SPSWAP
        };
        rd : 0..3;
        rs1 : 0..3;
        rs2 : 0..3;
        m_external_interrupt : unsigned word[1];
    DEFINE
        csr_rs := rs1 mod 2;

    DEFINE
        -- TODO: Throw on a load without privileges?
        can_load := (priv
            ? (rs1 < REGION0_SIZE
                ? (!pmpcfg0.locked | pmpcfg0.read)
                : (!pmpcfg1.locked | pmpcfg1.read)
            )
            : (rs1 < REGION0_SIZE
                ? pmpcfg0.read
                : pmpcfg1.read
            ));
        -- TODO: Throw on a write without privileges?
        can_write := (priv
            ? (rd < REGION0_SIZE
                ? (!pmpcfg0.locked | pmpcfg0.write)
                : (!pmpcfg1.locked | pmpcfg1.write)
            )
            : (rd < REGION0_SIZE
                ? pmpcfg0.write
                : pmpcfg1.write
            ));

    -- privelege mode transitions
    TRANS next(priv) = case
        do_trap: TRUE;
        op = MRET: bool(MPP);
        TRUE: priv;
    esac;

    -- mstatus
    -- Scale m_external_interrupt to a bitmask
    DEFINE
        csr_write_mask := __csrs_write_privs[csr_rs] -> __priv_vec;
        __meip_input := resize(m_external_interrupt, XLEN) << 3;
    TRANS next(mstatus) = (__meip_input | (do_trap
        ?   pmacfg                  -- preserve pmacfg
            :: 0b_00                -- MEIP := 0 and MIE := 0
            :: MIE                  -- MPIE := MIE
            :: word1(priv)          -- MPP := priv
        : case
            priv & op = MRET: mstatus[7:3] :: MPIE :: 0b_10;
            csr_rs != 0: mstatus;
            op = CSRRC: mstatus & (unsigned(regs[rs2]) | !csr_write_mask | __mstatus_high_guard);
            op = CSRRS: mstatus | (unsigned(regs[rs2]) & csr_write_mask & __mstatus_low_guard);
            -- on a trap return, set MPIE to 1 and MPP to user mode
            TRUE: mstatus;     -- do nothing on all others ops that do not trap
        esac));

    TRANS next(pmpcfg) = case
            do_trap | csr_rs != 1: pmpcfg;
            op = CSRRC: pmpcfg & (unsigned(regs[rs2]) | !csr_write_mask | (
                (pmpcfg1.locked ? 0h_F : 0h_0) :: (pmpcfg0.locked ? 0h_F : 0h_0)
            ));
            op = CSRRS: pmpcfg | (unsigned(regs[rs2]) & csr_write_mask & (
                (pmpcfg1.locked ? 0h_0 : 0h_F) :: (pmpcfg0.locked ? 0h_0 : 0h_F)
            ));
            TRUE: pmpcfg;
        esac;

    TRANS next(mesp) = (priv & op = SPSWAP ? regs[0] : mesp);
    TRANS next(mesp_conf) = (priv & op = SPSWAP ? regs_conf[0] : mesp_conf);
    TRANS next(mesp_integrity) = (priv & op = SPSWAP
        ? regs_integrity[0]
        : mesp_integrity);

    DEFINE
        csr_read_mask := __csrs_read_privs[csr_rs] -> __priv_vec;
    -- register transitions
    #define next_reg(i) \
        (case \
            priv & op = SPSWAP & i = 0: mesp; \
            rd != i | do_trap: regs[i]; \
            op = LOAD & can_load: cache.__read; \
            op = ADD: regs[rs1] + regs[rs2]; \
            op = SUB: regs[rs1] - regs[rs2]; \
            op = AND: regs[rs1] & regs[rs2]; \
            op = OR: regs[rs1] | regs[rs2]; \
            op = MOV: regs[rs1]; \
            op = SLT: regs[rs1] < regs[rs2] ? 0sh_01 : 0sh_00; \
            op = SLL: regs[rs1] << clamp(toint(regs[rs2]), 0, XLEN); \
            op = SRA: regs[rs1] >> clamp(toint(regs[rs2]), 0, XLEN); \
            op = CSRRS | op = CSRRC: signed(csrs[csr_rs] & csr_read_mask); \
            TRUE: regs[i]; \
        esac)

    #define loadi_targeted(i) (rd = i & op = LOADI & !do_trap)
    TRANS loadi_targeted(0) | (next(regs)[0] = next_reg(0));
    TRANS loadi_targeted(1) | (next(regs)[1] = next_reg(1));
    TRANS loadi_targeted(2) | (next(regs)[2] = next_reg(2));
    TRANS loadi_targeted(3) | (next(regs)[3] = next_reg(3));

    -- Cast conf reg to signed on right shift for correct sign extension
    #define next_reg_conf(i) \
        (case \
            do_trap: regs_conf[i]; \
            priv & op = SPSWAP & i = 0: mesp_conf; \
            op = CLR: 0h_00; \
            rd != i: regs_conf[i]; \
            op = LOAD & can_load: cache.__read_conf; \
            op = LOADI: unsigned(resize(signed(word1(priv)), XLEN)); \
            op = ADD: least_one_extended(regs_conf[rs1] | regs_conf[rs2]); \
            op = SUB: least_one_extended(regs_conf[rs1] | regs_conf[rs2]); \
            op = SLT: (0h_00 < regs_conf[rs1] | 0h_00 < regs_conf[rs2] ? 0h_01 : 0h_00); \
            op = SLL: regs_conf[rs1] << clamp(toint(regs[rs2]), 0, XLEN); \
            op = SRA: unsigned(signed(regs_conf[rs1]) >> clamp(toint(regs[rs2]), 0, XLEN)); \
            op = CSRRS | op = CSRRC: __csrs_conf[csr_rs] & csr_read_mask; \
            TRUE: regs_conf[i]; \
        esac)

    TRANS next(regs_conf)[0] = next_reg_conf(0);
    TRANS next(regs_conf)[1] = next_reg_conf(1);
    TRANS next(regs_conf)[2] = next_reg_conf(2);
    TRANS next(regs_conf)[3] = next_reg_conf(3);

    -- This pseudo-function casts a signed bitvector into an int in the range of
    -- [0, 8] by hand. Doing this with the macro clamp leads to a bug when used
    -- in a bit-shift, cf. https://essvn.fbk.eu/bugs/view.php?id=5410.
    #define clamp_buggy(w) (case \
        w < 0sd8_0: 0; \
        0sd8_8 <= w: 8; \
        TRUE: toint(resize(unsigned(w), 3)); \
    esac)

    #define next_reg_integrity(i) \
        (case \
            do_trap: regs_integrity[i]; \
            priv & op = SPSWAP & i = 0: mesp_integrity; \
            op = SAN: 0h_FF; \
            rd != i: regs_integrity[i]; \
            op = LOAD & can_load: cache.__read_integrity; \
            op = LOADI: (priv ? 0h_FF : 0h_00); \
            op = ADD: least_one_extended( \
                regs_integrity[rs1] & regs_integrity[rs2] \
            ); \
            op = SUB: least_one_extended( \
                regs_integrity[rs1] & regs_integrity[rs2] \
            ); \
            op = SLT: (priv ? 0h_FE : 0h_00) | ( \
                    0h_FF = (regs_integrity[rs1] & regs_integrity[rs2]) \
                        ? 0h_FF \
                        : 0h_00 \
                ); \
            op = SLL: ( \
                (priv ? 0h_FF : 0h_00) >> (XLEN - clamp_buggy(regs[rs2])) \
            ) | (regs_integrity[rs1] << clamp(toint(regs[rs2]), 0, XLEN)); \
            op = SRA: ( \
                (priv ? 0h_FF : 0h_00) << (XLEN - clamp_buggy(regs[rs2])) \
            ) | (regs_integrity[rs1] >> clamp(toint(regs[rs2]), 0, XLEN)); \
            op = CSRRS | op = CSRRC: __csrs_integrity[csr_rs] & csr_read_mask; \
            TRUE: regs_integrity[i]; \
        esac)

    TRANS next(regs_integrity)[0] = next_reg_integrity(0);
    TRANS next(regs_integrity)[1] = next_reg_integrity(1);
    TRANS next(regs_integrity)[2] = next_reg_integrity(2);
    TRANS next(regs_integrity)[3] = next_reg_integrity(3);

    -- memory transitions
    #define store_targeted(i) (rd = i & !do_trap & op = STORE & can_write \
        & (i < REGION0_SIZE ? !pmacfg0.write_back : !pmacfg1.write_back))
    #define try_store(i, r_source, mem_source, write_back_source) \
        (case \
            store_targeted(i): r_source[rs1]; \
            cache.addr = i & next(cache.addr) != i & cache.valid \
            & (i < REGION0_SIZE ? pmacfg0.write_back : pmacfg1.write_back): \
                write_back_source; \
            TRUE: mem_source[i]; \
        esac)
    TRANS next(memory)[0] = try_store(0, regs, memory, cache.__read);
    TRANS next(memory)[1] = try_store(1, regs, memory, cache.__read);
    TRANS next(memory)[2] = try_store(2, regs, memory, cache.__read);
    TRANS next(memory)[3] = try_store(3, regs, memory, cache.__read);

    TRANS next(memory_conf)[0] = try_store(
        0,
        regs_conf,
        memory_conf,
        cache.conf
    );
    TRANS next(memory_conf)[1] = try_store(
        1,
        regs_conf,
        memory_conf,
        cache.conf
    );
    TRANS next(memory_conf)[2] = try_store(
        2,
        regs_conf,
        memory_conf,
        cache.conf
    );
    TRANS next(memory_conf)[3] = try_store(
        3,
        regs_conf,
        memory_conf,
        cache.conf
    );

    TRANS next(memory_integrity)[0] = try_store(
        0,
        regs_integrity,
        memory_integrity,
        cache.integrity
    );
    TRANS next(memory_integrity)[1] = try_store(
        1,
        regs_integrity,
        memory_integrity,
        cache.integrity
    );
    TRANS next(memory_integrity)[2] = try_store(
        2,
        regs_integrity,
        memory_integrity,
        cache.integrity
    );
    TRANS next(memory_integrity)[3] = try_store(
        3,
        regs_integrity,
        memory_integrity,
        cache.integrity
    );

    -- This property is here to be targeted by the user to check whether the
    -- model is syntactically correct without starting expensive proofs.
    LTLSPEC NAME SYNTAX_CANARY := TRUE;

    -- The following properties about information leakage are incremental:
    -- Confidential information can never leak into user mode
    LTLSPEC NAME NO_LEAK := G (priv | (
        regs_conf[0] = 0h_00
        & regs_conf[1] = 0h_00
        & regs_conf[2] = 0h_00
        & regs_conf[3] = 0h_00
    ));
    -- ... if machine mode clears its registers before returning
    LTLSPEC NAME NO_LEAK_SANITIZED :=
        G (
            priv & op = MRET
            -> regs_conf[0] = 0h_00
                & regs_conf[1] = 0h_00
                & regs_conf[2] = 0h_00
                & regs_conf[3] = 0h_00
        )
        -> G (priv | (
            regs_conf[0] = 0h_00
            & regs_conf[1] = 0h_00
            & regs_conf[2] = 0h_00
            & regs_conf[3] = 0h_00
        ));
    -- ... and if machine mode does not declassify memory regions that have
    -- confidential data in them
    LTLSPEC NAME NO_LEAK_SANITIZED_NO_MEM_DECLASSIFICATION :=
            G (
                priv & op in { CSRRS, CSRRC } & 0 < rs1
                ->
                    ((0h_00 = memory_conf[0] & 0h_00 = memory_conf[1]
                        & (cache.valid & cache.addr < REGION0_SIZE
                            -> 0h_00 = cache.conf
                        ))
                        | X !pmpcfg0.read)
                    & ((0h_00 = memory_conf[2] & 0h_00 = memory_conf[3]
                        & (cache.valid & REGION0_SIZE <= cache.addr
                            -> 0h_00 = cache.conf
                        ))
                        | X !pmpcfg1.read)
                )
            & G (priv & op = STORE -> rd < REGION0_SIZE)
            & G (
                priv & op = MRET
                -> regs_conf[0] = 0h_00
                    & regs_conf[1] = 0h_00
                    & regs_conf[2] = 0h_00
                    & regs_conf[3] = 0h_00
            )
        -> G (priv | (
                regs_conf[0] = 0h_00
                & regs_conf[1] = 0h_00
                & regs_conf[2] = 0h_00
                & regs_conf[3] = 0h_00
            ));
    -- ... and if machine mode does not write into memory that is publicly readable
    LTLSPEC NAME NO_LEAK_SANITIZED_NO_USE_DECLASSIFIED_MEM :=
            G (
                priv & op in { CSRRS, CSRRC } & 0 < rs1
                ->
                    ((0h_00 = memory_conf[0] & 0h_00 = memory_conf[1]
                        & (cache.valid & cache.addr < REGION0_SIZE
                            -> 0h_00 = cache.conf
                        ))
                        | X !pmpcfg0.read)
                    & ((0h_00 = memory_conf[2] & 0h_00 = memory_conf[3]
                        & (cache.valid & REGION0_SIZE <= cache.addr
                            -> 0h_00 = cache.conf
                        ))
                        | X !pmpcfg1.read)
            )
            & G (
                priv & op = STORE & 0h_00 < regs_conf[rs1]
                -> (rd < REGION0_SIZE ? !pmpcfg0.read : !pmpcfg1.read)
            )
            & G (
                priv & op = MRET
                -> regs_conf[0] = 0h_00
                    & regs_conf[1] = 0h_00
                    & regs_conf[2] = 0h_00
                    & regs_conf[3] = 0h_00
            )
        -> G (priv | (
            regs_conf[0] = 0h_00
            & regs_conf[1] = 0h_00
            & regs_conf[2] = 0h_00
            & regs_conf[3] = 0h_00
        ));

    -- Control and status registers are only written with machine-mode
    -- controlled values
    LTLSPEC NAME NO_INFLUENCE :=
        G (
            priv & op in { CSRRS, CSRRC }
            -> regs_integrity[rs2] = 0h_FF
        );
    -- ... and if machine mode only loads from regions user-mode can't write to
    LTLSPEC NAME NO_INFLUENCE_NO_PUBLIC_READS :=
        G (priv & op = LOAD -> (rs1 < REGION0_SIZE ? !pmpcfg0.write : !pmpcfg1.write))
        -> G (
            priv & op in { CSRRS, CSRRC }
            -> regs_integrity[rs2] = 0h_FF
        );
    -- ... if machine-mode sanitizes user-mode input
    LTLSPEC NAME NO_INFLUENCE_NO_PUBLIC_READS_SANITIZED :=
        G (!priv & X priv -> X (op = SAN))
        & G (priv & op = LOAD -> (rs1 < REGION0_SIZE ? !pmpcfg0.write : !pmpcfg1.write))
        -> G (
            priv & op in { CSRRS, CSRRC }
            -> regs_integrity[rs2] = 0h_FF
        );
    -- ... and if machine-mode does not allocate memory unsanitized
    LTLSPEC NAME NO_INFLUENCE_NO_PUBLIC_READS_SANITIZED_NO_DECLASSIFICATION :=
        G (!priv & X priv -> X (op = SAN))
        & G (priv & op = LOAD -> (rs1 < REGION0_SIZE ? !pmpcfg0.write : !pmpcfg1.write))
        & G (
                priv & op in { CSRRC, CSRRS }
            -> (
                pmpcfg0.write & X !pmpcfg0.write
                -> memory_integrity[0] = 0h_FF & memory_integrity[1] = 0h_FF
            ) & (
                pmpcfg1.write & X !pmpcfg1.write
                -> memory_integrity[2] = 0h_FF & memory_integrity[3] = 0h_FF
            )
        )
        -> G (
            priv & op in { CSRRS, CSRRC }
            -> regs_integrity[rs2] = 0h_FF
        );

    LTLSPEC NAME SYSRET :=
            G (Y !priv & priv -> op = SPSWAP)
            & G (priv & rd != 0)
        -> G !(priv & regs_integrity[0] = 0h_00 & do_trap);
