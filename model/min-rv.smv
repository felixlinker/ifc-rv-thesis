
#define OPLEN 4
#define RADDRLEN 4
#define RLEN 16
-- #define CSRADDRLEN 1
-- #define CSRLEN 2
#define XLEN 16
--// = OPLEN + 3 * RADDRLEN
#define EXMEMADDRLEN 3
#define EXMEMLEN 16
#define RMEMADDRLEN 3
#define RMEMLEN 16
#define MEMADDRLEN (EXMEMADDRLEN + 1)
#define MEMLEN (EXMEMLEN + RMEMADDRLEN)

MODULE main
    FROZENVAR
        executable_memory : array 0..(EXMEMLEN - 1) of unsigned word[XLEN];
    VAR
        memory : array 0..(RMEMLEN - 1) of signed word[XLEN];
        priv : {machine, user};
        regs : array 0..(RLEN - 1) of signed word[XLEN];
        pc : unsigned word[MEMADDRLEN];

    DEFINE
        --// op-codes
        LUI := 0h_0;  --// load upper immediate
        LLI := 0h_1;  --// load lower immediate
        AUIPC := 0h_2;  --// add upper immediate to PC
        ADD := 0h_3;  --// add
        SUB := 0h_4;  --// subtract
        SLT := 0h_5;  --// set if less
        SLL := 0h_6;  --// shift left logically
        SRA := 0h_7;  --// shift right arithmetically
        JALR := 0h_8;  --// jump and link register
        LW := 0h_9;  --// load word
        CSRRS := 0h_A;  --// csr read and set
        CSRRC := 0h_B;  --// csr read and clear
        --// Opcodes >= 0h_C don't have rd
        BNL := 0h_C;  --// branch if not low
        SW := 0h_D;  --// store word
        ECALL := 0h_E;  --// environment call
        MRET := 0h_F;  --// machine return

        --// machine constants
        reset_addr := 4;
        trap_vector := 0uh_0;
        vectored := FALSE;

        --// instruction stream decoding
        op_code := executable_memory[pc][3:0];
        rd := executable_memory[pc][7:4];
        rd_int := toint(rd);
        csr_rd := resize(rd, CSRADDRLEN);
        rs1 := executable_memory[pc][11:8];
        rs2 := executable_memory[pc][15:12];
        imm_short := executable_memory[pc][15:12];
        imm := executable_memory[pc][15:8];
        op_result := case
            op_code = LUI : signed(resize(imm, XLEN) << 8);
            op_code = LLI : signed(resize(imm, XLEN));
            --// TODO: It's idiotic to use AUIPC because our memory is too small
            op_code = AUIPC : resize(
                signed(pc) + signed(resize(imm << 8, MEMADDRLEN)),
                XLEN
            );
            op_code = ADD : regs[rs1] + regs[rs2];
            op_code = SUB : regs[rs1] - regs[rs2];
            op_code = SLT : (regs[rs1] < regs[rs2] ? 0sh_0001 : 0sh_0000);
            op_code = SLL : regs[rs1] << toint(regs[rs2]);
            op_code = SRA : regs[rs1] >> toint(regs[rs2]);
            --// result is return address
            op_code = JALR : signed(resize(pc + 0uh_1, XLEN));
            op_code = LW : memory[
                resize(unsigned(regs[rs1]) + resize(rs2, XLEN), MEMADDRLEN)
            ];
            (op_code = CSRRS) | (op_code = CSRRC): mstatus;
        esac;

        --// processor state
        -- TODO: there are more possibilities to take exceptions
        interrupt_taken := mstatus.MIE & (
            (mstatus.MEIP & mstatus.MEIE) | (mstatus.MSIP & mstatus.MSIE)
        );
        exception_taken := interrupt_taken | op_code = ECALL;
        trap_return := op_code = MRET & priv = machine;

    VAR
        mstatus : unsigned word[XLEN];
    #define MIE 0:0
    #define MPIE 1:1
    #define MPP 2:2
    #define MEIP 3:3
    #define UEIP 4:4
    #define USIP 5:5
    #define MEIE 6:6
    #define UEIE 7:7
    #define USIE 8:8
    #define MCAUSE_INTERRUPT 9:9
    #define MCAUSE 11:10
    #define MEPC 15:12

    #define UEI 0
    #define MEI 1
    #define USI 2
    #define ECALL_FROM_U 0
    #define ECALL_FROM_M 1

    DEFINE
        highest_pending := case
            bool(mstatus[MEIP]) : MEI;
            bool(mstatus[UEIP]) : UEI;
            bool(mstatus[USIP]) : USI;
            !interrupt_taken : (priv = user
                ? ECALL_FROM_U
                : ECALL_FROM_M);
        esac;

    --// mstatus
    --// TODO: Make
    TRANS next(mstatus) = (exception_taken
        ? ( next(mstatus)[MIE] = 0b_0 &
            next(mstatus)[MPIE] = mstatus[0:0] &
            next(mstatus)[MPP] = case
                priv = machine: 0b_1;
                TRUE: 0b_0;
            esac &
            next(mstatus)[MCAUSE_INTERRUPT] = word1(interrupt_taken) &
            next(mstatus)[MCAUSE] = highest_pending &
            next(mstatus)[MEPC] = pc
        )
        : (trap_return
            ? mstatus
            : case
                op_code = CSRRS : mstatus | regs[rs1];
                op_code = CSRRC : mstatus & regs[rs1];
                TRUE : mstatus;
            esac));

    --// Register transitions
    #define TRANS_R_REL( i ) \
        next(regs)[i] = (((i != rd_int) | BNL <= op_code) \
            ? regs[i] \
            : op_result)
    TRANS TRANS_R_REL(0);
    TRANS TRANS_R_REL(1);
    TRANS TRANS_R_REL(2);
    TRANS TRANS_R_REL(3);
    TRANS TRANS_R_REL(4);
    TRANS TRANS_R_REL(5);
    TRANS TRANS_R_REL(6);
    TRANS TRANS_R_REL(7);
    TRANS TRANS_R_REL(8);
    TRANS TRANS_R_REL(9);
    TRANS TRANS_R_REL(10);
    TRANS TRANS_R_REL(11);
    TRANS TRANS_R_REL(12);
    TRANS TRANS_R_REL(13);
    TRANS TRANS_R_REL(14);
    TRANS TRANS_R_REL(15);

    TRANS next(pc) = (exception_taken
        --// trap
        ? trap_vector
        : case
            --// jump
            op_code = JALR : resize(
                regs[rs1] + resize(imm_short, XLEN),
                MEMADDRLEN
            );
            --// branch
            (op_code = BNL) & (regs[rd] != 0uh_0000): pc + unsigned(resize(
                imm,
                MEMADDRLEN
            ));
            --// trap-return
            trap_return : resize(mstatus.MEPC, MEMADDRLEN);
            --// advance
            TRUE: pc + 0uh_1;
        esac);

    TRANS next(priv) = (exception_taken
        --// always trap into machine mode
        ? machine
        : (trap_return
            --// return from trap into mode we originated from
            ? case
                mstatus.MPP: machine
                TRUE: user
            esac
            --// else stable
            : priv));
