
#define XLEN 8

#define least_one_extended(w) \
    (0h_00 < (w & 0h_FF) \
        ? (0h_00 < (w & 0h_0F) \
            ? (0h_00 < (w & 0h_03) \
                ? (0h_00 < (w & 0h_01) ? 0h_FF : 0h_FE) \
                : (0h_00 < (w & 0h_04) ? 0h_FC : 0h_F8) \
            ) \
            : (0h_00 < (w & 0h_30) \
                ? (0h_00 < (w & 0h_10) ? 0h_F0 : 0h_E0) \
                : (0h_00 < (w & 0h_40) ? 0h_C0 : 0h_80) \
            )) \
        : 0h_00)

#define clamp(v, l, h) (min(max((v), l), h))

MODULE main
    VAR
        priv : boolean;
        mstatus : unsigned word[XLEN];
        regs : array 0..3 of signed word[XLEN];
        regs_conf : array 0..3 of unsigned word[XLEN];
        regs_integrity : array 0..3 of unsigned word[XLEN];
        memory : array 0..3 of signed word[XLEN];
        memory_conf : array 0..3 of unsigned word[XLEN];
        memory_integrity : array 0..3 of unsigned word[XLEN];

    DEFINE init_conf := [ 0h_FF, 0h_FF, 0h_FF, 0h_FF ];
        mem_init_conf := [ 0h_FF, 0h_FF, 0h_00, 0h_00 ];
        init_integrity := [ 0h_FF, 0h_FF, 0h_FF, 0h_FF ];
        mem_init_integrity := [ 0h_FF, 0h_FF, 0h_00, 0h_00 ];

    INIT priv = TRUE;
    -- Initialize mstatus to have interrupts enable and nothing else
    INIT mstatus = 0b_00000110;
    INIT regs_conf = init_conf;
    INIT memory_conf = mem_init_conf;
    INIT regs_integrity = init_integrity;
    INIT memory_integrity = mem_init_integrity;

    DEFINE
        mem_read_privs := [ TRUE, TRUE, FALSE, FALSE ];
        write_mem_privs := [ TRUE, TRUE, FALSE, FALSE ];
        MPP := mstatus[0:0];
        MPIE := mstatus[1:1];
        MIE := mstatus[2:2] | word1(!priv);
        MEIP := mstatus[3:3];
        MSIP := mstatus[4:4];
        mscratch := mstatus[5:5];
        mcause := mstatus[7:6];

        do_trap := (op = ECALL) | (bool(MIE) & bool(MEIP | MSIP));

    IVAR
        op : {LOAD, STORE, LOADI, ADD, SUB, ECALL, MRET, SLT, SLL, SRA, CSRRS, CSRRC};
        rd : 0..3;
        rs1 : 0..3;
        rs2 : 0..3;

    -- privelege mode transitions
    TRANS next(priv) = case
        op = MRET: bool(MPP);
        op = ECALL: TRUE;
        TRUE: priv;
    esac;

    -- mstatus
    TRANS next(mstatus) = (do_trap
        ? (case                     -- set mcause
                bool(MEIP): 0b_00;
                bool(MSIP): 0b_01;
                TRUE: 0b_10;        -- op = ECALL
            esac)
            :: mstatus[5:5]         -- preserve mscratch
            :: (MEIP & MSIP)        -- MSIP can only be taken if !MEIP
            :: 0b_00                -- MEIP := 0 and MIE := 0
            :: MIE                  -- MPIE := MIE
            :: word1(priv)          -- MPP := priv
        : case
            !priv: mstatus;     -- ignore unprivileged writes
            op = CSRRC: mstatus & unsigned(regs[rs1]);
            op = CSRRS: mstatus | unsigned(regs[rs1]);
            -- on a trap return, set MPIE to 1 and MPP to user mode
            op = MRET: mstatus[7:2] :: 0b_10;
            TRUE: mstatus;      -- do nothing on all others ops that do not trap
        esac);

    -- register transitions
    #define next_reg(i) \
        (case \
            priv & op = MRET & !next(priv): 0sh_00; \
            rd != i: regs[i]; \
            op = LOAD & (mem_read_privs[rs1] -> priv): memory[rs1]; \
            op = ADD: regs[rs1] + regs[rs2]; \
            op = SUB: regs[rs1] - regs[rs2]; \
            op = SLT: regs[rs1] < regs[rs2] ? 0sh_01 : 0sh_00; \
            op = SLL: regs[rs1] << clamp(toint(regs[rs2]), 0, 8); \
            op = SRA: regs[rs1] >> clamp(toint(regs[rs2]), 0, 8); \
            priv & (op = CSRRS | op = CSRRC): signed(mstatus); \
            TRUE: regs[i]; \
        esac)

    #define loadi_targeted(i) (rd = i & op = LOADI)
    TRANS loadi_targeted(0) | (next(regs)[0] = next_reg(0));
    TRANS loadi_targeted(1) | (next(regs)[1] = next_reg(1));
    TRANS loadi_targeted(2) | (next(regs)[2] = next_reg(2));
    TRANS loadi_targeted(3) | (next(regs)[3] = next_reg(3));

    -- Cast conf reg to signed on right shift for correct sign extension
    #define next_reg_conf(i) \
        (case \
            priv & op = MRET & !next(priv): 0h_00; \
            rd != i: regs_conf[i]; \
            op = LOAD & (mem_read_privs[rs1] -> priv): memory_conf[rs1]; \
            op = LOADI: unsigned(resize(signed(word1(priv)), 8)); \
            op = ADD: least_one_extended(regs_conf[rs1] | regs_conf[rs2]); \
            op = SUB: least_one_extended(regs_conf[rs1] | regs_conf[rs2]); \
            op = SLT: (0h_00 < regs_conf[rs1] | 0h_00 < regs_conf[rs2] ? 0h_01 : 0h_00); \
            op = SLL: regs_conf[rs1] << clamp(toint(regs[rs2]), 0, 8); \
            op = SRA: unsigned(signed(regs_conf[rs1]) >> clamp(toint(regs[rs2]), 0, 8)); \
            priv & (op = CSRRS | op = CSRRC): 0h_FF; \
            TRUE: regs_conf[i]; \
        esac)

    TRANS next(regs_conf)[0] = next_reg_conf(0);
    TRANS next(regs_conf)[1] = next_reg_conf(1);
    TRANS next(regs_conf)[2] = next_reg_conf(2);
    TRANS next(regs_conf)[3] = next_reg_conf(3);

    -- This pseudo-function casts a signed bitvector into an int in the range of
    -- [0, 8] by hand. Doing this with the macro clamp leads to a bug when used
    -- in a bit-shift, cf. https://essvn.fbk.eu/bugs/view.php?id=5410.
    #define clamp_buggy(w) (case \
        w < 0sd8_0: 0; \
        0sd8_8 <= w: 8; \
        TRUE: toint(resize(unsigned(w), 3)); \
    esac)

    #define next_reg_integrity(i) \
        (case \
            rd != i: regs_integrity[i]; \
            op = LOADI: (priv ? 0h_FF : 0h_00); \
            op = ADD: least_one_extended( \
                regs_integrity[rs1] & regs_integrity[rs2] \
            ); \
            op = SUB: least_one_extended( \
                regs_integrity[rs1] & regs_integrity[rs2] \
            ); \
            op = SLT: (priv ? 0h_FE : 0h_00) | ( \
                    0h_FF = (regs_integrity[rs1] & regs_integrity[rs2]) \
                        ? 0h_FF \
                        : 0h_00 \
                ); \
            op = SLL: ( \
                (priv ? 0h_FF : 0h_00) >> (8 - clamp_buggy(regs[rs2])) \
            ) | (regs_integrity[rs1] << clamp(toint(regs[rs2]), 0, 8)); \
            op = SRA: ( \
                (priv ? 0h_FF : 0h_00) << (8 - clamp_buggy(regs[rs2])) \
            ) | (regs_integrity[rs1] >> clamp(toint(regs[rs2]), 0, 8)); \
            priv & (op = CSRRS | op = CSRRC): 0h_FF; \
            TRUE: regs_integrity[i]; \
        esac)

    TRANS next(regs_integrity)[0] = next_reg_integrity(0);
    TRANS next(regs_integrity)[1] = next_reg_integrity(1);
    TRANS next(regs_integrity)[2] = next_reg_integrity(2);
    TRANS next(regs_integrity)[3] = next_reg_integrity(3);

    -- memory transitions
    #define store_targeted(i) (rd = i & op = STORE \
        & (write_mem_privs[rd] -> priv))
    TRANS next(memory)[0] = (store_targeted(0) ? regs[rs1] : memory[0]);
    TRANS next(memory)[1] = (store_targeted(1) ? regs[rs1] : memory[1]);
    TRANS next(memory)[2] = (store_targeted(2) ? regs[rs1] : memory[2]);
    TRANS next(memory)[3] = (store_targeted(3) ? regs[rs1] : memory[3]);

    TRANS next(memory_conf)[0] = (store_targeted(0) ? regs_conf[rs1] : memory_conf[0]);
    TRANS next(memory_conf)[1] = (store_targeted(1) ? regs_conf[rs1] : memory_conf[1]);
    TRANS next(memory_conf)[2] = (store_targeted(2) ? regs_conf[rs1] : memory_conf[2]);
    TRANS next(memory_conf)[3] = (store_targeted(3) ? regs_conf[rs1] : memory_conf[3]);

    TRANS next(memory_integrity)[0] = (store_targeted(0)
        ? regs_integrity[rs1]
        : mem_init_integrity[0]);
    TRANS next(memory_integrity)[1] = (store_targeted(1)
        ? regs_integrity[rs1]
        : mem_init_integrity[1]);
    TRANS next(memory_integrity)[2] = (store_targeted(2)
        ? regs_integrity[rs1]
        : mem_init_integrity[2]);
    TRANS next(memory_integrity)[3] = (store_targeted(3)
        ? regs_integrity[rs1]
        : mem_init_integrity[3]);

    LTLSPEC G (priv | (regs_conf[0] = 0h_00 & regs_conf[1] = 0h_00 & regs_conf[2] = 0h_00 & regs_conf[3] = 0h_00));
